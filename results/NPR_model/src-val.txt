class CompilationUnitResolver extends Compiler { static class IntArrayList { public int [ ] list = new int [ 5 ] ; public int length = 0 ; public void add ( int i ) { } } HashtableOfObject requestedSources ; HashtableOfObject requestedKeys ; DefaultBindingResolver . BindingTables bindingTables ; boolean hasCompilationAborted ; public CompilationUnitResolver ( INameEnvironment environment , IErrorHandlingPolicy policy , Map settings , ICompilerRequestor requestor , IProblemFactory problemFactory ) { } public void accept ( ISourceType [ ] sourceTypes , PackageBinding packageBinding , AccessRestriction accessRestriction ) { } protected void beginToCompile ( ICompilationUnit [ ] sourceUnits , String [ ] bindingKeys ) { int sourceLength = sourceUnits . length ; int keyLength = bindingKeys . length ; int maxUnits = sourceLength + keyLength ; this . totalUnits = 0 ; this . unitsToProcess = new CompilationUnitDeclaration [ maxUnits ] ; int index = 0 ; this . requestedSources = new HashtableOfObject ( ) ; for ( int i = 0 ; i < sourceLength ; i ++ ) { ICompilationUnit sourceUnit = sourceUnits [ i ] ; CompilationUnitDeclaration parsedUnit ; CompilationResult unitResult = new CompilationResult ( sourceUnit , ( index ++ ) , maxUnits , this . options . maxProblemsPerUnit ) ; try { if ( options . verbose ) { System . out . println ( Messages . bind ( Messages . compilation_request , new String [ ] { String . valueOf ( ( ( index ++ ) + 1 ) ) , String . valueOf ( maxUnits ) , new String ( sourceUnit . getFileName ( ) ) } ) ) ; } if ( ( this . totalUnits ) < ( this . parseThreshold ) ) { parsedUnit = this . parser . parse ( sourceUnit , unitResult ) ; } else { parsedUnit = this . parser . dietParse ( sourceUnit , unitResult ) ; } this . lookupEnvironment . buildTypeBindings ( parsedUnit , null ) ; addCompilationUnit ( sourceUnit , parsedUnit ) ; this . requestedSources . put ( unitResult . getFileName ( ) , sourceUnit ) ; } finally { sourceUnits [ i ] = null ; } } this . requestedKeys = new HashtableOfObject ( ) ; for ( int i = 0 ; i < keyLength ; i ++ ) { BindingKeyResolver resolver = new BindingKeyResolver ( bindingKeys [ i ] , this , this . lookupEnvironment ) ; resolver . parse ( true ) ; CompilationUnitDeclaration parsedUnit = resolver . getCompilationUnitDeclaration ( ) ; if ( parsedUnit != null ) { char [ ] fileName = parsedUnit . compilationResult . getFileName ( ) ; Object existing = this . requestedKeys . get ( fileName ) ; if ( existing == null ) this . requestedKeys . put ( fileName , resolver ) ; else if ( existing instanceof ArrayList ) ( ( ArrayList ) ( existing ) ) . add ( resolver ) ; else { ArrayList list = new ArrayList ( ) ; list . add ( existing ) ; list . add ( resolver ) ; this . requestedKeys . put ( fileName , list ) ; } } else { <START_BUG> if ( resolver . isPackage ( ) ) { <END_BUG> char [ ] pkgName = CharOperation . concatWith ( resolver . compoundName ( ) , '.' ) ; this . requestedKeys . put ( pkgName , resolver ) ; } else { char [ ] key = resolver . getKey ( ) . toCharArray ( ) ; this . requestedKeys . put ( key , resolver ) ; } } } lookupEnvironment . completeTypeBindings ( ) ; } IBinding createBinding ( String key ) { } public static CompilationUnit convert ( CompilationUnitDeclaration compilationUnitDeclaration , char [ ] source , int apiLevel , Map options , boolean needToResolveBindings , WorkingCopyOwner owner , DefaultBindingResolver . BindingTables bindingTables , IProgressMonitor monitor ) { } protected static IErrorHandlingPolicy getHandlingPolicy ( ) { } protected static ICompilerRequestor getRequestor ( ) { } public void initializeParser ( ) { } public void process ( CompilationUnitDeclaration unit , int i ) { } protected void handleInternalException ( Throwable internalException , CompilationUnitDeclaration unit , CompilationResult result ) { } protected void handleInternalException ( org . eclipse . jdt . internal . compiler . problem . AbortCompilation abortException , CompilationUnitDeclaration unit ) { } public static void parse ( org . eclipse . jdt . core . ICompilationUnit [ ] compilationUnits , ASTRequestor astRequestor , int apiLevel , Map options , IProgressMonitor monitor ) { } public static CompilationUnitDeclaration parse ( ICompilationUnit sourceUnit , NodeSearcher nodeSearcher , Map settings ) { } public static void resolve ( org . eclipse . jdt . core . ICompilationUnit [ ] compilationUnits , String [ ] bindingKeys , ASTRequestor requestor , int apiLevel , Map options , IJavaProject javaProject , WorkingCopyOwner owner , IProgressMonitor monitor ) { } public static CompilationUnitDeclaration resolve ( ICompilationUnit sourceUnit , IJavaProject javaProject , NodeSearcher nodeSearcher , Map options , WorkingCopyOwner owner , IProgressMonitor monitor ) throws JavaModelException { } public static IBinding [ ] resolve ( final IJavaElement [ ] elements , int apiLevel , Map compilerOptions , IJavaProject javaProject , WorkingCopyOwner owner , IProgressMonitor monitor ) { } public void removeUnresolvedBindings ( CompilationUnitDeclaration compilationUnitDeclaration ) { } private void removeUnresolvedBindings ( TypeDeclaration type ) { } private void resolve ( org . eclipse . jdt . core . ICompilationUnit [ ] compilationUnits , String [ ] bindingKeys , ASTRequestor astRequestor , int apiLevel , Map compilerOptions , WorkingCopyOwner owner , IProgressMonitor monitor ) { } private void reportBinding ( Object key , ASTRequestor astRequestor , WorkingCopyOwner owner , CompilationUnitDeclaration unit ) { } private CompilationUnitDeclaration resolve ( CompilationUnitDeclaration unit , ICompilationUnit sourceUnit , NodeSearcher nodeSearcher , boolean verifyMethods , boolean analyzeCode , boolean generateCode ) { } public CompilationUnitDeclaration resolve ( ICompilationUnit sourceUnit , boolean verifyMethods , boolean analyzeCode , boolean generateCode ) { }
private static final String KEYWORD_ADD = "ADD" ; private static final String KEYWORD_PUT = "PUT" ; private static final String KEYWORD_REMOVE = "REMOVE" ; private static final String KEYWORD_INCREMENT = "INCREMENT" ; private static final String KEYWORD_MERGE = "MERGE" ; private static final String KEYWORD_UPSERT = "UPSERT" ; private static final Object EMPTY_VALUE = new Object ( ) ; private Map < String , Object > setEntries = new LinkedHashMap < String , Object > ( ) ; private List < OPair < String , Object > > addEntries = new ArrayList < OPair < String , Object > > ( ) ; private Map < String , OPair < String , Object > > putEntries = new LinkedHashMap < String , OPair < String , Object > > ( ) ; private List < OPair < String , Object > > removeEntries = new ArrayList < OPair < String , Object > > ( ) ; private Map < String , Number > incrementEntries = new LinkedHashMap < String , Number > ( ) ; private ODocument merge = null ; private String lockStrategy = "NONE" ; private OReturnHandler returnHandler = new ORecordCountHandler ( ) ; private OQuery < ? > query ; private OSQLFilter compiledFilter ; private String subjectName ; private OCommandParameters parameters ; private boolean upsertMode = false ; private boolean isUpsertAllowed = false ; private boolean updated = false ; @ SuppressWarnings ( "unchecked" ) public OCommandExecutorSQLUpdate parse ( final OCommandRequest iRequest ) { } public Object execute ( final Map < Object , Object > iArgs ) { } @ SuppressWarnings ( "unchecked" ) public boolean result ( final Object iRecord ) { } @ Override public String getSyntax ( ) { } @ Override public void end ( ) { } @ Override public int getSecurityOperationType ( ) { } protected void parseMerge ( ) { } protected String getBlock ( String fieldValue ) { } protected void parseReturn ( ) throws OCommandSQLParsingException { } private boolean handleContent ( ODocument record ) { } private boolean handleMerge ( ODocument record ) { } private boolean handleSetEntries ( ODocument record ) { } private boolean handleIncrementEnries ( ODocument record ) { } private boolean handleAddEntries ( ODocument record ) { } @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private boolean handlePutEntries ( ODocument record ) { boolean updated = false ; if ( ! ( putEntries . isEmpty ( ) ) ) { for ( Map . Entry < String , OPair < String , Object > > entry : putEntries . entrySet ( ) ) { Object fieldValue = record . field ( entry . getKey ( ) ) ; if ( fieldValue == null ) { if ( ( record . getSchemaClass ( ) ) != null ) { final OProperty property = record . getSchemaClass ( ) . getProperty ( entry . getKey ( ) ) ; if ( ( property != null ) && ( ( ( property . getType ( ) ) != null ) && ( ( ! ( property . getType ( ) . equals ( EMBEDDEDMAP ) ) ) && ( ! ( property . getType ( ) . equals ( LINKMAP ) ) ) ) ) ) { throw new com . orientechnologies . orient . core . exception . OCommandExecutionException ( ( ( "field<seq2seq4repair_space>" + ( entry . getKey ( ) ) ) + "<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>defined<seq2seq4repair_space>as<seq2seq4repair_space>a<seq2seq4repair_space>map" ) ) ; } } fieldValue = new HashMap < String , Object > ( ) ; record . field ( entry . getKey ( ) , fieldValue ) ; } if ( fieldValue instanceof Map < ? , ? > ) { Map < String , Object > map = ( ( Map < String , Object > ) ( fieldValue ) ) ; OPair < String , Object > pair = entry . getValue ( ) ; Object value = extractValue ( record , pair ) ; if ( ( record . getSchemaClass ( ) ) != null ) { final OProperty property = record . getSchemaClass ( ) . getProperty ( entry . getKey ( ) ) ; if ( ( ( property != null ) && ( property . getType ( ) . equals ( LINKMAP ) ) ) && ( ! ( value instanceof OIdentifiable ) ) ) { throw new com . orientechnologies . orient . core . exception . OCommandExecutionException ( ( ( "field<seq2seq4repair_space>" + ( entry . getKey ( ) ) ) + "<seq2seq4repair_space>defined<seq2seq4repair_space>of<seq2seq4repair_space>type<seq2seq4repair_space>LINKMAP<seq2seq4repair_space>accept<seq2seq4repair_space>only<seq2seq4repair_space>link<seq2seq4repair_space>values" ) ) ; } } <START_BUG> if ( ( LINKMAP . equals ( record . fieldType ( entry . getKey ( ) ) ) ) && ( ! ( value instanceof OIdentifiable ) ) ) { <END_BUG> map = new com . orientechnologies . orient . core . db . record . OTrackedMap ( record , map , Object . class ) ; record . field ( entry . getKey ( ) , map , EMBEDDEDMAP ) ; } map . put ( pair . getKey ( ) , value ) ; updated = true ; } } } return updated ; } private boolean handleRemoveEntries ( ODocument record ) { } private boolean removeFromCollection ( boolean updated , Object value , Collection < ? > collection ) { } private boolean removeFromMap ( boolean updated , Object value , Map < ? , ? > map ) { } private boolean removeFromBag ( ODocument record , boolean updated , Object value , ORidBag bag ) { } private boolean removeSingleValueFromBag ( ORidBag bag , Object value , ODocument record ) { } private Object extractValue ( ODocument record , OPair < String , Object > entry ) { } private void parseAddFields ( ) { } private void parsePutFields ( ) { } private void parseRemoveFields ( ) { } private void parseIncrementFields ( ) { } }
public class GenericController extends AbstractTestElement implements Serializable , Controller , PerThreadClonable { protected List subControllersAndSamplers = new ArrayList ( ) ; protected int current ; protected Iterator controlIt ; private List configs = new LinkedList ( ) ; private boolean returnedNull = false ; private boolean done = false ; private boolean timeForNext = false ; private List assertions = new LinkedList ( ) ; public GenericController ( ) { } public boolean isNextFirst ( ) { } protected List getConfigElements ( ) { } private void addConfigElement ( TestElement el ) { } public void initialize ( ) { } public void reInitialize ( ) { } protected void removeCurrentController ( ) { } protected void resetCurrent ( ) { } protected void incrementCurrent ( ) { } protected boolean hasNextAtEnd ( ) { } protected void nextAtEnd ( ) { } public boolean hasNext ( ) { } protected void currentHasNextIsFalse ( ) { } protected boolean shortCircuitIsDone ( ) { } protected void setShortCircuit ( boolean done ) { } public boolean isDone ( ) { } protected TestElement getCurrentController ( ) { } protected List getSubControllers ( ) { } public void addTestElement ( TestElement child ) { } private void addController ( TestElement child ) { } public Sampler next ( ) { } public static class Test extends TestCase { public Test ( String name ) { } public void testProcessing ( ) throws Exception { GenericController controller = new GenericController ( ) ; GenericController sub_1 = new GenericController ( ) ; sub_1 . addTestElement ( makeSampler ( "one" ) ) ; sub_1 . addTestElement ( makeSampler ( "two" ) ) ; controller . addTestElement ( sub_1 ) ; controller . addTestElement ( makeSampler ( "three" ) ) ; GenericController sub_2 = new GenericController ( ) ; GenericController sub_3 = new GenericController ( ) ; sub_2 . addTestElement ( makeSampler ( "four" ) ) ; sub_3 . addTestElement ( makeSampler ( "five" ) ) ; sub_3 . addTestElement ( makeSampler ( "six" ) ) ; sub_2 . addTestElement ( sub_3 ) ; sub_2 . addTestElement ( makeSampler ( "seven" ) ) ; controller . addTestElement ( sub_2 ) ; String [ ] order = new String [ ] { "one" , "two" , "three" , "four" , "five" , "six" , "seven" } ; int counter = 7 ; for ( int i = 0 ; i < 2 ; i ++ ) { assertEquals ( 7 , counter ) ; counter = 0 ; while ( controller . hasNext ( ) ) { TestElement sampler = controller . next ( ) ; <START_BUG> assertEquals ( order [ ( counter ++ ) ] , sampler . getProperty ( NAME ) ) ; <END_BUG> } } } private TestElement makeSampler ( String name ) { } class TestSampler extends AbstractSampler implements PerSampleClonable { public void addCustomTestElement ( TestElement t ) { } public SampleResult sample ( Entry e ) { } } } }
class ASTConverter { private AST ast ; private char [ ] compilationUnitSource ; private Scanner scanner ; private boolean resolveBindings ; private Set pendingThisExpressionScopeResolution ; private Set pendingNameScopeResolution ; public ASTConverter ( Map options , boolean resolveBindings ) { } public void setAST ( AST ast ) { } public CompilationUnit convert ( CompilationUnitDeclaration unit , char [ ] source ) { } public PackageDeclaration convertPackage ( CompilationUnitDeclaration compilationUnitDeclaration ) { } public ImportDeclaration convertImport ( ImportReference importReference ) { } public TypeDeclaration convert ( org . eclipse . jdt . internal . compiler . ast . TypeDeclaration typeDeclaration ) { } private void buildBodyDeclarations ( org . eclipse . jdt . internal . compiler . ast . TypeDeclaration typeDeclaration , TypeDeclaration typeDecl ) { } private void checkAndAddMultipleFieldDeclaration ( FieldDeclaration [ ] fields , int index , List bodyDeclarations ) { } private void checkAndAddMultipleLocalDeclaration ( Statement [ ] stmts , int index , List blockStatements ) { } public Name convert ( TypeReference typeReference ) { } public SimpleName convert ( SingleNameReference nameReference ) { } public Name convert ( QualifiedNameReference nameReference ) { } private QualifiedName setQualifiedNameNameAndSourceRanges ( char [ ] [ ] typeName , long [ ] positions , AstNode node ) { } public Expression convert ( ThisReference reference ) { <START_BUG> if ( reference == ( ThisImplicit ) ) { <END_BUG> return null ; } else if ( reference instanceof QualifiedSuperReference ) { return convert ( ( ( QualifiedSuperReference ) ( reference ) ) ) ; } else if ( reference instanceof QualifiedThisReference ) { return convert ( ( ( QualifiedThisReference ) ( reference ) ) ) ; } else { ThisExpression thisExpression = this . ast . newThisExpression ( ) ; thisExpression . setSourceRange ( reference . sourceStart , ( ( ( reference . sourceEnd ) - ( reference . sourceStart ) ) + 1 ) ) ; if ( this . resolveBindings ) { recordNodes ( thisExpression , reference ) ; recordPendingThisExpressionScopeResolution ( thisExpression ) ; } return thisExpression ; } } public ThisExpression convert ( QualifiedThisReference reference ) { } public Name convert ( QualifiedSuperReference reference ) { } public ArrayAccess convert ( ArrayReference reference ) { } public Expression convert ( FieldReference reference ) { } public Expression convert ( Reference reference ) { } public Name convert ( NameReference reference ) { } public TypeDeclaration convert ( MemberTypeDeclaration typeDeclaration ) { } private void completeRecord ( ArrayType arrayType , AstNode astNode ) { } public Type convertType ( TypeReference typeReference ) { } public MethodDeclaration convert ( AbstractMethodDeclaration methodDeclaration ) { } public Expression convert ( org . eclipse . jdt . internal . compiler . ast . Expression expression ) { } public ParenthesizedExpression convertToParenthesizedExpression ( org . eclipse . jdt . internal . compiler . ast . Expression expression ) { } public ClassInstanceCreation convert ( AllocationExpression expression ) { } public ClassInstanceCreation convert ( AnonymousLocalTypeDeclaration expression ) { } private void buildBodyDeclarations ( AnonymousLocalTypeDeclaration expression , AnonymousClassDeclaration anonymousClassDeclaration ) { } public ArrayCreation convert ( ArrayAllocationExpression expression ) { } public SingleVariableDeclaration convert ( Argument argument ) { } public ArrayInitializer convert ( org . eclipse . jdt . internal . compiler . ast . ArrayInitializer expression ) { } public Expression convert ( QualifiedAllocationExpression expression ) { } public Assignment convert ( org . eclipse . jdt . internal . compiler . ast . Assignment expression ) { } public Assignment convert ( CompoundAssignment expression ) { } public PrefixExpression convert ( org . eclipse . jdt . internal . compiler . ast . PrefixExpression expression ) { } public PostfixExpression convert ( org . eclipse . jdt . internal . compiler . ast . PostfixExpression expression ) { } public CastExpression convert ( org . eclipse . jdt . internal . compiler . ast . CastExpression expression ) { } public Type convertToType ( NameReference reference ) { } public Expression convert ( ClassLiteralAccess expression ) { } public BooleanLiteral convert ( FalseLiteral expression ) { } public BooleanLiteral convert ( TrueLiteral expression ) { } public NullLiteral convert ( org . eclipse . jdt . internal . compiler . ast . NullLiteral expression ) { } public CharacterLiteral convert ( CharLiteral expression ) { } public NumberLiteral convert ( DoubleLiteral expression ) { } public NumberLiteral convert ( FloatLiteral expression ) { } public NumberLiteral convert ( IntLiteral expression ) { } public NumberLiteral convert ( IntLiteralMinValue expression ) { } public NumberLiteral convert ( LongLiteral expression ) { } public NumberLiteral convert ( LongLiteralMinValue expression ) { } public StringLiteral convert ( org . eclipse . jdt . internal . compiler . ast . StringLiteral expression ) { } public StringLiteral convert ( ExtendedStringLiteral expression ) { } public Expression convert ( BinaryExpression expression ) { } public PrefixExpression convert ( UnaryExpression expression ) { } public InstanceofExpression convert ( InstanceOfExpression expression ) { } public ConditionalExpression convert ( org . eclipse . jdt . internal . compiler . ast . ConditionalExpression expression ) { } public Expression convert ( MessageSend expression ) { } public Expression convert ( AND_AND_Expression expression ) { } public Expression convert ( EqualExpression expression ) { } public Expression convert ( OR_OR_Expression expression ) { } public Statement convert ( Statement statement ) { } public AssertStatement convert ( org . eclipse . jdt . internal . compiler . ast . AssertStatement statement ) { } public Block convert ( org . eclipse . jdt . internal . compiler . ast . Block statement ) { } public BreakStatement convert ( Break statement ) { } public ContinueStatement convert ( Continue statement ) { } public SwitchCase convert ( Case statement ) { } public SwitchCase convert ( DefaultCase statement ) { } public DoStatement convert ( org . eclipse . jdt . internal . compiler . ast . DoStatement statement ) { }
public ParameterMetaData getParameterMetaData ( ) throws SqlException { } private ParameterMetaData getParameterMetaDataX ( ) throws SqlException { } public void writeExecute ( Section section , ColumnMetaData parameterMetaData , Object [ ] inputs , int numInputColumns , boolean outputExpected , boolean chainedWritesFollowingSetLob ) throws SqlException { } public void readExecute ( ) throws SqlException { } public void writeOpenQuery ( Section section , int fetchSize , int resultSetType , int numInputColumns , ColumnMetaData parameterMetaData , Object [ ] inputs ) throws SqlException { } public void writeDescribeInput ( Section section ) throws SqlException { } public void readDescribeInput ( ) throws SqlException { } public void completeDescribeInput ( ColumnMetaData parameterMetaData , Sqlca sqlca ) { } public void writeDescribeOutput ( Section section ) throws SqlException { } public void readDescribeOutput ( ) throws SqlException { } public void completeDescribeOutput ( ColumnMetaData resultSetMetaData , Sqlca sqlca ) { } void writePrepareDescribeInputOutput ( ) throws SqlException { } void readPrepareDescribeInputOutput ( ) throws SqlException { } void writePrepareDescribeInput ( ) throws SqlException { } void readPrepareDescribeInput ( ) throws SqlException { } void completePrepareDescribe ( ) { } private Object [ ] expandObjectArray ( Object [ ] array , int newLength ) { } private boolean [ ] expandBooleanArray ( boolean [ ] array , int newLength ) { } void flowPrepareForSelectFromInsert ( ) throws SqlException { } void writePrepareDescribeInputOutput ( String sql , Section section ) throws SqlException { } void flowPrepareDescribeInputOutput ( ) throws SqlException { } void flowExecute ( int executeType ) throws SqlException { super . checkForClosedStatement ( ) ; super . clearWarningsX ( ) ; super . checkForAppropriateSqlMode ( executeType , sqlMode_ ) ; checkThatAllParametersAreSet ( ) ; if ( ( sqlMode_ ) == ( isUpdate__ ) ) { updateCount_ = 0 ; } else { updateCount_ = - 1 ; } Timer queryTimer = null ; QueryTimerTask queryTimerTask = null ; if ( ( timeout_ ) != 0 ) { queryTimer = new Timer ( ) ; queryTimerTask = new QueryTimerTask ( this , queryTimer ) ; queryTimer . schedule ( queryTimerTask , ( 1000 * ( timeout_ ) ) ) ; } try { agent_ . beginWriteChain ( this ) ; boolean piggybackedAutocommit = super . writeCloseResultSets ( true ) ; int numInputColumns = ( ( parameterMetaData_ ) != null ) ? parameterMetaData_ . getColumnCount ( ) : 0 ; boolean outputExpected = ( ( resultSetMetaData_ ) != null ) && ( ( resultSetMetaData_ . getColumnCount ( ) ) > 0 ) ; boolean chainAutoCommit = false ; boolean commitSubstituted = false ; boolean repositionedCursor = false ; ResultSet scrollableRS = null ; switch ( sqlMode_ ) { case isUpdate__ : if ( ( positionedUpdateCursorName_ ) != null ) { scrollableRS = sectionManager_ . getPositionedUpdateResultSet ( positionedUpdateCursorName_ ) ; } if ( ( scrollableRS != null ) && ( ! ( scrollableRS . isRowsetCursor_ ) ) ) { repositionedCursor = scrollableRS . repositionScrollableResultSetBeforeJDBC1PositionedUpdateDelete ( ) ; if ( ! repositionedCursor ) { scrollableRS = null ; } } chainAutoCommit = ( connection_ . willAutoCommitGenerateFlow ( ) ) && ( isAutoCommittableStatement_ ) ; if ( ( ( sqlUpdateMode_ ) == ( isInsertSql__ ) ) && ( ( generatedKeysColumnNames_ ) != null ) ) { writeOpenQuery ( section_ , fetchSize_ , resultSetType_ , numInputColumns , parameterMetaData_ , parameters_ ) ; } else { boolean chainOpenQueryForAutoGeneratedKeys = ( ( sqlUpdateMode_ ) == ( isInsertSql__ ) ) && ( ( autoGeneratedKeys_ ) == ( java . sql . Statement . RETURN_GENERATED_KEYS ) ) ; writeExecute ( section_ , parameterMetaData_ , parameters_ , numInputColumns , outputExpected , ( chainAutoCommit || chainOpenQueryForAutoGeneratedKeys ) ) ; if ( chainOpenQueryForAutoGeneratedKeys ) { prepareAutoGeneratedKeysStatement ( ) ; writeOpenQuery ( section_ , fetchSize_ , resultSetType_ ) ; } } if ( chainAutoCommit ) { if ( ( agent_ . accumulatedReadExceptions_ ) != null ) { connection_ . writeCommitSubstitute_ ( ) ; commitSubstituted = true ; } else { connection_ . writeCommit ( ) ; } } break ; case isQuery__ : writeOpenQuery ( section_ , fetchSize_ , resultSetType_ , numInputColumns , parameterMetaData_ , parameters_ ) ; break ; case isCall__ : writeExecuteCall ( outputRegistered_ , null , section_ , fetchSize_ , false , resultSetType_ , parameterMetaData_ , parameters_ ) ; break ; } agent_ . flow ( this ) ; super . readCloseResultSets ( true ) ; if ( piggybackedAutocommit ) { connection_ . completeTransactionStart ( ) ; } <START_BUG> super . markResultSetsClosed ( ) ; <END_BUG> switch ( sqlMode_ ) { case isUpdate__ : if ( ( scrollableRS != null ) && ( ! ( scrollableRS . isRowsetCursor_ ) ) ) { scrollableRS . readPositioningFetch_ ( ) ; } if ( ( ( sqlUpdateMode_ ) == ( isInsertSql__ ) ) && ( ( generatedKeysColumnNames_ ) != null ) ) { readOpenQuery ( ) ; if ( ( resultSet_ ) != null ) { generatedKeysResultSet_ = resultSet_ ; resultSet_ = null ; updateCount_ = 1 ; } } else { readExecute ( ) ; if ( ( ( sqlUpdateMode_ ) == ( isInsertSql__ ) ) && ( ( autoGeneratedKeys_ ) == ( java . sql . Statement . RETURN_GENERATED_KEYS ) ) ) { readPrepareAutoGeneratedKeysStatement ( ) ; preparedStatementForAutoGeneratedKeys_ . readOpenQuery ( ) ; generatedKeysResultSet_ = preparedStatementForAutoGeneratedKeys_ . resultSet_ ; preparedStatementForAutoGeneratedKeys_ . resultSet_ = null ; } } if ( chainAutoCommit ) { if ( commitSubstituted ) { connection_ . readCommitSubstitute_ ( ) ; } else { connection_ . readCommit ( ) ; } } break ; case isQuery__ : try { readOpenQuery ( ) ; } catch ( DisconnectException dise ) { throw dise ; } catch ( SqlException e ) { throw e ; } if ( ( resultSet_ ) != null ) { resultSet_ . parseScrollableRowset ( ) ; mapCursorNameToResultSet ( ) ; } break ; case isCall__ : readExecuteCall ( ) ; break ; } try { agent_ . endReadChain ( ) ; } catch ( SqlException e ) { throw e ;
public class ScentedFilter extends VisualizationComponent implements ISpinnerListener { @ FXML protected AnchorPane root_anchorPane ; @ FXML protected Label param_label ; protected NumericSpinner min_spinner ; protected NumericSpinner max_spinner ; @ FXML protected VBox container_vbox ; @ FXML protected StackedBarChart < String , Number > barchart ; protected RangeSlider rangeSlider ; protected Slider slider ; protected XYChart . Series < String , Number > discardedDataSeries ; protected XYChart . Series < String , Number > inactiveDataSeries ; protected XYChart . Series < String , Number > activeDataSeries ; protected ScentedFilterOptionset options ; protected ScentedFilterDataset data ; protected boolean isAdjustedToExtrema ; protected Set < String > selectedBars ; @ Override public void initialize ( URL location , ResourceBundle resources ) { } protected void initSpinners ( ) { min_spinner = new NumericSpinner ( new BigDecimal ( 0 ) , new BigDecimal ( 1 ) ) ; max_spinner = new NumericSpinner ( new BigDecimal ( 0 ) , new BigDecimal ( 1 ) ) ; min_spinner . setId ( "min_spinner" ) ; max_spinner . setId ( "max_spinner" ) ; root_anchorPane . getChildren ( ) . add ( min_spinner ) ; root_anchorPane . getChildren ( ) . add ( max_spinner ) ; min_spinner . setPrefWidth ( 55 ) ; min_spinner . setLayoutX ( 25 ) ; min_spinner . setLayoutY ( 30 ) ; max_spinner . setPrefWidth ( 55 ) ; <START_BUG> max_spinner . setLayoutX ( 100 ) ; <END_BUG> max_spinner . setLayoutY ( 30 ) ; min_spinner . registerListener ( this ) ; max_spinner . registerListener ( this ) ; } protected void initSelection ( ) { } public void applyOptions ( ScentedFilterOptionset options ) { } protected void addEventHandlerToRangeSlider ( RangeSlider rs ) { } protected void addEventHandlerToSlider ( Slider s ) { } protected void updateControlValues ( RangeSlider rs ) { } protected void updateControlValues ( Slider s ) { } public void processSpinnerValue ( BigDecimal value , String id ) { } @ Override public void processSelectionManipulationRequest ( double minX , double minY , double maxX , double maxY ) { } @ Override public void processEndOfSelectionManipulation ( ) { } @ Override public Pair < Integer , Integer > provideOffsets ( ) { } @ Override public void processKeyPressedEvent ( KeyEvent ke ) { } @ Override public void processKeyReleasedEvent ( KeyEvent ke ) { } @ Override public void refresh ( ) { } @ Override protected Map < String , Integer > prepareOptionSet ( ) { } protected void setBarHighlighting ( Node node , boolean on , Color color ) { } @ Override public void resizeContent ( double width , double height ) { } public void refresh ( ScentedFilterDataset data ) { } public void adjustControlExtrema ( ArrayList < LDAConfiguration > ldaConfigurations ) { } public void adjustDerivedControlExtrema ( double [ ] derivedData ) { } protected XYChart . Series < String , Number > addParameterHistogramDataSeries ( double [ ] parameterBinList , final int numberOfBins , final int seriesIndex ) { } protected XYChart . Series < String , Number > generateParameterHistogramDataSeries ( double [ ] parameterBinList , final int numberOfBins ) { } protected void colorParameterHistogramBarchart ( StackedBarChart < String , Number > barchart , int seriesIndex ) { } public void addThresholdsToMap ( Map < String , Pair < Double , Double > > thresholdMap ) { } @ Override public void initHoverEventListeners ( ) { } @ Override public void highlightHoveredOverDataPoints ( Set < Integer > dataPointIDs , DatapointIDMode idMode ) { } protected boolean isBarToHighlight ( int barIndex , String seriesPraefix , Set < Integer > dataPointIDs ) { } @ Override public void removeHoverHighlighting ( ) { } protected void addHoverEventListenersToNode ( XYChart . Data < String , Number > bar ) { } @ Override public String getComponentIdentification ( ) { } }
public class Application { public long calcTimeExecution ( long start , long end ) { long totalTime = end - start ; NumberFormat formatter = new DecimalFormat ( "#0.00" ) ; <START_BUG> System . out . print ( ( ( "\n********<seq2seq4repair_space>Tempo<seq2seq4repair_space>de<seq2seq4repair_space>execução:<seq2seq4repair_space>" + ( formatter . format ( ( totalTime / 1000.0 ) ) ) ) + "<seq2seq4repair_space>segundos<seq2seq4repair_space>\n" ) ) ; <END_BUG> return totalTime ; } public static void main ( String [ ] args ) throws IOException , SQLException { } }
public class RenameFolderAction extends AbstractColumbaAction implements ISelectionListener { public RenameFolderAction ( FrameMediator frameMediator ) { } public void actionPerformed ( ActionEvent evt ) { } public void selectionChanged ( SelectionChangedEvent evt ) { <START_BUG> if ( ( ( ( org . columba . mail . gui . tree . selection . TreeSelectionChangedEvent ) ( evt ) ) . getSelected ( ) . length ) > 0 ) { <END_BUG> AbstractFolder folder = ( ( org . columba . mail . gui . tree . selection . TreeSelectionChangedEvent ) ( evt ) ) . getSelected ( ) [ 0 ] ; if ( ( folder != null ) && ( folder instanceof AbstractMessageFolder ) ) { IFolderItem item = folder . getConfiguration ( ) ; if ( item . getString ( "property" , "accessrights" ) . equals ( "user" ) ) { setEnabled ( true ) ; } else { setEnabled ( false ) ; } } } else { setEnabled ( false ) ; } } }
public class ResourceUrlEncodingFilter extends OncePerRequestFilter { private static final Log logger = LogFactory . getLog ( ResourceUrlEncodingFilter . class ) ; @ Override protected void doFilterInternal ( HttpServletRequest request , HttpServletResponse response , FilterChain filterChain ) throws IOException , ServletException { } private static class ResourceUrlEncodingResponseWrapper extends HttpServletResponseWrapper { private HttpServletRequest request ; private Integer indexLookupPath ; private ResourceUrlEncodingResponseWrapper ( HttpServletRequest request , HttpServletResponse wrapped ) { } @ Override public String encodeURL ( String url ) { } private ResourceUrlProvider getResourceUrlProvider ( ) { } private void initIndexLookupPath ( ResourceUrlProvider urlProvider ) { if ( ( this . indexLookupPath ) == null ) { String requestUri = urlProvider . getPathHelper ( ) . getRequestUri ( this . request ) ; String lookupPath = urlProvider . getPathHelper ( ) . getLookupPathForRequest ( this . request ) ; <START_BUG> this . indexLookupPath = requestUri . indexOf ( lookupPath ) ; <END_BUG> } } } }
public class TextFile extends File { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private String encoding = null ; public TextFile ( File filename , String encoding ) { } public TextFile ( File filename ) { } public TextFile ( String filename ) { } public TextFile ( String filename , String encoding ) { } public void setText ( String body ) { } public String getText ( ) { String lineEnd = System . getProperty ( "line.separator" ) ; <START_BUG> StringBuffer sb = new StringBuffer ( ) ; <END_BUG> Reader reader = null ; BufferedReader br = null ; try { if ( ( encoding ) == null ) { reader = new FileReader ( this ) ; } else { reader = new InputStreamReader ( new FileInputStream ( this ) , encoding ) ; } br = new BufferedReader ( reader ) ; String line = "NOTNULL" ; while ( line != null ) { line = br . readLine ( ) ; if ( line != null ) { sb . append ( ( line + lineEnd ) ) ; } } } catch ( IOException ioe ) { TextFile . log . error ( "" , ioe ) ; } finally { JOrphanUtils . closeQuietly ( br ) ; } return sb . toString ( ) ; } public String getEncoding ( ) { } public void setEncoding ( String string ) { } }
class CraftAsyncDebugger { private CraftAsyncDebugger next = null ; private final int expiry ; private final Plugin plugin ; private final Class < ? extends Runnable > clazz ; CraftAsyncDebugger ( final int expiry , final Plugin plugin , final Class < ? extends Runnable > clazz ) { } final CraftAsyncDebugger getNextHead ( final int time ) { } final CraftAsyncDebugger setNext ( final CraftAsyncDebugger next ) { } StringBuilder debugTo ( final StringBuilder string ) { for ( CraftAsyncDebugger next = this ; next != null ; next = next . next ) { <START_BUG> string . append ( plugin . getDescription ( ) . getName ( ) ) . append ( ':' ) . append ( clazz . getName ( ) ) . append ( '@' ) . append ( expiry ) . append ( ',' ) ; <END_BUG> } return string ; } }
public class DigestAlgorithm implements Algorithm { private static final int BYTE_MASK = 255 ; private static final int BUFFER_SIZE = 8192 ; private String algorithm = "MD5" ; private String provider = null ; private MessageDigest messageDigest = null ; private int readBufferSize = DigestAlgorithm . BUFFER_SIZE ; public void setAlgorithm ( String algorithm ) { } public void setProvider ( String provider ) { } public void initMessageDigest ( ) { } public boolean isValid ( ) { } public String getValue ( File file ) { } public String toString ( ) { <START_BUG> StringBuffer buf = new StringBuffer ( ) ; <END_BUG> buf . append ( "<DigestAlgorithm:" ) ; buf . append ( "algorithm=" ) . append ( algorithm ) ; buf . append ( ";provider=" ) . append ( provider ) ; buf . append ( ">" ) ; return buf . toString ( ) ; } }
public class GuildRoleUpdateHandler extends PacketHandler { public GuildRoleUpdateHandler ( ImplDiscordAPI api ) { } @ Override public void handle ( JSONObject packet ) { String guildId = packet . getString ( "guild_id" ) ; JSONObject roleJson = packet . getJSONObject ( "role" ) ; Server server = api . getServerById ( guildId ) ; final ImplRole role = ( ( ImplRole ) ( server . getRoleById ( roleJson . getString ( "id" ) ) ) ) ; String name = roleJson . getString ( "name" ) ; if ( ! ( role . getName ( ) . equals ( name ) ) ) { final String oldName = role . getName ( ) ; role . setName ( name ) ; listenerExecutorService . submit ( new Runnable ( ) { @ Override public void run ( ) { List < Listener > listeners = api . getListeners ( RoleChangeNameListener . class ) ; synchronized ( listeners ) { for ( Listener listener : listeners ) { ( ( RoleChangeNameListener ) ( listener ) ) . onRoleChangeName ( api , role , oldName ) ; } } } } ) ; } Permissions permissions = new ImplPermissions ( roleJson . getInt ( "permissions" ) ) ; if ( ! ( role . getPermissions ( ) . equals ( permissions ) ) ) { final Permissions oldPermissions = role . getPermissions ( ) ; role . setPermissions ( ( ( ImplPermissions ) ( permissions ) ) ) ; listenerExecutorService . submit ( new Runnable ( ) { @ Override public void run ( ) { List < Listener > listeners = api . getListeners ( RoleChangePermissionsListener . class ) ; synchronized ( listeners ) { for ( Listener listener : listeners ) { ( ( RoleChangePermissionsListener ) ( listener ) ) . onRoleChangePermissions ( api , role , oldPermissions ) ; } } } } ) ; } Color color = new Color ( roleJson . getInt ( "color" ) ) ; if ( ( role . getColor ( ) . getRGB ( ) ) != ( color . getRGB ( ) ) ) { final Color oldColor = role . getColor ( ) ; role . setColor ( color ) ; listenerExecutorService . submit ( new Runnable ( ) { @ Override public void run ( ) { List < Listener > listeners = api . getListeners ( RoleChangeColorListener . class ) ; synchronized ( listeners ) { for ( Listener listener : listeners ) { ( ( RoleChangeColorListener ) ( listener ) ) . onRoleChangeColor ( api , role , oldColor ) ; } } } } ) ; } <START_BUG> if ( ( role . getHoist ( ) ) != ( packet . getBoolean ( "hoist" ) ) ) { <END_BUG> role . setHoist ( ( ! ( role . getHoist ( ) ) ) ) ; listenerExecutorService . submit ( new Runnable ( ) { @ Override public void run ( ) { List < Listener > listeners = api . getListeners ( RoleChangeHoistListener . class ) ; synchronized ( listeners ) { for ( Listener listener : listeners ) { ( ( RoleChangeHoistListener ) ( listener ) ) . onRoleChangeHoist ( api , role , ( ! ( role . getHoist ( ) ) ) ) ; } } } } ) ; } synchronized ( Role . class ) { int position = roleJson . getInt ( "position" ) ; if ( ( role . getPosition ( ) ) != position ) { final int oldPosition = role . getPosition ( ) ; role . setPosition ( position ) ; listenerExecutorService . submit ( new Runnable ( ) { @ Override public void run ( ) { List < Listener > listeners = api . getListeners ( RoleChangePositionListener . class ) ; synchronized ( listeners ) { for ( Listener listener : listeners ) { ( ( RoleChangePositionListener ) ( listener ) ) . onRoleChangePosition ( api , role , oldPosition ) ; } } } } ) ; } } } }
public class Results extends ActionBarActivity { private ArrayList < Card > cards = new ArrayList < > ( ) ; public CardListView cardView ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( activity_results ) ; Toolbar toolbar = ( ( Toolbar ) ( findViewById ( toolbar ) ) ) ; <START_BUG> toolbar . setTitle ( second ) ; <END_BUG> presentIndicativeActive ( ) ; presentIndicativePassive ( ) ; imperfectIndicativeActive ( ) ; imperfectSubjunctiveActive ( ) ; imperfectIndicativePassive ( ) ; perfectIndicativeActive ( ) ; perfectIndicativePassive ( ) ; pluperfectIndicativeActive ( ) ; pluperfectSubjunctiveActive ( ) ; pluperfectIndicativePassive ( ) ; CardArrayAdapter mCardArrayAdapter = new CardArrayAdapter ( this , cards ) ; CardListView listView = ( ( CardListView ) ( findViewById ( list_view ) ) ) ; if ( listView != null ) { listView . setAdapter ( mCardArrayAdapter ) ; } } public void presentIndicativeActive ( ) { } public void presentIndicativePassive ( ) { } public void imperfectIndicativeActive ( ) { } public void imperfectIndicativePassive ( ) { } public void imperfectSubjunctiveActive ( ) { } public void perfectIndicativeActive ( ) { } public void perfectIndicativePassive ( ) { } public void pluperfectIndicativeActive ( ) { } public void pluperfectSubjunctiveActive ( ) { } public void pluperfectIndicativePassive ( ) { } No newline ; at end ; of file ; }
public class ChangePassword extends ScarabTemplateAction { public void doChangepassword ( RunData data , TemplateContext context ) throws Exception { String template = getCurrentTemplate ( data , null ) ; String nextTemplate = getNextTemplate ( data , template ) ; IntakeTool intake = getIntakeTool ( context ) ; if ( intake . isAllValid ( ) ) { Object user = data . getUser ( ) . getTemp ( SESSION_REGISTER ) ; Group register = null ; if ( ( user != null ) && ( user instanceof ScarabUser ) ) { register = intake . get ( "Register" , ( ( ScarabUser ) ( user ) ) . getQueryKey ( ) , false ) ; } else { register = intake . get ( "Register" , DEFAULT_KEY , false ) ; } <START_BUG> String username = register . get ( "Email" ) . toString ( ) ; <END_BUG> String oldPassword = register . get ( "OldPassword" ) . toString ( ) ; String password = register . get ( "Password" ) . toString ( ) ; String passwordConfirm = register . get ( "PasswordConfirm" ) . toString ( ) ; if ( oldPassword . equals ( password ) ) { getScarabRequestTool ( context ) . setInfoMessage ( ( "Your<seq2seq4repair_space>new<seq2seq4repair_space>password<seq2seq4repair_space>was<seq2seq4repair_space>the<seq2seq4repair_space>same<seq2seq4repair_space>as<seq2seq4repair_space>your<seq2seq4repair_space>old<seq2seq4repair_space>one.<seq2seq4repair_space>" + "Your<seq2seq4repair_space>password<seq2seq4repair_space>has<seq2seq4repair_space>not<seq2seq4repair_space>been<seq2seq4repair_space>changed!" ) ) ; setTarget ( data , template ) ; } else if ( password . equals ( passwordConfirm ) ) { try { ScarabUser confirmedUser = ( ( ScarabUser ) ( TurbineSecurity . getUser ( username ) ) ) ; confirmedUser . setPasswordExpire ( ) ; confirmedUser . setHasLoggedIn ( Boolean . FALSE ) ; data . setUser ( confirmedUser ) ; data . save ( ) ; TurbineSecurity . changePassword ( confirmedUser , oldPassword , password ) ; getScarabRequestTool ( context ) . setConfirmMessage ( ( "Your<seq2seq4repair_space>password<seq2seq4repair_space>has<seq2seq4repair_space>been<seq2seq4repair_space>changed." + "<seq2seq4repair_space>Please<seq2seq4repair_space>login<seq2seq4repair_space>with<seq2seq4repair_space>your<seq2seq4repair_space>new<seq2seq4repair_space>password." ) ) ; setTarget ( data , "Login.vm" ) ; } catch ( PasswordMismatchException pme ) { getScarabRequestTool ( context ) . setAlertMessage ( pme . getMessage ( ) ) ; setTarget ( data , template ) ; } } else { getScarabRequestTool ( context ) . setAlertMessage ( "The<seq2seq4repair_space>passwords<seq2seq4repair_space>you<seq2seq4repair_space>entered<seq2seq4repair_space>do<seq2seq4repair_space>not<seq2seq4repair_space>match!" ) ; setTarget ( data , template ) ; } } } }
@ RunWith ( SpringJUnit4ClassRunner . class ) @ ContextConfiguration ( classes = ApplicationConfig . class ) @ ActiveProfiles ( "dev" ) @ Transactional @ WebAppConfiguration public class MessageRepositoryTest { @ Autowired private MessageRepository messageRepository ; @ Test public void testFindByMessageAuthor ( ) { Message message = new Message ( "test_user" , "hello<seq2seq4repair_space>world" ) ; messageRepository . save ( message ) ; List < Message > messages = messageRepository . findByMessageAuthor ( "test_user" ) ; assertNotNull ( messages ) ; assertFalse ( messages . isEmpty ( ) ) ; <START_BUG> assertEquals ( 2 , messages . size ( ) ) ; <END_BUG> } @ Test public void testFindByAll ( ) { } }
void setBackgroundPixel ( int pixel ) { } void setCheckboxImageListColor ( ) { } void setCheckboxImageList ( int width , int height ) { } void setFocusIndex ( int index ) { } public void setFont ( Font font ) { } void setForegroundPixel ( int pixel ) { } public void setHeaderVisible ( boolean show ) { } public void setItemCount ( int count ) { } void setItemHeight ( ) { } public void setLinesVisible ( boolean show ) { } public void setRedraw ( boolean redraw ) { } boolean setScrollWidth ( TableItem item , boolean force ) { } public void setSelection ( int [ ] indices ) { } public void setSelection ( TableItem [ ] items ) { } public void setSelection ( int index ) { } public void setSelection ( int start , int end ) { } void setTableEmpty ( ) { } public void setTopIndex ( int index ) { } public void showColumn ( TableColumn column ) { } void showItem ( int index ) { } public void showItem ( TableItem item ) { } public void showSelection ( ) { } String toolTipText ( NMTTDISPINFO hdr ) { } int widgetStyle ( ) { } TCHAR windowClass ( ) { } int windowProc ( ) { } LRESULT WM_CHAR ( int wParam , int lParam ) { } LRESULT WM_ERASEBKGND ( int wParam , int lParam ) { } LRESULT WM_GETOBJECT ( int wParam , int lParam ) { } LRESULT WM_KEYDOWN ( int wParam , int lParam ) { } LRESULT WM_LBUTTONDBLCLK ( int wParam , int lParam ) { } LRESULT WM_LBUTTONDOWN ( int wParam , int lParam ) { } LRESULT WM_LBUTTONUP ( int wParam , int lParam ) { } LRESULT WM_MOUSEHOVER ( int wParam , int lParam ) { } LRESULT WM_PAINT ( int wParam , int lParam ) { } LRESULT WM_NOTIFY ( int wParam , int lParam ) { NMHDR hdr = new NMHDR ( ) ; OS . MoveMemory ( hdr , lParam , sizeof ) ; int hwndHeader = OS . SendMessage ( handle , LVM_GETHEADER , 0 , 0 ) ; if ( ( hdr . hwndFrom ) == hwndHeader ) { switch ( hdr . code ) { case OS . HDN_BEGINTRACKW : case OS . HDN_BEGINTRACKA : case OS . HDN_DIVIDERDBLCLICKW : case OS . HDN_DIVIDERDBLCLICKA : { NMHEADER phdn = new NMHEADER ( ) ; OS . MoveMemory ( phdn , lParam , NMHEADER . sizeof ) ; TableColumn column = columns [ phdn . iItem ] ; if ( ( column != null ) && ( ! ( column . getResizable ( ) ) ) ) { return LRESULT . ONE ; } break ; } case OS . HDN_ITEMCHANGEDW : case OS . HDN_ITEMCHANGEDA : { int width = OS . SendMessage ( handle , LVM_GETCOLUMNWIDTH , 0 , 0 ) ; if ( ( ( lastWidth ) == 0 ) && ( width > 0 ) ) { int bits = OS . SendMessage ( handle , LVM_GETEXTENDEDLISTVIEWSTYLE , 0 , 0 ) ; if ( ( bits & ( OS . LVS_EX_GRIDLINES ) ) != 0 ) { RECT rect = new RECT ( ) ; OS . GetClientRect ( handle , rect ) ; rect . right = ( rect . left ) + width ; OS . InvalidateRect ( handle , rect , true ) ; } } lastWidth = width ; if ( ! ( ignoreResize ) ) { NMHEADER phdn = new NMHEADER ( ) ; OS . MoveMemory ( phdn , lParam , NMHEADER . sizeof ) ; if ( ( phdn . pitem ) != 0 ) { HDITEM pitem = new HDITEM ( ) ; OS . MoveMemory ( pitem , phdn . pitem , HDITEM . sizeof ) ; if ( ( ( pitem . mask ) & ( OS . HDI_WIDTH ) ) != 0 ) { TableColumn column = columns [ phdn . iItem ] ; if ( column != null ) { column . sendEvent ( Resize ) ; if ( isDisposed ( ) ) return LRESULT . ZERO ; int count = OS . SendMessage ( hwndHeader , HDM_GETITEMCOUNT , 0 , 0 ) ; if ( ( count == 1 ) && ( ( columns [ 0 ] ) == null ) ) count = 0 ; TableColumn [ ] newColumns = new TableColumn [ count ] ; System . arraycopy ( columns , 0 , newColumns , 0 , count ) ; for ( int i = ( phdn . iItem ) + 1 ; i < count ; i ++ ) { <START_BUG> if ( ( ( newColumns [ i ] ) != null ) && ( ! ( newColumns [ i ] . isDisposed ( ) ) ) ) { <END_BUG> newColumns [ i ] . sendEvent ( Move ) ; } } } } } } break ; } case OS . HDN_ITEMDBLCLICKW : case OS . HDN_ITEMDBLCLICKA : { NMHEADER phdn = new NMHEADER ( ) ; OS . MoveMemory ( phdn , lParam , NMHEADER . sizeof ) ; TableColumn column = columns [ phdn . iItem ] ; if ( column != null ) { column . postEvent ( DefaultSelection ) ; } break ; } } } return super . WM_NOTIFY ( wParam , lParam ) ; } LRESULT WM_RBUTTONDBLCLK ( int wParam , int lParam ) { } LRESULT WM_RBUTTONDOWN ( int wParam , int lParam ) { } LRESULT WM_SETFOCUS ( int wParam , int lParam ) { } LRESULT WM_SIZE ( int wParam , int lParam ) { } LRESULT WM_SYSCOLORCHANGE ( int wParam , int lParam ) { } LRESULT WM_VSCROLL ( int wParam , int lParam ) { } LRESULT WM_WINDOWPOSCHANGED ( int wParam , int lParam ) { } LRESULT wmNotifyChild ( int wParam , int lParam ) { } }
public class IrcBot { public static final IrcBot instance = new IrcBot ( ) ; public static CLogger LOGGER ; private final MemBuffer buffer = new MemBuffer ( ) ; private boolean isRunning = false ; private boolean canRun = true ; private String shutdownReason = null ; private IrcListener handler ; private IrcConnection connection ; private NickServ nickServ ; private Admins admins ; private Auth auth ; private StringCheck stringCheck ; private BlackList blacklist ; private AutoJoinList autoJoinList ; private IrcBot ( ) { } private void start ( ) { } private void init ( ) { } private void onTick ( ) { } private void end ( int code ) { } public void stop ( ) { } public void stop ( String reason ) { } public IrcListener getHandler ( ) { } public IrcConnection getConnection ( ) { } public String getVersionString ( ) { <START_BUG> return "AcomputerBot<seq2seq4repair_space>v0.13" ; <END_BUG> } public boolean canRun ( ) { } public NickServ getNickServ ( ) { } public Admins getAdmins ( ) { } public Auth getAuth ( ) { } public StringCheck getStringCheck ( ) { } public BlackList getBlacklist ( ) { } public static void main ( String [ ] args ) { } }
public class SharedObjectFactory implements ISharedObjectFactory { private static Trace debug = Trace . create ( "containerfactory" ) ; private static Hashtable sharedobjectdescriptions = new Hashtable ( ) ; protected static ISharedObjectFactory instance = null ; protected SharedObjectFactory ( ) { } public static ISharedObjectFactory getDefault ( ) { } private static void trace ( String msg ) { } private static void dumpStack ( String msg , Throwable e ) { } public SharedObjectDescription addDescription ( SharedObjectDescription description ) { } public List getDescriptions ( ) { } protected List getDescriptions0 ( ) { } protected SharedObjectDescription addDescription0 ( SharedObjectDescription n ) { } public boolean containsDescription ( SharedObjectDescription scd ) { } protected boolean containsDescription0 ( SharedObjectDescription scd ) { } protected SharedObjectDescription getDescription0 ( SharedObjectDescription scd ) { } protected SharedObjectDescription getDescription0 ( String name ) { } public SharedObjectDescription getDescriptionByName ( String name ) throws SharedObjectInstantiationException { } public ISharedObject createSharedObject ( SharedObjectDescription desc , String [ ] argTypes , Object [ ] args ) throws SharedObjectInstantiationException { SharedObjectFactory . trace ( ( ( ( ( ( ( "createSharedObject(" + desc ) + "," ) + ( Trace . convertStringAToString ( argTypes ) ) ) + "," ) + ( Trace . convertObjectAToString ( args ) ) ) + ")" ) ) ; if ( desc == null ) throw new SharedObjectInstantiationException ( "SharedObjectDescription<seq2seq4repair_space>cannot<seq2seq4repair_space>be<seq2seq4repair_space>null" ) ; SharedObjectDescription cd = getDescription0 ( desc ) ; if ( cd == null ) throw new SharedObjectInstantiationException ( ( ( "SharedObjectDescription<seq2seq4repair_space>named<seq2seq4repair_space>'" + ( desc . getName ( ) ) ) + "'<seq2seq4repair_space>not<seq2seq4repair_space>found" ) ) ; Class [ ] clazzes = null ; ISharedObjectInstantiator instantiator = null ; try { instantiator = ( ( ISharedObjectInstantiator ) ( cd . getInstantiator ( ) ) ) ; <START_BUG> clazzes = AbstractFactory . getClassesForTypes ( argTypes , args , cd . getClassLoader ( ) ) ; <END_BUG> } catch ( Exception e ) { SharedObjectInstantiationException newexcept = new SharedObjectInstantiationException ( ( ( ( ( ( "createSharedObject<seq2seq4repair_space>exception<seq2seq4repair_space>with<seq2seq4repair_space>description:<seq2seq4repair_space>" + desc ) + ":<seq2seq4repair_space>" ) + ( e . getClass ( ) . getName ( ) ) ) + ":<seq2seq4repair_space>" ) + ( e . getMessage ( ) ) ) ) ; newexcept . setStackTrace ( e . getStackTrace ( ) ) ; SharedObjectFactory . dumpStack ( "Exception<seq2seq4repair_space>in<seq2seq4repair_space>createSharedObject" , newexcept ) ; throw newexcept ; } if ( instantiator == null ) throw new SharedObjectInstantiationException ( ( ( "Instantiator<seq2seq4repair_space>for<seq2seq4repair_space>SharedObjectDescription<seq2seq4repair_space>" + ( cd . getName ( ) ) ) + "<seq2seq4repair_space>is<seq2seq4repair_space>null" ) ) ; return ( ( ISharedObject ) ( instantiator . createInstance ( desc , clazzes , args ) ) ) ; } public ISharedObject createSharedObject ( String descriptionName ) throws SharedObjectInstantiationException { } public ISharedObject createSharedObject ( String descriptionName , Object [ ] args ) throws SharedObjectInstantiationException { } public ISharedObject createSharedObject ( String descriptionName , String [ ] argsTypes , Object [ ] args ) throws SharedObjectInstantiationException { } public SharedObjectDescription removeDescription ( SharedObjectDescription scd ) { } protected SharedObjectDescription removeDescription0 ( SharedObjectDescription n ) { } }
public class TransactionAction { private RealShop2Plugin plugin ; public TransactionAction ( RealShop2Plugin plugin ) { } public int buy ( Player player , Shop shop , ItemStack itemStack ) { } public Price calculatePrice ( Shop shop , ItemStack itemStack ) { } public Price calculatePrice ( Shop shop , RealItemStack itemStack ) { RealItemType itemType = itemStack . getItemType ( ) ; <START_BUG> ItemPriceList prices = new ItemPriceList ( plugin , shop . getPlayerName ( ) ) ; <END_BUG> Price price = prices . getPrice ( itemType , itemStack . getDamage ( ) , plugin . getMarketPrices ( ) ) ; return price ; } public boolean canPay ( Player player , Shop shop , ItemStack buyStack , ItemStack sellStack ) { } public int sell ( Player player , Shop shop , ItemStack itemStack ) { } private void sendMessage ( Player player , Shop shop , ItemStack itemStack , double price , double amount , String side , String shopSide ) { } }
public class MessageBuilder { private static Logger LOGGER = LoggerFactory . getLogger ( MessageBuilder . class ) ; private AppEntity appEntity ; private DeviceEntity deviceEntity ; private long utcTime ; private String domain ; private MessageIdGenerator idGenerator ; private String senderId ; private String userId ; private String replyTo ; private Map < String , String > metadata ; private boolean receipt ; private static final String EMPTY = "" ; public MessageBuilder setAppEntity ( AppEntity appEntity ) { } public MessageBuilder setDeviceEntity ( DeviceEntity deviceEntity ) { } public MessageBuilder setUtcTime ( long utcTime ) { } public MessageBuilder setDomain ( String domain ) { } public MessageBuilder setIdGenerator ( MessageIdGenerator idGenerator ) { } public MessageBuilder setSenderId ( String senderId ) { } public MessageBuilder setUserId ( String userId ) { } public MessageBuilder setReplyTo ( String replyTo ) { } public MessageBuilder setMetadata ( Map < String , String > metadata ) { } public MessageBuilder setReceipt ( boolean receipt ) { } public Message build ( ) { Message message = new Message ( ) ; String id = idGenerator . generate ( userId , appEntity . getAppId ( ) , ( ( deviceEntity ) != null ? deviceEntity . getDeviceId ( ) : null ) ) ; message . setID ( id ) ; Element mmxElement = message . addChildElement ( MMX , MMX_NS_MSG_PAYLOAD ) ; MmxHeaders mmxMeta = new MmxHeaders ( ) ; if ( ( senderId ) != null ) { mmxMeta . put ( FROM , new MMXid ( senderId , null ) ) ; } if ( ( userId ) != null ) { <START_BUG> mmxMeta . put ( TO , new MMXid ( userId , null ) ) ; <END_BUG> } String mmxMetaJSON = GsonData . getGson ( ) . toJson ( mmxMeta ) ; Element mmxMetaElement = mmxElement . addElement ( MMX_MMXMETA ) ; mmxMetaElement . setText ( mmxMetaJSON ) ; if ( ( replyTo ) != null ) { if ( ( metadata ) == null ) { metadata = new HashMap < String , String > ( ) ; } metadata . put ( REPLY_TO , formatReplyTo ( replyTo ) ) ; } if ( ( metadata ) == null ) { metadata = new HashMap < String , String > ( ) ; } Map < String , String > meta = metadata ; String metaJSON = GsonData . getGson ( ) . toJson ( meta ) ; Element metaElement = mmxElement . addElement ( MMX_META ) ; metaElement . setText ( metaJSON ) ; Element payloadElement = mmxElement . addElement ( MMX_PAYLOAD ) ; DateFormat fmt = Utils . buildISO8601DateFormat ( ) ; String formattedDateTime = fmt . format ( new Date ( utcTime ) ) ; payloadElement . addAttribute ( MMX_ATTR_STAMP , formattedDateTime ) ; String text = MessageBuilder . EMPTY ; payloadElement . setText ( text ) ; payloadElement . addAttribute ( MMX_ATTR_CHUNK , MessageBuilder . buildChunkAttributeValue ( text ) ) ; message . setType ( chat ) ; message . setFrom ( buildFromJID ( ) ) ; message . setTo ( buildToJID ( ) ) ; if ( receipt ) { message . addChildElement ( XMPP_REQUEST , XMPP_NS_RECEIPTS ) ; } message . setBody ( MESSAGE_BODY_DOT ) ; return message ; } private JID buildToJID ( ) { } public static String buildChunkAttributeValue ( String content ) { } private JID buildFromJID ( ) { } private String formatReplyTo ( String replyTo ) { } }
for ( int j = 0 ; j < ( types . length ) ; j ++ ) dTValidators . addElement ( types [ j ] ) ; } else { dTValidators . addElement ( baseValidator ) ; } } } } if ( baseTypeName == null ) { content = DOMUtil . getNextSiblingElement ( content ) ; } else { content = DOMUtil . getFirstChildElement ( content ) ; if ( content != null ) { if ( DOMUtil . getLocalName ( content ) . equals ( ELT_ANNOTATION ) ) { traverseAnnotationDecl ( content , attrValues , false , schemaDoc ) ; content = DOMUtil . getNextSiblingElement ( content ) ; } } } if ( union ) { if ( memberTypes != null ) { if ( content != null ) { if ( DOMUtil . getLocalName ( content ) . equals ( ELT_ANNOTATION ) ) { traverseAnnotationDecl ( content , attrValues , false , schemaDoc ) ; content = DOMUtil . getNextSiblingElement ( content ) ; } } if ( content != null ) { if ( DOMUtil . getLocalName ( content ) . equals ( ELT_ANNOTATION ) ) { Object [ ] args = new Object [ ] { nameProperty } ; reportSchemaError ( "dt-union-memberType" , args ) ; } } } while ( content != null ) { baseValidator = traverseLocal ( content , schemaDoc , grammar ) ; if ( baseValidator != null ) { if ( ( ( fListName . length ( ) ) != 0 ) && ( ( baseValidator . getVariety ( ) ) == ( XSSimpleType . VARIETY_LIST ) ) ) { reportCosListOfAtomic ( qualifiedName ) ; return null ; } if ( ( baseValidator . getVariety ( ) ) == ( XSSimpleType . VARIETY_UNION ) ) { XSSimpleType [ ] types = ( ( org . apache . xerces . impl . dv . XSUnionSimpleType ) ( baseValidator ) ) . getMemberTypes ( ) ; for ( int i = 0 ; i < ( types . length ) ; i ++ ) dTValidators . addElement ( types [ i ] ) ; } else { dTValidators . addElement ( baseValidator ) ; } } if ( baseValidator == null ) { Object [ ] args = new Object [ ] { content . getAttribute ( ATT_BASE ) , nameProperty } ; reportSchemaError ( "dt-unknown-basetype" , args ) ; baseValidator = SchemaGrammar . fAnySimpleType ; } content = DOMUtil . getNextSiblingElement ( content ) ; } } if ( ( fListName . length ( ) ) != 0 ) { if ( fListName . equals ( qualifiedName ) ) { fListName = SchemaSymbols . EMPTY_STRING ; } } XSFacets facetData = null ; short presentFacets = 0 ; short fixedFacets = 0 ; if ( restriction && ( content != null ) ) { FacetInfo fi = traverseFacets ( content , contentAttrs , nameProperty , baseValidator , schemaDoc , grammar ) ; content = fi . nodeAfterFacets ; if ( content != null ) { content = null ; reportSchemaError ( "s4s-elt-must-match" , new Object [ ] { SchemaSymbols . ELT_RESTRICTION , "(annotation?,<seq2seq4repair_space>(simpleType?,<seq2seq4repair_space>(minExclusive<seq2seq4repair_space>|<seq2seq4repair_space>minInclusive<seq2seq4repair_space>|<seq2seq4repair_space>maxExclusive<seq2seq4repair_space>|<seq2seq4repair_space>maxInclusive<seq2seq4repair_space>|<seq2seq4repair_space>totalDigits<seq2seq4repair_space>|<seq2seq4repair_space>fractionDigits<seq2seq4repair_space>|<seq2seq4repair_space>length<seq2seq4repair_space>|<seq2seq4repair_space>minLength<seq2seq4repair_space>|<seq2seq4repair_space>maxLength<seq2seq4repair_space>|<seq2seq4repair_space>enumeration<seq2seq4repair_space>|<seq2seq4repair_space>whiteSpace<seq2seq4repair_space>|<seq2seq4repair_space>pattern)*))" } ) ; } facetData = fi . facetdata ; presentFacets = fi . fPresentFacets ; fixedFacets = fi . fFixedFacets ; } else if ( list && ( content != null ) ) { if ( baseTypeName != null ) { if ( DOMUtil . getLocalName ( content ) . equals ( ELT_ANNOTATION ) ) { traverseAnnotationDecl ( content , attrValues , false , schemaDoc ) ; content = DOMUtil . getNextSiblingElement ( content ) ; } if ( content != null ) { Object [ ] args = new Object [ ] { nameProperty } ; reportSchemaError ( "dt-list-itemType" , args ) ; } } else { reportSchemaError ( "s4s-elt-must-match" , new Object [ ] { SchemaSymbols . ELT_LIST , "(annotation?,<seq2seq4repair_space>(simpleType?))" } ) ; } } else if ( union && ( content != null ) ) { reportSchemaError ( "s4s-elt-must-match" , new Object [ ] { SchemaSymbols . ELT_UNION , "(annotation?,<seq2seq4repair_space>(simpleType?))" } ) ; } XSSimpleType newDecl = null ; if ( list ) { newDecl = schemaFactory . createTypeList ( nameProperty , schemaDoc . fTargetNamespace , ( ( short ) ( finalProperty ) ) , baseValidator ) ; } else if ( restriction ) { newDecl = schemaFactory . createTypeRestriction ( nameProperty , schemaDoc . fTargetNamespace , ( ( short ) ( finalProperty ) ) , baseValidator ) ; try { fValidationState . setNamespaceSupport ( schemaDoc . fNamespaceSupport ) ; newDecl . applyFacets ( facetData , presentFacets , fixedFacets , fValidationState ) ; } catch ( InvalidDatatypeFacetException ex ) { <START_BUG> reportGenericSchemaError ( ( ( ( "facet<seq2seq4repair_space>error<seq2seq4repair_space>when<seq2seq4repair_space>creating<seq2seq4repair_space>type<seq2seq4repair_space>'" + qualifiedName ) + "':<seq2seq4repair_space>" ) + ( ex . getLocalizedMessage ( ) ) ) ) ; <END_BUG> } } else { XSSimpleType [ ] memberDecls = new XSSimpleType [ dTValidators . size ( ) ] ; for ( int i = 0 ; i < ( dTValidators . size ( ) ) ; i ++ ) memberDecls [ i ] = ( ( XSSimpleType ) ( dTValidators . elementAt ( i ) ) ) ; newDecl = schemaFactory . createTypeUnion ( nameProperty , schemaDoc . fTargetNamespace , ( ( short ) ( finalProperty ) ) , memberDecls ) ; } if ( ( nameProperty == null ) && isGlobal ) { return null ; } if ( ( newDecl != null ) && isGlobal ) { grammar . addGlobalTypeDecl ( newDecl ) ; } return newDecl ; } private void reportCosListOfAtomic ( String qualifiedName ) { } private XSSimpleType findDTValidator ( Element elm , QName baseTypeStr , short baseRefContext , XSDocumentInfo schemaDoc ) { } private boolean isListDatatype ( XSSimpleType validator ) { } }
private Panel storeInventoryButtons ; private Panel textPanel ; private Button cancelButton ; private Button clearButton ; private Button inventoryButton ; private Button buyButton ; private Label [ ] itemDescription ; private Label partyMoney ; private ComponentModal < SegmentedControl > buyModal ; private MessageModal failedBuyModal ; private List < Item > currentPurchase ; private List < Inventoried > currentParty ; private ItemType currentItem = null ; private ItemType hoverItem = null ; private Inventory inv ; private Party party ; private double priceModifier ; public StoreScene ( Party p , Inventory storeInventory , double priceModifier ) { } @ Override public void init ( GameContainer container , StateBasedGame game ) throws SlickException { } @ Override public void update ( GameContainer container , StateBasedGame game , int delta ) throws SlickException { } @ Override public void keyReleased ( int key , char c ) { } @ Override public int getID ( ) { } @ Override public void mouseMoved ( int oldx , int oldy , int newx , int newy ) { } @ Override public void dismissModal ( Modal modal , int button ) { } @ Override public void enter ( GameContainer container , StateBasedGame game ) { } private void createComponents ( ) { } private void updateLabels ( ItemType currentItem ) { } private void updatePartyMoneyLabel ( ) { } private int makePurchase ( ) { int itemCount = ( storeInventory [ getButtonIndex ( currentItem ) ] . getMax ( ) ) - ( storeInventory [ getButtonIndex ( currentItem ) ] . getCount ( ) ) ; List < Inventoried > currentBuyers = party . canGetItem ( currentItem , itemCount ) ; System . out . println ( currentBuyers ) ; if ( ( currentItem ) == ( ItemType . MAP ) ) { String errorText ; if ( ( party . getMoney ( ) ) > ( ( int ) ( ( currentItem . getCost ( ) ) * ( priceModifier ) ) ) ) { Random random = new Random ( ) ; GameDirector . sharedSceneListener ( ) . updateMap ( StateIdx . values ( ) [ random . nextInt ( StateIdx . values ( ) . length ) ] ) ; party . setMoney ( ( ( party . getMoney ( ) ) - ( ( int ) ( ( currentItem . getCost ( ) ) * ( priceModifier ) ) ) ) ) ; return 1 ; } else { errorText = ConstantStore . get ( "STORE_SCENE" , "ERR_NOT_ENOUGH_MONEY" ) ; failedBuyModal = new MessageModal ( container , this , errorText ) ; return - 1 ; } } if ( ( ( currentItem ) == ( ItemType . WAGON ) ) && ( ( party . getVehicle ( ) ) == null ) ) { if ( ( itemCount > 1 ) && ( ( party . getMoney ( ) ) >= ( ( int ) ( ( WAGON . getCost ( ) ) * ( priceModifier ) ) ) ) ) { failedBuyModal = new MessageModal ( container , this , ConstantStore . get ( "STORE_SCENE" , "ERR_TOO_MANY_WAGON" ) ) ; return - 1 ; } else if ( ( party . getMoney ( ) ) > ( ( int ) ( ( currentItem . getCost ( ) ) * ( priceModifier ) ) ) ) { party . setVehicle ( new Wagon ( ) ) ; inv . removeItemFromInventory ( currentItem , 1 ) ; party . setMoney ( ( ( party . getMoney ( ) ) - ( ( int ) ( ( WAGON . getCost ( ) ) * ( priceModifier ) ) ) ) ) ; storeInventory [ getButtonIndex ( currentItem ) ] . setMax ( inv . getNumberOf ( currentItem ) ) ; updateLabels ( currentItem ) ; return 1 ; } else { failedBuyModal = new MessageModal ( container , this , ConstantStore . get ( "STORE_SCENE" , "ERR_NOT_ENOUGH_MONEY_FOR_WAGON" ) ) ; return - 1 ; } } else if ( ( currentBuyers . size ( ) ) == 0 ) { String errorText ; <START_BUG> if ( ( currentItem . isAnimal ( ) ) && ( ( ( party . getAnimals ( ) . size ( ) ) + itemCount ) > 5 ) ) { <END_BUG> errorText = ConstantStore . get ( "STORE_SCENE" , "ERR_TOO_MANY_ANIMALS" ) ; } else if ( ( party . getMoney ( ) ) < ( itemCount * ( ( int ) ( ( currentItem . getCost ( ) ) * ( priceModifier ) ) ) ) ) { errorText = ConstantStore . get ( "STORE_SCENE" , "ERR_NOT_ENOUGH_MONEY" ) ; } else { errorText = ConstantStore . get ( "STORE_SCENE" , "ERR_CANT_CARRY" ) ; } failedBuyModal = new MessageModal ( container , this , errorText ) ; return - 1 ; } else { currentPurchase = inv . removeItemFromInventory ( currentItem , itemCount ) ; currentParty = new ArrayList < Inventoried > ( ) ; currentParty . addAll ( party . getPartyMembers ( ) ) ; if ( ( party . getVehicle ( ) ) != null ) currentParty . add ( party . getVehicle ( ) ) ; List < Inventoried > disabledList = new ArrayList < Inventoried > ( ) ; List < Inventoried > enabledList = new ArrayList < Inventoried > ( ) ; for ( int i = 0 ; i < ( currentParty . size ( ) ) ; i ++ ) { Inventoried currentPerson = currentParty . get ( i ) ; boolean found = false ; for ( int j = 0 ; ( j < ( currentBuyers . size ( ) ) ) && ( ! found ) ; j ++ ) { if ( currentPerson == ( currentBuyers . get ( j ) ) ) { found = true ; } } if ( ! found ) { disabledList . add ( currentPerson ) ; } else { enabledList . add ( currentPerson ) ; } }
public class MainController implements MouseListener , SelectionListener { private ExecutionHandler executionHandler ; private MainFrame mainframe ; private MiscController miscController ; private SettingsController settingsController ; private EditorController editorController ; private TreeViewController treeController ; public MainController ( ) { } private void initMainFrame ( ) { } @ Override public void widgetSelected ( SelectionEvent e ) { } @ Override public void mouseDoubleClick ( MouseEvent e ) { if ( ( e . getSource ( ) ) == ( this . editorController . getEditorView ( ) . getLineNumbers ( ) ) ) { int offset = this . editorController . getEditorView ( ) . getLineNumbers ( ) . getCaretOffset ( ) ; int lineCount = this . editorController . getEditorView ( ) . getTextField ( ) . getLineCount ( ) ; <START_BUG> if ( ( ( offset > ( lineCount - 1 ) ) || ( ( this . editorController . getEditorView ( ) . getTextField ( ) . getLine ( offset ) ) == null ) ) || ( ( this . editorController . getEditorView ( ) . getTextField ( ) . getLine ( offset ) . length ( ) ) == 0 ) ) { <END_BUG> return ; } this . treeController . addStatementBreakpoint ( ( offset + 1 ) ) ; } } @ Override public void widgetDefaultSelected ( SelectionEvent e ) { } @ Override public void mouseDown ( MouseEvent arg0 ) { } @ Override public void mouseUp ( MouseEvent arg0 ) { } }
public class JMeterMenuBar extends JMenuBar implements LocaleChangeListener { private static final long serialVersionUID = 240L ; private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private JMenu fileMenu ; private JMenuItem file_save_as ; private JMenuItem file_selection_as ; private JMenuItem file_revert ; private JMenuItem file_load ; private List < JComponent > file_load_recent_files ; private JMenuItem file_merge ; private JMenuItem file_exit ; private JMenuItem file_close ; private JMenu editMenu ; private JMenu edit_add ; private JMenuItem edit_remove ; private JMenu runMenu ; private JMenuItem run_start ; private JMenu remote_start ; private JMenuItem remote_start_all ; private Collection < JMenuItem > remote_engine_start ; private JMenuItem run_stop ; private JMenuItem run_shut ; private JMenu remote_stop ; private JMenu remote_shut ; private JMenuItem remote_stop_all ; private JMenuItem remote_shut_all ; private Collection < JMenuItem > remote_engine_stop ; private Collection < JMenuItem > remote_engine_shut ; private JMenuItem run_clear ; private JMenuItem run_clearAll ; private JMenu optionsMenu ; private JMenu lafMenu ; private JMenuItem sslManager ; private JMenu helpMenu ; private JMenuItem help_about ; private String [ ] remoteHosts ; private JMenu remote_exit ; private JMenuItem remote_exit_all ; private Collection < JMenuItem > remote_engine_exit ; public JMeterMenuBar ( ) { } public void setFileSaveEnabled ( boolean enabled ) { } public void setFileLoadEnabled ( boolean enabled ) { } public void setFileRevertEnabled ( boolean enabled ) { } public void setProjectFileLoaded ( String file ) { } public void setEditEnabled ( boolean enabled ) { } public void setEditAddMenu ( JMenu menu ) { } public void setEditMenu ( JPopupMenu menu ) { } public void setEditAddEnabled ( boolean enabled ) { } public void setEditRemoveEnabled ( boolean enabled ) { } public void createMenuBar ( ) { } private void makeHelpMenu ( ) { } private void makeOptionsMenu ( ) { } private static class LangMenuHelper { final ActionRouter actionRouter = ActionRouter . getInstance ( ) ; final JMenu languageMenu ; LangMenuHelper ( JMenu _languageMenu ) { } void addLang ( String locale ) { } } public static String [ ] getLanguages ( ) { } static JMenu makeLanguageMenu ( ) { } private void makeRunMenu ( ) { } private void makeEditMenu ( ) { } private void makeFileMenu ( ) { } public void setRunning ( boolean running , String host ) { JMeterMenuBar . log . info ( ( ( ( ( "setRunning(" + running ) + "," ) + host ) + ")" ) ) ; Iterator < JMenuItem > iter = remote_engine_start . iterator ( ) ; Iterator < JMenuItem > iter2 = remote_engine_stop . iterator ( ) ; Iterator < JMenuItem > iter3 = remote_engine_exit . iterator ( ) ; Iterator < JMenuItem > iter4 = remote_engine_shut . iterator ( ) ; while ( ( ( ( iter . hasNext ( ) ) && ( iter2 . hasNext ( ) ) ) && ( iter3 . hasNext ( ) ) ) && ( iter4 . hasNext ( ) ) ) { JMenuItem start = iter . next ( ) ; JMenuItem stop = iter2 . next ( ) ; JMenuItem exit = iter3 . next ( ) ; JMenuItem shut = iter4 . next ( ) ; if ( start . getText ( ) . equals ( host ) ) { JMeterMenuBar . log . debug ( ( "Found<seq2seq4repair_space>start<seq2seq4repair_space>host:<seq2seq4repair_space>" + ( start . getText ( ) ) ) ) ; start . setEnabled ( ( ! running ) ) ; } if ( stop . getText ( ) . equals ( host ) ) { JMeterMenuBar . log . debug ( ( "Found<seq2seq4repair_space>stop<seq2seq4repair_space>host:<seq2seq4repair_space>" + ( stop . getText ( ) ) ) ) ; stop . setEnabled ( running ) ; } if ( exit . getText ( ) . equals ( host ) ) { JMeterMenuBar . log . debug ( ( "Found<seq2seq4repair_space>exit<seq2seq4repair_space>host:<seq2seq4repair_space>" + ( exit . getText ( ) ) ) ) ; exit . setEnabled ( true ) ; } if ( shut . getText ( ) . equals ( host ) ) { JMeterMenuBar . log . debug ( ( "Found<seq2seq4repair_space>exit<seq2seq4repair_space>host:<seq2seq4repair_space>" + ( exit . getText ( ) ) ) ) ; <START_BUG> exit . setEnabled ( true ) ; <END_BUG> } } } @ Override public void setEnabled ( boolean enable ) { } private void getRemoteItems ( ) { } public void localeChanged ( LocaleChangeEvent event ) { } private void updateMenuElement ( MenuElement menu ) { } private static boolean isResource ( String actionCommand ) { } private static JMenu makeMenuRes ( String resource ) { } private static JMenu makeMenuRes ( String resource , int mnemonic ) { } private static JMenuItem makeMenuItemNoRes ( String label , String actionCommand ) { } private static JMenuItem makeMenuItemRes ( String resource , String actionCommand ) { } private static JMenuItem makeMenuItemRes ( String resource , String actionCommand , KeyStroke keyStroke ) { } private static JMenuItem makeMenuItemRes ( String resource , int mnemonic , String actionCommand ) { } private static JMenuItem makeMenuItemRes ( String resource , int mnemonic , String actionCommand , KeyStroke keyStroke ) { } }
public class WarWebXmlInterceptor extends BaseInterceptor implements ContextInterceptor { private static StringManager sm = StringManager . getManager ( "org.apache.tomcat.core" ) ; public WarWebXmlInterceptor ( ) { } public void contextInit ( Context ctx ) { if ( ! ( ctx . getDocumentBase ( ) . getProtocol ( ) . equalsIgnoreCase ( "war" ) ) ) { return ; } WebApplicationReader webXmlReader = new WebApplicationReader ( ) ; try { webXmlReader . processDefaultWebApp ( ctx ) ; String s = ctx . getDocumentBase ( ) . toString ( ) ; if ( s . endsWith ( "/" ) ) s = s . substring ( 0 , ( ( s . length ( ) ) - 1 ) ) ; URL webURL = null ; <START_BUG> webURL = new URL ( ( ( s + "!/" ) + ( Constants . Context . ConfigFile ) ) ) ; <END_BUG> InputStream is = webURL . openConnection ( ) . getInputStream ( ) ; System . out . println ( ( ( ( "Context(" + ( ctx . getPath ( ) ) ) + "):<seq2seq4repair_space>" ) + ( webURL . getFile ( ) ) ) ) ; webXmlReader . processWebApp ( ctx , is ) ; } catch ( Exception e ) { String msg = WarWebXmlInterceptor . sm . getString ( "context.getConfig.e" , ( ( ( ctx . getPath ( ) ) + "<seq2seq4repair_space>" ) + ( ctx . getDocBase ( ) ) ) ) ; } } }
public class JMeterTest extends JMeterTestCase { private static Logger log = LoggingManager . getLoggerForClass ( ) ; private static Map guiTitles ; private static Map guiTags ; private static Map funcTitles ; public JMeterTest ( String name ) { } private TestElement testItem ; public JMeterTest ( String testName , TestElement te ) { } private Serializable serObj ; public JMeterTest ( String testName , Serializable ser ) { } private JMeterGUIComponent guiItem ; public JMeterTest ( String testName , JMeterGUIComponent gc ) { } private Function funcItem ; private static boolean classPathShown = false ; public JMeterTest ( String testName , Function fi ) { } public static Test suite ( ) throws Exception { } public void createTitleSet ( ) throws Exception { } public void createTagSet ( ) throws Exception { } public void createFunctionSet ( ) throws Exception { } private int scanprintMap ( Map m , String t ) { } public void checkGuiSet ( ) throws Exception { } public void checkFunctionSet ( ) throws Exception { } private static Test suiteGUIComponents ( ) throws Exception { } private static Test suiteFunctions ( ) throws Exception { } private static Test suiteBeanComponents ( ) throws Exception { } public void runGUITitle ( ) throws Exception { } public void runFunction ( ) throws Exception { } public void runFunction2 ( ) throws Exception { } public void GUIComponents1 ( ) throws Exception { } public void GUIComponents2 ( ) throws Exception { } private static Test suiteSerializableElements ( ) throws Exception { } public void runSerialTest ( ) throws Exception { } private static Test suiteTestElements ( ) throws Exception { } public void runTestElement ( ) throws Exception { } private static Collection getObjects ( Class extendsClass ) throws Exception { String exName = extendsClass . getName ( ) ; Object myThis = "" ; Iterator classes = ClassFinder . findClassesThatExtend ( JMeterUtils . getSearchPaths ( ) , new Class [ ] { extendsClass } ) . iterator ( ) ; List objects = new LinkedList ( ) ; String n = "" ; boolean caughtError = true ; Throwable caught = null ; try { while ( classes . hasNext ( ) ) { n = ( ( String ) ( classes . next ( ) ) ) ; if ( n . endsWith ( "RemoteJMeterEngineImpl" ) ) { continue ; } Class c = null ; try { c = Class . forName ( n ) ; try { objects . add ( c . newInstance ( ) ) ; } catch ( InstantiationException e ) { caught = e ; try { objects . add ( c . getConstructor ( new Class [ ] { Object . class } ) . newInstance ( new Object [ ] { myThis } ) ) ; } catch ( NoSuchMethodException f ) { System . out . println ( ( ( ( "WARN:<seq2seq4repair_space>" + exName ) + ":<seq2seq4repair_space>NoSuchMethodException<seq2seq4repair_space>" ) + n ) ) ; } } } catch ( NoClassDefFoundError e ) { System . out . println ( ( ( ( "WARN:<seq2seq4repair_space>" + exName ) + ":<seq2seq4repair_space>NoClassDefFoundError<seq2seq4repair_space>" ) + n ) ) ; } catch ( IllegalAccessException e ) { caught = e ; System . out . println ( ( ( ( "WARN:<seq2seq4repair_space>" + exName ) + ":<seq2seq4repair_space>IllegalAccessException<seq2seq4repair_space>" ) + n ) ) ; } catch ( Exception e ) { caught = e ; if ( ( e instanceof RemoteException ) || ( e . getClass ( ) . getName ( ) . equals ( "java.awt.HeadlessException" ) ) ) { System . out . println ( ( ( ( ( "WARN:<seq2seq4repair_space>" + "Error<seq2seq4repair_space>creating<seq2seq4repair_space>" ) + n ) + "<seq2seq4repair_space>" ) + ( e . toString ( ) ) ) ) ; } else { throw new Exception ( ( ( ( "Error<seq2seq4repair_space>creating<seq2seq4repair_space>" + n ) + "<seq2seq4repair_space>" ) + ( e . toString ( ) ) ) ) ; } } } caughtError = false ; } finally { if ( caughtError ) { System . out . println ( ( "Last<seq2seq4repair_space>class=" + n ) ) ; System . out . println ( ( "objects.size=" + ( objects . size ( ) ) ) ) ; System . out . println ( ( "Last<seq2seq4repair_space>error=" + caught ) ) ; } } if ( ( objects . size ( ) ) == 0 ) { System . out . println ( ( ( "No<seq2seq4repair_space>classes<seq2seq4repair_space>found<seq2seq4repair_space>that<seq2seq4repair_space>extend<seq2seq4repair_space>" + exName ) + ".<seq2seq4repair_space>Check<seq2seq4repair_space>the<seq2seq4repair_space>following:" ) ) ; System . out . println ( "Search<seq2seq4repair_space>paths<seq2seq4repair_space>are:" ) ; String [ ] ss = JMeterUtils . getSearchPaths ( ) ; for ( int i = 0 ; i < ( ss . length ) ; i ++ ) { System . out . println ( ss [ i ] ) ; } <START_BUG> if ( ( ! ( JMeterTest . classPathShown ) ) <= false ) { <END_BUG> System . out . println ( "Class<seq2seq4repair_space>path<seq2seq4repair_space>is:" ) ; String cp = System . getProperty ( "java.class.path" ) ; String [ ] cpe = JOrphanUtils . split ( cp , File . pathSeparator ) ; for ( int i = 0 ; i < ( cpe . length ) ; i ++ ) { System . out . println ( cpe [ i ] ) ; } JMeterTest . classPathShown = true ; } } return objects ; } private static void cloneTesting ( TestElement item , TestElement clonedItem ) { } private static void checkElementCloning ( TestElement item ) { } }
public class Choices < T > extends AbstractOptions < T > { private static final long serialVersionUID = 1L ; public Choices ( String id , Palette < T > palette ) { } @ Override protected void onComponentTag ( ComponentTag tag ) { super . onComponentTag ( tag ) ; IValueMap attrs = tag . getAttributes ( ) ; String onFocus = Choices . getPalette ( ) . getChoicesOnFocusJS ( ) ; if ( onFocus != null ) { <START_BUG> attrs . put ( "onFocus" , onFocus ) ; <END_BUG> } tag . getAttributes ( ) . put ( "ondblclick" , Choices . getPalette ( ) . getAddOnClickJS ( ) ) ; } @ Override protected Iterator < T > getOptionsIterator ( ) { } }
public class CodeFlow implements Opcodes { private final Stack < ArrayList < String > > compilationScopes ; public CodeFlow ( ) { } public void loadTarget ( MethodVisitor mv ) { } public void pushDescriptor ( String descriptor ) { <START_BUG> Assert . notNull ( descriptor ) ; <END_BUG> this . compilationScopes . peek ( ) . add ( descriptor ) ; } public void enterCompilationScope ( ) { } public void exitCompilationScope ( ) { } public String lastDescriptor ( ) { } public void unboxBooleanIfNecessary ( MethodVisitor mv ) { } public static void insertUnboxInsns ( MethodVisitor mv , char ch , boolean isObject ) { } public static String createSignatureDescriptor ( Method method ) { } public static String createSignatureDescriptor ( Constructor < ? > ctor ) { } public static String toJVMDescriptor ( Class < ? > clazz ) { } public static String toDescriptorFromObject ( Object value ) { } public static boolean isBooleanCompatible ( String descriptor ) { } public static boolean isPrimitive ( String descriptor ) { } public static boolean isPrimitiveArray ( String descriptor ) { } public static boolean areBoxingCompatible ( String desc1 , String desc2 ) { } public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean ( String descriptor ) { } public static boolean isPrimitiveOrUnboxableSupportedNumber ( String descriptor ) { } public static char toPrimitiveTargetDesc ( String descriptor ) { } public static void insertCheckCast ( MethodVisitor mv , String descriptor ) { } public static void insertBoxIfNecessary ( MethodVisitor mv , String descriptor ) { } public static void insertBoxIfNecessary ( MethodVisitor mv , char ch ) { } public static String toDescriptor ( Class < ? > type ) { } public static String [ ] toParamDescriptors ( Method method ) { } public static String [ ] toParamDescriptors ( Constructor < ? > ctor ) { } private static String [ ] toDescriptors ( Class < ? > [ ] types ) { } }
public class WeatherDetail extends Activity { private static final String TAG = WeatherDetail . class . getSimpleName ( ) ; private TextView cityName ; private TextView weatherDate ; private ProgressBar progressBar ; private ImageView weatherIcon ; private TextView noImage ; private TextView tempLabel ; private TextView tempEve ; private TextView tempMax ; private TextView tempMin ; private TextView des ; private int day ; private WeatherJSONEntity weatherResult ; private List weatherList ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } private void findViews ( ) { } private void extractFromBundle ( ) { } private void initViews ( ) { Calendar currentDate = Calendar . getInstance ( ) ; SimpleDateFormat myFmt = new SimpleDateFormat ( getString ( format_date ) , Locale . getDefault ( ) ) ; currentDate . add ( Calendar . DAY_OF_MONTH , ( ( day ) + 1 ) ) ; cityName . setText ( ( ( ( weatherResult . city . name ) + "<seq2seq4repair_space>" ) + ( getString ( weather ) ) ) ) ; weatherDate . setText ( ( ( day ) == 0 ? getString ( tmr ) : myFmt . format ( currentDate . getTime ( ) ) ) ) ; <START_BUG> tempEve . setText ( ( ( weatherList . temp . eve ) + ( getString ( tempsymbol ) ) ) ) ; <END_BUG> tempMax . setText ( ( ( ( ( getString ( max ) ) + "<seq2seq4repair_space>" ) + ( weatherList . temp . max ) ) + ( getString ( tempsymbol ) ) ) ) ; tempMin . setText ( ( ( ( ( getString ( min ) ) + "<seq2seq4repair_space>" ) + ( weatherList . temp . min ) ) + ( getString ( tempsymbol ) ) ) ) ; des . setText ( weatherList . weather . get ( 0 ) . description ) ; } private void showProgress ( final boolean show ) { } private void downloadIcon ( ) { } class DownloadIconTask extends AsyncTask < String , Integer , Bitmap > { Bitmap bm = null ; @ Override protected Bitmap doInBackground ( String ... params ) { } @ Override protected void onCancelled ( ) { } @ Override protected void onPostExecute ( Bitmap result ) { } @ Override protected void onPreExecute ( ) { } } }
public class JdbcQuery implements SqlQuery { final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; Connection connection ; String queryString ; List < String > scalars = new ArrayList < String > ( ) ; Map < String , Object > scalarTypes = new HashMap < String , Object > ( ) ; List < String > parameters = new ArrayList < String > ( ) ; Map < String , Object > parameterValues = new HashMap < String , Object > ( ) ; Map < String , Object > parameterTypes = new HashMap < String , Object > ( ) ; Map < String , Object > parameterOutValueTypes = new HashMap < String , Object > ( ) ; Map < String , OutValueSetter > parameterOutValueSetters = new HashMap < String , OutValueSetter > ( ) ; Map < Integer , Integer > parameterOutValuesToPickup = new LinkedHashMap < Integer , Integer > ( ) ; List < String > identities = new ArrayList < String > ( ) ; Map < String , IdentitySetter > identitySetters = new HashMap < String , IdentitySetter > ( ) ; Map < String , Object > identityTypes = new HashMap < String , Object > ( ) ; Integer timeout ; Integer firstResult ; Integer maxResults ; public JdbcQuery ( Connection connection , String queryString ) { } @ Override public Object getQuery ( ) { } @ Override public SqlQuery setTimeout ( int timeout ) { } @ Override public SqlQuery setFirstResult ( int firstResult ) { } @ Override public SqlQuery setMaxResults ( int maxResults ) { } @ Override public List list ( ) throws SqlProcessorException { } @ Override public Object unique ( ) throws SqlProcessorException { } @ Override public int update ( ) throws SqlProcessorException { } protected void doIdentitySelect ( String identityName ) { } static final Pattern CALL = Pattern . compile ( "\\s*\\{?\\s*(\\?)?\\s*=?\\s*call\\s*(.*?)\\s*}?\\s*" ) ; @ Override public List callList ( ) throws SqlProcessorException { } @ Override public Object callUnique ( ) throws SqlProcessorException { } @ Override public int callUpdate ( ) throws SqlProcessorException { } @ Override public Object callFunction ( ) throws SqlProcessorException { } @ Override public SqlQuery addScalar ( String columnAlias ) { } @ Override public SqlQuery addScalar ( String columnAlias , Object type ) { } @ Override public SqlQuery setParameter ( String name , Object val ) throws SqlProcessorException { } @ Override public SqlQuery setParameter ( String name , Object val , Object type ) throws SqlProcessorException { } @ Override public SqlQuery setParameterList ( String name , Object [ ] vals ) throws SqlProcessorException { } @ Override public SqlQuery setParameterList ( String name , Object [ ] vals , Object type ) throws SqlProcessorException { } protected void setParameters ( PreparedStatement ps , SqlUtils . LimitType limitType , int start ) throws SQLException , SqlProcessorException { int ix = start ; ix = setLimits ( ps , limitType , ix , false ) ; for ( int i = 0 , n = parameters . size ( ) ; i < n ; i ++ ) { String name = parameters . get ( i ) ; Object type = parameterTypes . get ( name ) ; if ( parameterValues . containsKey ( name ) ) { Object value = parameterValues . get ( name ) ; if ( type != null ) { if ( type instanceof JdbcSqlType ) { JdbcSqlType sqlType = ( ( JdbcSqlType ) ( type ) ) ; try { sqlType . set ( ps , ( ix + i ) , value ) ; } catch ( ClassCastException cce ) { StringBuilder sb = new StringBuilder ( "Not<seq2seq4repair_space>compatible<seq2seq4repair_space>input<seq2seq4repair_space>value<seq2seq4repair_space>of<seq2seq4repair_space>type<seq2seq4repair_space>" ) . append ( ( value != null ? value . getClass ( ) : "null" ) ) ; sb . append ( ".<seq2seq4repair_space>The<seq2seq4repair_space>JDBC<seq2seq4repair_space>type<seq2seq4repair_space>for<seq2seq4repair_space>" ) . append ( name ) . append ( "<seq2seq4repair_space>is<seq2seq4repair_space>" ) . append ( ( sqlType != null ? sqlType . getClass ( ) : "null" ) ) ; sb . append ( "." ) ; throw new SqlProcessorException ( sb . toString ( ) , cce ) ; } } else if ( value == null ) { ps . setNull ( ( ix + i ) , ( ( Integer ) ( type ) ) ) ; } else { ps . setObject ( ( ix + i ) , value , ( ( Integer ) ( type ) ) ) ; } } else { ps . setObject ( ( ix + i ) , value ) ; } } if ( parameterOutValueSetters . containsKey ( name ) ) { CallableStatement cs = ( ( CallableStatement ) ( ps ) ) ; if ( type != null ) { if ( type instanceof SqlProviderType ) { cs . registerOutParameter ( ( ix + i ) , ( ( Integer ) ( ( ( SqlProviderType ) ( type ) ) . getProviderSqlNullType ( ) ) ) ) ; } else { cs . registerOutParameter ( ( ix + i ) , ( ( Integer ) ( type ) ) ) ; } } else { throw new SqlProcessorException ( "OUT<seq2seq4repair_space>parameter<seq2seq4repair_space>type<seq2seq4repair_space>for<seq2seq4repair_space>callable<seq2seq4repair_space>statement<seq2seq4repair_space>is<seq2seq4repair_space>null" ) ; } parameterOutValuesToPickup . put ( i , ( ix + i ) ) ; } } <START_BUG> ix = setLimits ( ps , limitType , ix , true ) ; <END_BUG> } protected int setLimits ( PreparedStatement ps , SqlUtils . LimitType limitType , int ix , boolean afterSql ) throws SQLException { } protected Object getParameters ( CallableStatement cs , boolean isFunction ) throws SQLException { } protected List getResults ( ResultSet rs ) throws SQLException { } }
public class Form extends WebMarkupContainer implements IFormSubmitListener { public abstract static class ValidationVisitor implements FormComponent . IVisitor { public Object formComponent ( IFormVisitorParticipant component ) { } public abstract void validate ( FormComponent formComponent ) { } } class FormDispatchRequest extends Request { private final ValueMap params = new ValueMap ( ) ; private final Request realRequest ; private final String url ; public FormDispatchRequest ( final Request realRequest , final String url ) { } public Locale getLocale ( ) { } public String getParameter ( String key ) { } public Map getParameterMap ( ) { } public String [ ] getParameters ( String key ) { } public String getPath ( ) { } public String getRelativePathPrefixToContextRoot ( ) { } public String getRelativePathPrefixToWicketHandler ( ) { } public String getURL ( ) { } } public static final String METHOD_GET = "get" ; public static final String METHOD_POST = "post" ; private static final short FLAG_SUBMITTED = FLAG_RESERVED1 ; private static final Logger log = LoggerFactory . getLogger ( Form . class ) ; private static final long serialVersionUID = 1L ; private static final String UPLOAD_FAILED_RESOURCE_KEY = "uploadFailed" ; private static final String UPLOAD_TOO_LARGE_RESOURCE_KEY = "uploadTooLarge" ; private IFormSubmittingComponent defaultSubmittingComponent ; private Object formValidators = null ; private String javascriptId ; private Bytes maxSize = null ; private boolean multiPart = false ; public Form ( final String id ) { } public Form ( final String id , IModel model ) { } public void add ( IFormValidator validator ) { } public void remove ( IFormValidator validator ) { } private final int formValidators_indexOf ( IFormValidator validator ) { } private final IFormValidator formValidators_remove ( IFormValidator validator ) { } private final IFormValidator formValidators_remove ( int index ) { } public final void clearInput ( ) { } public final void error ( String error , Map args ) { } public final IFormSubmittingComponent findSubmittingButton ( ) { } public final IFormSubmittingComponent getDefaultButton ( ) { } public final CharSequence getJsForInterfaceUrl ( CharSequence url ) { } public Bytes getMaxSize ( ) { } public Form getRootForm ( ) { } public String getValidatorKeyPrefix ( ) { } public final boolean hasError ( ) { } public boolean isRootForm ( ) { } public final boolean isSubmitted ( ) { } public boolean isVersioned ( ) { } public final void loadPersistentFormComponentValues ( ) { } public final void onFormSubmitted ( ) { } public boolean process ( ) { } private void callOnError ( ) { } private void markFormsSubmitted ( ) { } public void removePersistentFormComponentValues ( final boolean disablePersistence ) { } public final void setDefaultButton ( IFormSubmittingComponent submittingComponent ) { } public void setMaxSize ( final Bytes maxSize ) { } public void setMultiPart ( boolean multiPart ) { } public final Component setVersioned ( final boolean isVersioned ) { } public final void visitFormComponents ( final FormComponent . IVisitor visitor ) { } public final void visitFormComponentsPostOrder ( final FormComponent . IVisitor visitor ) { } private void visitChildrenInContainingBorder ( final FormComponent . IVisitor visitor ) { } private boolean anyFormComponentError ( ) { } private void dispatchEvent ( final Page page , final String url ) { } private void formValidators_add ( final IFormValidator validator ) { } private IFormValidator formValidators_get ( int index ) { } private int formValidators_size ( ) { } private void inputChanged ( ) { } private void persistFormComponentData ( ) { } protected void appendDefaultButtonField ( final MarkupStream markupStream , final ComponentTag openTag ) { } protected void beforeUpdateFormComponentModels ( ) { } protected void delegateSubmit ( IFormSubmittingComponent submittingComponent ) { } protected final String getHiddenFieldId ( ) { } protected final String getJavascriptId ( ) { } protected String getMethod ( ) { } protected boolean getStatelessHint ( ) { } protected IValuePersister getValuePersister ( ) { } protected boolean handleMultiPart ( ) { } protected void internalOnModelChanged ( ) { } protected final void markFormComponentsInvalid ( ) { } protected final void markFormComponentsValid ( ) { } private void markNestedFormComponentsValid ( ) { } private void internalMarkFormComponentsValid ( ) { } protected void onComponentTag ( final ComponentTag tag ) { } protected void onComponentTagBody ( final MarkupStream markupStream , final ComponentTag openTag ) { } protected void onDetach ( ) { } protected void onError ( ) { } protected void onRender ( final MarkupStream markupStream ) { } protected void onSubmit ( ) { } protected final void updateFormComponentModels ( ) { } private final void updateNestedFormComponentModels ( ) { } private void internalUpdateFormComponentModels ( ) { } protected void validate ( ) { } protected final void validateComponents ( ) { <START_BUG> visitFormComponents ( new Form . ValidationVisitor ( ) { <END_BUG> public void validate ( final FormComponent formComponent ) { final Form form = formComponent . getForm ( ) ; if ( ( ( ( form == ( Form . this ) ) && ( form . isEnabled ( ) ) ) && ( form . isEnableAllowed ( ) ) ) && ( form . isVisibleInHierarchy ( ) ) ) { formComponent . validate ( ) ; } } } ) ; } private boolean isFormComponentVisibleInPage ( FormComponent fc ) { } protected final void validateFormValidator ( final IFormValidator validator ) { } protected final void validateFormValidators ( ) { } private void validateNestedForms ( ) { } private class FormValidatorRemovedChange extends Change { private static final long serialVersionUID = 1L ; private final IFormValidator removed ; public FormValidatorRemovedChange ( final IFormValidator removed ) { } public void undo ( ) { } } }
public final class LegacyActionPersistence extends RegistryPersistence { private static final int INDEX_ACTION_SETS = 0 ; private static final int INDEX_EDITOR_CONTRIBUTIONS = 1 ; private static final int INDEX_OBJECT_CONTRIBUTIONS = 2 ; private static final int INDEX_VIEW_CONTRIBUTIONS = 3 ; private static final int INDEX_VIEWER_CONTRIBUTIONS = 4 ; private static final SLocation createLocation ( final String barType , final String path , final LegacyLocationInfo locationInfo , final char mnemonic , final String imageStyle ) { final LeafLocationElement leafElement = new SBar ( barType , path ) ; final LocationElement locationElement ; if ( locationInfo == null ) { locationElement = leafElement ; } else { locationElement = locationInfo . append ( leafElement ) ; } <START_BUG> return new SLocation ( mnemonic , imageStyle , null , locationElement ) ; <END_BUG> } private static final Expression readVisibility ( final IConfigurationElement parentElement , final String parentId , final List warningsToLog ) { } private final BindingManager bindingManager ; private final CommandImageManager commandImageManager ; private final CommandManager commandManager ; private final Collection menuContributions = new ArrayList ( ) ; private final IMenuService menuService ; public LegacyActionPersistence ( final CommandManager commandManager , final BindingManager bindingManager , final CommandImageManager commandImageManager , final IMenuService menuService ) { } private final void clearBindings ( ) { } private final void clearImages ( ) { } private final void clearMenus ( ) { } private final void convertActionToBinding ( final IConfigurationElement element , final ParameterizedCommand command ) { } private final ParameterizedCommand convertActionToCommand ( final IConfigurationElement element , final String primaryId , final String secondaryId , final List warningsToLog ) { } private final String convertActionToImages ( final IConfigurationElement element , final ParameterizedCommand command ) { } private final void convertActionToItem ( final IConfigurationElement element , final List warningsToLog , final ParameterizedCommand command , final String imageStyle , final LegacyLocationInfo locationInfo , final Expression visibleWhenExpression ) { } protected final boolean isChangeImportant ( final IRegistryChangeEvent event ) { } public final void dispose ( ) { } public final void read ( ) { } private final SReference [ ] readActions ( final String primaryId , final IConfigurationElement [ ] elements , final List warningsToLog , final LegacyLocationInfo locationInfo , final Expression visibleWhenExpression ) { } private final SReference [ ] readActionsAndMenus ( final IConfigurationElement element , final String id , final List warningsToLog , final LegacyLocationInfo locationInfo , final Expression visibleWhenExpression ) { } private final void readActionSets ( final IConfigurationElement [ ] configurationElements , final int configurationElementCount ) { } private final void readEditorContributions ( final IConfigurationElement [ ] configurationElements , final int configurationElementCount ) { } private final SReference [ ] readGroups ( final IConfigurationElement [ ] elements , final List warningsToLog , final String path , final LegacyLocationInfo locationInfo , final Expression visibleWhenExpression , final boolean separatorsVisible ) { } private final SReference [ ] readMenusAndGroups ( final IConfigurationElement [ ] menuElements , final String contributionId , final List warningsToLog , final LegacyLocationInfo locationInfo , final Expression visibleWhenExpression ) { } private final void readObjectContributions ( final IConfigurationElement [ ] configurationElements , final int configurationElementCount ) { } private final void readViewContributions ( final IConfigurationElement [ ] configurationElements , final int configurationElementCount ) { } private final void readViewerContributions ( final IConfigurationElement [ ] configurationElements , final int configurationElementCount ) { } }
public class DeployCommandDialog extends JDialog implements ActionListener { private static JFileChooser fileChooser = new JFileChooser ( new File ( "." ) ) ; private JPanel inputPanel = new JPanel ( new GridBagLayout ( ) ) ; private JTextField pathField = new JTextField ( 40 ) ; private JTextField nameField = new JTextField ( 40 ) ; private JTextField runtimeNameField = new JTextField ( 40 ) ; private JCheckBox forceCheckBox = new JCheckBox ( "force" ) ; private JCheckBox disabledCheckBox = new JCheckBox ( "disabled" ) ; private ServerGroupChooser serverGroupChooser = new ServerGroupChooser ( ) ; private JCheckBox allServerGroups = new JCheckBox ( "all-server-groups" ) ; public DeployCommandDialog ( ) { } private void setAllServerGroupsListener ( ) { } private void setForceListener ( ) { } private JPanel makeInputPanel ( ) { } private void addStrut ( ) { } private JPanel makeButtonPanel ( ) { } public void actionPerformed ( ActionEvent e ) { StringBuilder builder = new StringBuilder ( "deploy" ) ; String path = pathField . getText ( ) ; if ( ! ( path . trim ( ) . isEmpty ( ) ) ) { builder . append ( "<seq2seq4repair_space>" ) . append ( path ) ; } else { JOptionPane . showMessageDialog ( this , "A<seq2seq4repair_space>file<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>selected." , "Empty<seq2seq4repair_space>File<seq2seq4repair_space>Path" , JOptionPane . ERROR_MESSAGE ) ; return ; } String name = nameField . getText ( ) ; if ( ! ( name . trim ( ) . isEmpty ( ) ) ) builder . append ( "<seq2seq4repair_space>--name=" ) . append ( name ) ; String runtimeName = runtimeNameField . getText ( ) ; if ( ! ( runtimeName . trim ( ) . isEmpty ( ) ) ) <START_BUG> builder . append ( "<seq2seq4repair_space>--runtime_name=" ) . append ( runtimeName ) ; <END_BUG> if ( forceCheckBox . isSelected ( ) ) builder . append ( "<seq2seq4repair_space>--force" ) ; if ( ( disabledCheckBox . isSelected ( ) ) && ( disabledCheckBox . isEnabled ( ) ) ) builder . append ( "<seq2seq4repair_space>--disabled" ) ; if ( ! ( serverGroupChooser . isStandalone ( ) ) ) { if ( ( allServerGroups . isSelected ( ) ) && ( allServerGroups . isEnabled ( ) ) ) { builder . append ( "<seq2seq4repair_space>--all-server-groups" ) ; } else if ( serverGroupChooser . isEnabled ( ) ) { builder . append ( serverGroupChooser . getCmdLineArg ( ) ) ; } } JTextComponent cmdText = GuiMain . getCommandLine ( ) . getCmdText ( ) ; cmdText . setText ( builder . toString ( ) ) ; dispose ( ) ; cmdText . requestFocus ( ) ; } }
public class LatencyDistributionProbe implements IntervalProbe < LatencyDistributionResult , LatencyDistributionProbe > { private static final int MAXIMUM_LATENCY = ( ( int ) ( TimeUnit . SECONDS . toMicros ( 5 ) ) ) ; private static final int STEP = 10 ; private final LinearHistogram histogram = new LinearHistogram ( LatencyDistributionProbe . MAXIMUM_LATENCY , LatencyDistributionProbe . STEP ) ; private long started ; @ Override public void started ( ) { } @ Override public void done ( ) { <START_BUG> histogram . addValue ( ( ( int ) ( TimeUnit . NANOSECONDS . toMillis ( ( ( System . nanoTime ( ) ) - ( started ) ) ) ) ) ) ; <END_BUG> } @ Override public void startProbing ( long time ) { } @ Override public void stopProbing ( long time ) { } @ Override public LatencyDistributionResult getResult ( ) { } @ Override public LatencyDistributionProbe createNew ( Long arg ) { } }
public class HelloHostApplication implements IDistributionConstants , IApplication { private static final String DEFAULT_CONTAINER_TYPE = "ecf.r_osgi.peer" ; public static final String DEFAULT_CONTAINER_ID = null ; private BundleContext bundleContext ; private ServiceTracker containerManagerServiceTracker ; private String containerType = HelloHostApplication . DEFAULT_CONTAINER_TYPE ; private String containerId = HelloHostApplication . DEFAULT_CONTAINER_ID ; private final Object appLock = new Object ( ) ; private boolean done = false ; private ServiceRegistration helloRegistration ; public Object start ( IApplicationContext appContext ) throws Exception { bundleContext = Activator . getContext ( ) ; processArgs ( appContext ) ; IContainerManager containerManager = getContainerManagerService ( ) ; if ( ( ( containerId ) == null ) || ( "" . equals ( containerId ) ) ) containerManager . getContainerFactory ( ) . createContainer ( containerType ) ; else containerManager . getContainerFactory ( ) . createContainer ( containerType , new Object [ ] { containerId } ) ; Properties props = new Properties ( ) ; <START_BUG> props . put ( REMOTE_INTERFACES , REMOTE_INTERFACES_WILDCARD ) ; <END_BUG> helloRegistration = bundleContext . registerService ( IHello . class . getName ( ) , new Hello ( ) , props ) ; System . out . println ( "Host:<seq2seq4repair_space>Hello<seq2seq4repair_space>Service<seq2seq4repair_space>Registered" ) ; waitForDone ( ) ; return IApplication . EXIT_OK ; } public void stop ( ) { } private IContainerManager getContainerManagerService ( ) { } private void processArgs ( IApplicationContext appContext ) { } private void waitForDone ( ) { } }
StAXSchemaParser fStAXSchemaParser ; XML11Configuration fAnnotationValidator ; XSDHandler . XSAnnotationGrammarPool fGrammarBucketAdapter ; private static final int INIT_STACK_SIZE = 30 ; private static final int INC_STACK_SIZE = 10 ; private int fLocalElemStackPos = 0 ; private XSParticleDecl [ ] fParticle = new XSParticleDecl [ XSDHandler . INIT_STACK_SIZE ] ; private Element [ ] fLocalElementDecl = new Element [ XSDHandler . INIT_STACK_SIZE ] ; private XSDocumentInfo [ ] fLocalElementDecl_schema = new XSDocumentInfo [ XSDHandler . INIT_STACK_SIZE ] ; private int [ ] fAllContext = new int [ XSDHandler . INIT_STACK_SIZE ] ; private XSObject [ ] fParent = new XSObject [ XSDHandler . INIT_STACK_SIZE ] ; private String [ ] [ ] fLocalElemNamespaceContext = new String [ XSDHandler . INIT_STACK_SIZE ] [ 1 ] ; private static final int INIT_KEYREF_STACK = 2 ; private static final int INC_KEYREF_STACK_AMOUNT = 2 ; private int fKeyrefStackPos = 0 ; private Element [ ] fKeyrefs = new Element [ XSDHandler . INIT_KEYREF_STACK ] ; private XSDocumentInfo [ ] fKeyrefsMapXSDocumentInfo = new XSDocumentInfo [ XSDHandler . INIT_KEYREF_STACK ] ; private XSElementDecl [ ] fKeyrefElems = new XSElementDecl [ XSDHandler . INIT_KEYREF_STACK ] ; private String [ ] [ ] fKeyrefNamespaceContext = new String [ XSDHandler . INIT_KEYREF_STACK ] [ 1 ] ; SymbolHash fGlobalAttrDecls = new SymbolHash ( ) ; SymbolHash fGlobalAttrGrpDecls = new SymbolHash ( ) ; SymbolHash fGlobalElemDecls = new SymbolHash ( ) ; SymbolHash fGlobalGroupDecls = new SymbolHash ( ) ; SymbolHash fGlobalNotationDecls = new SymbolHash ( ) ; SymbolHash fGlobalIDConstraintDecls = new SymbolHash ( ) ; SymbolHash fGlobalTypeDecls = new SymbolHash ( ) ; public XSDHandler ( ) { } public XSDHandler ( XSGrammarBucket gBucket ) { } public SchemaGrammar parseSchema ( XMLInputSource is , XSDDescription desc , Hashtable locationPairs ) throws IOException { fLocationPairs = locationPairs ; fSchemaParser . resetNodePool ( ) ; SchemaGrammar grammar = null ; String schemaNamespace = null ; short referType = desc . getContextType ( ) ; if ( referType != ( XSDDescription . CONTEXT_PREPARSE ) ) { if ( ( ( fHonourAllSchemaLocations ) && ( referType == ( XSDDescription . CONTEXT_IMPORT ) ) ) && ( isExistingGrammar ( desc , fNamespaceGrowth ) ) ) { grammar = fGrammarBucket . getGrammar ( desc . getTargetNamespace ( ) ) ; } else { grammar = findGrammar ( desc , fNamespaceGrowth ) ; } if ( grammar != null ) { if ( ! ( fNamespaceGrowth ) ) { return grammar ; } else { try { if ( grammar . getDocumentLocations ( ) . contains ( XMLEntityManager . expandSystemId ( is . getSystemId ( ) , is . getBaseSystemId ( ) , false ) ) ) { return grammar ; } } catch ( MalformedURIException e ) { } } } schemaNamespace = desc . getTargetNamespace ( ) ; if ( schemaNamespace != null ) { schemaNamespace = fSymbolTable . addSymbol ( schemaNamespace ) ; } } prepareForParse ( ) ; Element schemaRoot = null ; if ( is instanceof DOMInputSource ) { schemaRoot = getSchemaDocument ( schemaNamespace , ( ( DOMInputSource ) ( is ) ) , ( referType == ( XSDDescription . CONTEXT_PREPARSE ) ) , referType , null ) ; } else if ( is instanceof SAXInputSource ) { schemaRoot = getSchemaDocument ( schemaNamespace , ( ( SAXInputSource ) ( is ) ) , ( referType == ( XSDDescription . CONTEXT_PREPARSE ) ) , referType , null ) ; } else if ( is instanceof StAXInputSource ) { schemaRoot = getSchemaDocument ( schemaNamespace , ( ( StAXInputSource ) ( is ) ) , ( referType == ( XSDDescription . CONTEXT_PREPARSE ) ) , referType , null ) ; } else if ( is instanceof XSInputSource ) { schemaRoot = getSchemaDocument ( ( ( XSInputSource ) ( is ) ) , desc ) ; } else { schemaRoot = getSchemaDocument ( schemaNamespace , is , ( referType == ( XSDDescription . CONTEXT_PREPARSE ) ) , referType , null ) ; } if ( schemaRoot == null ) { if ( is instanceof XSInputSource ) { return fGrammarBucket . getGrammar ( desc . getTargetNamespace ( ) ) ; } <START_BUG> return null ; <END_BUG> } if ( referType == ( XSDDescription . CONTEXT_PREPARSE ) ) { Element schemaElem = schemaRoot ; schemaNamespace = DOMUtil . getAttrValue ( schemaElem , ATT_TARGETNAMESPACE ) ; if ( ( schemaNamespace != null ) && ( ( schemaNamespace . length ( ) ) > 0 ) ) { schemaNamespace = fSymbolTable . addSymbol ( schemaNamespace ) ; desc . setTargetNamespace ( schemaNamespace ) ; } else { schemaNamespace = null ; } grammar = findGrammar ( desc , fNamespaceGrowth ) ; String schemaId = XMLEntityManager . expandSystemId ( is . getSystemId ( ) , is . getBaseSystemId ( ) , false ) ; if ( grammar != null ) { if ( ( ! ( fNamespaceGrowth ) ) || ( grammar . getDocumentLocations ( ) . contains ( schemaId ) ) ) { return grammar ; } } XSDHandler . XSDKey key = new XSDHandler . XSDKey ( schemaId , referType , schemaNamespace ) ; fTraversed . put ( key , schemaRoot ) ; if ( schemaId != null ) { fDoc2SystemId . put ( schemaRoot , schemaId ) ; } } prepareForTraverse ( ) ; fRoot = constructTrees ( schemaRoot , is . getSystemId ( ) , desc , ( grammar != null ) ) ; if ( ( fRoot ) == null ) { return null ; } buildGlobalNameRegistries ( ) ; ArrayList annotationInfo = ( fValidateAnnotations ) ? new ArrayList ( ) : null ; traverseSchemas ( annotationInfo ) ; traverseLocalElements ( ) ; resolveKeyRefs ( ) ; for ( int i = ( fAllTNSs . size ( ) ) - 1 ; i >= 0 ; i -- ) { String tns = ( ( String ) ( fAllTNSs . elementAt ( i ) ) ) ; Vector ins = ( ( Vector ) ( fImportMap . get ( tns ) ) ) ;
public class ImageTransfer extends ByteArrayTransfer { private static ImageTransfer _instance = new ImageTransfer ( ) ; private static final String CF_DIB = "CF_DIB" ; private static final int CF_DIBID = COM . CF_DIB ; private ImageTransfer ( ) { } public static ImageTransfer getInstance ( ) { } public void javaToNative ( Object object , TransferData transferData ) { } public Object nativeToJava ( TransferData transferData ) { if ( ( ! ( isSupportedType ( transferData ) ) ) || ( ( transferData . pIDataObject ) == 0 ) ) return null ; IDataObject dataObject = new IDataObject ( transferData . pIDataObject ) ; dataObject . AddRef ( ) ; FORMATETC formatetc = new FORMATETC ( ) ; formatetc . cfFormat = COM . CF_DIB ; formatetc . ptd = 0 ; formatetc . dwAspect = COM . DVASPECT_CONTENT ; formatetc . lindex = - 1 ; formatetc . tymed = COM . TYMED_HGLOBAL ; STGMEDIUM stgmedium = new STGMEDIUM ( ) ; stgmedium . tymed = COM . TYMED_HGLOBAL ; transferData . result = getData ( dataObject , formatetc , stgmedium ) ; if ( ( transferData . result ) != ( COM . S_OK ) ) return null ; int hMem = stgmedium . unionField ; dataObject . Release ( ) ; try { int ptr = OS . GlobalLock ( hMem ) ; if ( ptr == 0 ) return null ; try { BITMAPINFOHEADER bmiHeader = new BITMAPINFOHEADER ( ) ; OS . MoveMemory ( bmiHeader , ptr , sizeof ) ; int [ ] pBits = new int [ 1 ] ; int memDib = OS . CreateDIBSection ( 0 , ptr , DIB_RGB_COLORS , pBits , 0 , 0 ) ; if ( memDib == 0 ) SWT . error ( ERROR_NO_HANDLES ) ; int bits = ptr + ( bmiHeader . biSize ) ; if ( ( bmiHeader . biBitCount ) <= 8 ) { <START_BUG> bits += ( 1 << ( bmiHeader . biBitCount ) ) * 4 ; <END_BUG> } else if ( ( bmiHeader . biCompression ) == ( OS . BI_BITFIELDS ) ) { bits += 12 ; } if ( ( bmiHeader . biHeight ) < 0 ) { OS . MoveMemory ( pBits [ 0 ] , bits , bmiHeader . biSizeImage ) ; } else { DIBSECTION dib = new DIBSECTION ( ) ; OS . GetObject ( memDib , DIBSECTION . sizeof , dib ) ; int biHeight = dib . biHeight ; int scanline = ( dib . biSizeImage ) / biHeight ; int pDestBits = pBits [ 0 ] ; int pSourceBits = bits + ( scanline * ( biHeight - 1 ) ) ; for ( int i = 0 ; i < biHeight ; i ++ ) { OS . MoveMemory ( pDestBits , pSourceBits , scanline ) ; pDestBits += scanline ; pSourceBits -= scanline ; } } Image image = Image . win32_new ( null , BITMAP , memDib ) ; ImageData data = image . getImageData ( ) ; OS . DeleteObject ( memDib ) ; image . dispose ( ) ; return data ; } finally { OS . GlobalUnlock ( hMem ) ; } } finally { OS . GlobalFree ( hMem ) ; } } protected int [ ] getTypeIds ( ) { } protected String [ ] getTypeNames ( ) { } boolean checkImage ( Object object ) { } protected boolean validate ( Object object ) { } }
public static final VariableBinding [ ] EmulationPathToImplicitThis = new VariableBinding [ ] { } ; public static final VariableBinding [ ] NoEnclosingInstanceInConstructorCall = new VariableBinding [ ] { } ; public static final VariableBinding [ ] NoEnclosingInstanceInStaticContext = new VariableBinding [ ] { } ; public BlockScope ( BlockScope parent ) { } public BlockScope ( BlockScope parent , boolean addToParentScope ) { } public BlockScope ( BlockScope parent , int variableCount ) { } protected BlockScope ( int kind , Scope parent ) { } public final void addAnonymousType ( TypeDeclaration anonymousType , ReferenceBinding superBinding ) { } public final void addLocalType ( TypeDeclaration localType ) { } public final void addLocalVariable ( LocalVariableBinding binding ) { } public void addSubscope ( Scope childScope ) { } public final boolean allowBlankFinalFieldAssignment ( FieldBinding binding ) { } String basicToString ( int tab ) { } private void checkAndSetModifiersForVariable ( LocalVariableBinding varBinding ) { } void computeLocalVariablePositions ( int ilocal , int initOffset , CodeStream codeStream ) { } public void emulateOuterAccess ( LocalVariableBinding outerLocalVariable ) { } public final ReferenceBinding findLocalType ( char [ ] name ) { } public LocalDeclaration [ ] findLocalVariableDeclarations ( int position ) { } public LocalVariableBinding findVariable ( char [ ] variableName ) { } public Binding getBinding ( char [ ] [ ] compoundName , int mask , InvocationSite invocationSite , boolean needResolve ) { Binding binding = getBinding ( compoundName [ 0 ] , ( ( mask | ( Binding . TYPE ) ) | ( Binding . PACKAGE ) ) , invocationSite , needResolve ) ; invocationSite . setFieldIndex ( 1 ) ; if ( binding instanceof VariableBinding ) return binding ; CompilationUnitScope unitScope = compilationUnitScope ( ) ; unitScope . recordQualifiedReference ( compoundName ) ; if ( ! ( binding . isValidBinding ( ) ) ) return binding ; int length = compoundName . length ; int currentIndex = 1 ; foundType : if ( binding instanceof PackageBinding ) { PackageBinding packageBinding = ( ( PackageBinding ) ( binding ) ) ; while ( currentIndex < length ) { unitScope . recordReference ( packageBinding . compoundName , compoundName [ currentIndex ] ) ; binding = packageBinding . getTypeOrPackage ( compoundName [ ( currentIndex ++ ) ] ) ; invocationSite . setFieldIndex ( currentIndex ) ; if ( binding == null ) { if ( currentIndex == length ) { return new ProblemReferenceBinding ( CharOperation . subarray ( compoundName , 0 , currentIndex ) , null , ProblemReasons . NotFound ) ; } return new ProblemBinding ( CharOperation . subarray ( compoundName , 0 , currentIndex ) , ProblemReasons . NotFound ) ; } if ( binding instanceof ReferenceBinding ) { if ( ! ( binding . isValidBinding ( ) ) ) return new ProblemReferenceBinding ( CharOperation . subarray ( compoundName , 0 , currentIndex ) , ( ( ReferenceBinding ) ( binding ) ) . closestMatch ( ) , binding . problemId ( ) ) ; if ( ! ( ( ( ReferenceBinding ) ( binding ) ) . canBeSeenBy ( this ) ) ) return new ProblemReferenceBinding ( CharOperation . subarray ( compoundName , 0 , currentIndex ) , ( ( ReferenceBinding ) ( binding ) ) , ProblemReasons . NotVisible ) ; break foundType ; } packageBinding = ( ( PackageBinding ) ( binding ) ) ; } return new ProblemReferenceBinding ( CharOperation . subarray ( compoundName , 0 , currentIndex ) , null , ProblemReasons . NotFound ) ; } ReferenceBinding referenceBinding = ( ( ReferenceBinding ) ( binding ) ) ; <START_BUG> binding = environment ( ) . convertToRawType ( referenceBinding ) ; <END_BUG> if ( invocationSite instanceof ASTNode ) { ASTNode invocationNode = ( ( ASTNode ) ( invocationSite ) ) ; if ( invocationNode . isTypeUseDeprecated ( referenceBinding , this ) ) { problemReporter ( ) . deprecatedType ( referenceBinding , invocationNode ) ; } } while ( currentIndex < length ) { referenceBinding = ( ( ReferenceBinding ) ( binding ) ) ; char [ ] nextName = compoundName [ ( currentIndex ++ ) ] ; invocationSite . setFieldIndex ( currentIndex ) ; invocationSite . setActualReceiverType ( referenceBinding ) ; if ( ( ( mask & ( Binding . FIELD ) ) != 0 ) && ( ( binding = findField ( referenceBinding , nextName , invocationSite , true ) ) != null ) ) { if ( ! ( binding . isValidBinding ( ) ) ) { return new ProblemFieldBinding ( ( ( ProblemFieldBinding ) ( binding ) ) . closestMatch , ( ( ProblemFieldBinding ) ( binding ) ) . declaringClass , CharOperation . concatWith ( CharOperation . subarray ( compoundName , 0 , currentIndex ) , '.' ) , binding . problemId ( ) ) ; } break ; } if ( ( binding = findMemberType ( nextName , referenceBinding ) ) == null ) { if ( ( mask & ( Binding . FIELD ) ) != 0 ) { return new ProblemBinding ( CharOperation . subarray ( compoundName , 0 , currentIndex ) , referenceBinding , ProblemReasons . NotFound ) ; } return new ProblemReferenceBinding ( CharOperation . subarray ( compoundName , 0 , currentIndex ) , referenceBinding , ProblemReasons . NotFound ) ; } if ( ! ( binding . isValidBinding ( ) ) ) return new ProblemReferenceBinding ( CharOperation . subarray ( compoundName , 0 , currentIndex ) , ( ( ReferenceBinding ) ( binding ) ) . closestMatch ( ) , binding . problemId ( ) ) ; if ( invocationSite instanceof ASTNode ) { referenceBinding = ( ( ReferenceBinding ) ( binding ) ) ; ASTNode invocationNode = ( ( ASTNode ) ( invocationSite ) ) ; if ( invocationNode . isTypeUseDeprecated ( referenceBinding , this ) ) { problemReporter ( ) . deprecatedType ( referenceBinding , invocationNode ) ; } } }
public class TestMultiTermConstantScore extends BaseTestRangeFilter { public static final float SCORE_COMP_THRESH = 1.0E-6F ; static Directory small ; static IndexReader reader ; public static void assertEquals ( String m , int e , int a ) { } @ BeforeClass public static void beforeClass ( ) throws Exception { String [ ] data = new String [ ] { "A<seq2seq4repair_space>1<seq2seq4repair_space>2<seq2seq4repair_space>3<seq2seq4repair_space>4<seq2seq4repair_space>5<seq2seq4repair_space>6" , "Z<seq2seq4repair_space>4<seq2seq4repair_space>5<seq2seq4repair_space>6" , null , "B<seq2seq4repair_space>2<seq2seq4repair_space>4<seq2seq4repair_space>5<seq2seq4repair_space>6" , "Y<seq2seq4repair_space>3<seq2seq4repair_space>5<seq2seq4repair_space>6" , null , "C<seq2seq4repair_space>3<seq2seq4repair_space>6" , "X<seq2seq4repair_space>4<seq2seq4repair_space>5<seq2seq4repair_space>6" } ; TestMultiTermConstantScore . small = newDirectory ( ) ; RandomIndexWriter writer = new RandomIndexWriter ( random ( ) , TestMultiTermConstantScore . small , newIndexWriterConfig ( TEST_VERSION_CURRENT , new org . apache . lucene . analysis . MockAnalyzer ( random ( ) , MockTokenizer . WHITESPACE , false ) ) . setMergePolicy ( newLogMergePolicy ( ) ) ) ; FieldType customType = new FieldType ( TextField . TYPE_STORED ) ; customType . setTokenized ( false ) ; for ( int i = 0 ; i < ( data . length ) ; i ++ ) { Document doc = new Document ( ) ; doc . add ( newField ( "id" , String . valueOf ( i ) , customType ) ) ; doc . add ( newField ( "all" , "all" , customType ) ) ; if ( null != ( data [ i ] ) ) { doc . add ( newTextField ( "data" , data [ i ] , YES ) ) ; } writer . addDocument ( doc ) ; } TestMultiTermConstantScore . reader = writer . getReader ( ) ; <START_BUG> writer . close ( ) ; <END_BUG> } @ AfterClass public static void afterClass ( ) throws Exception { } public static Query csrq ( String f , String l , String h , boolean il , boolean ih ) { } public static Query csrq ( String f , String l , String h , boolean il , boolean ih , MultiTermQuery . RewriteMethod method ) { } public static Query cspq ( Term prefix ) { } public static Query cswcq ( Term wild ) { } @ Test public void testBasics ( ) throws IOException { } @ Test public void testEqualScores ( ) throws IOException { } @ Test public void testEqualScoresWhenNoHits ( ) throws IOException { } @ Test public void testBoost ( ) throws IOException { } @ Test public void testBooleanOrderUnAffected ( ) throws IOException { } @ Test public void testRangeQueryId ( ) throws IOException { } @ Test public void testRangeQueryRand ( ) throws IOException { } }
public class ProfList implements Iterable < Professor > { private List < Professor > professors ; public ProfList ( ) { } void add ( Professor professor ) { } public Professor create ( String name , Subject [ ] subjects , TimePeriod [ ] timePeriods ) { } public Professor get ( int index ) throws IndexOutOfBoundsException { } public Professor [ ] toArray ( ) { <START_BUG> return ( ( Professor [ ] ) ( professors . toArray ( ) ) ) ; <END_BUG> } public boolean exist ( Professor professor ) { } public boolean delete ( int index ) { } public int size ( ) { } @ Override public Iterator < Professor > iterator ( ) { } }
public ar , int n , Context context ) throws ArgumentException { } @ Override public UUID readAndValidateFrom ( ArgumentReader ar , Context ctx ) throws ArgumentException { StringBuilder sb = new StringBuilder ( ) ; sb . append ( ArgumentType . TUUID . readHexDigits ( ar , 8 , ctx ) ) ; ar . expect ( '-' , "in<seq2seq4repair_space>UUID" ) ; sb . append ( '-' ) ; sb . append ( ArgumentType . TUUID . readHexDigits ( ar , 4 , ctx ) ) ; ar . expect ( '-' , "in<seq2seq4repair_space>UUID" ) ; sb . append ( '-' ) ; sb . append ( ArgumentType . TUUID . readHexDigits ( ar , 4 , ctx ) ) ; ar . expect ( '-' , "in<seq2seq4repair_space>UUID" ) ; sb . append ( '-' ) ; sb . append ( ArgumentType . TUUID . readHexDigits ( ar , 4 , ctx ) ) ; ar . expect ( '-' , "in<seq2seq4repair_space>UUID" ) ; sb . append ( '-' ) ; sb . append ( ArgumentType . TUUID . readHexDigits ( ar , 12 , ctx ) ) ; return UUID . fromString ( sb . toString ( ) ) ; } @ Override public String name ( ) { } } public static final ArgumentType . TUUID JAVA_UUID = new ArgumentType . TUUID ( ) ; public static final class TCommand implements ArgumentType { @ Override public CommandWithArgs readAndValidateFrom ( ArgumentReader ar , Context context ) throws ArgumentException { ar . deactivateSubcommands ( ) ; String cmdstr = ArgumentType . STRING_IN_SQUARE_BRACKETS . readAndValidateFrom ( ar , context ) ; ar . activateSubcommands ( ) ; return ar . getSubcommandLibrary ( ) . getCommandWithArgs ( cmdstr ) ; } @ Override public String name ( ) { } } public static final ArgumentType . TCommand COMMAND = new ArgumentType . TCommand ( ) ; public static final class TLateCommand implements ArgumentType { @ Override public CommandWithLateArgs readAndValidateFrom ( ArgumentReader ar , Context context ) throws ArgumentException { ar . deactivateSubcommands ( ) ; String cmdstr = ArgumentType . STRING_IN_SQUARE_BRACKETS . readAndValidateFrom ( ar , context ) ; ar . activateSubcommands ( ) ; return ar . getSubcommandLibrary ( ) . getCommandWithLateArgs ( cmdstr ) ; } @ Override public String name ( ) { } } public static final ArgumentType . TLateCommand LATE_COMMAND = new ArgumentType . TLateCommand ( ) ; public static class TOr implements ArgumentType { ArgumentType [ ] types ; public TOr ( ArgumentType ... argumentTypes ) { } @ Override public Object readAndValidateFrom ( ArgumentReader ar , Context context ) throws ArgumentException { int position = ar . position ( ) ; for ( ArgumentType type : types ) { try { Object res = type . readAndValidateFrom ( ar , context ) ; return res ; } catch ( ArgumentException e ) { ar . setPosition ( position ) ; } } ar . syntaxError ( "Invalid<seq2seq4repair_space>argument<seq2seq4repair_space>type" ) ; return null ; } public String name ( ) { } } public static class TDelimitedList implements ArgumentType { char start ; char delimiter ; char end ; boolean skipWhitespace ; ArgumentType elementType ; public TDelimitedList ( char start , char delimiter , char end , ArgumentType elementType , boolean skipWhitespace ) { } public TDelimitedList ( char start , char delimiter , char end , ArgumentType elementType ) { } public TDelimitedList ( char start , char end , ArgumentType elementType ) { } public TDelimitedList ( ArgumentType elementType ) { } @ Override public List < Object > readAndValidateFrom ( ArgumentReader ar , Context context ) throws ArgumentException { if ( skipWhitespace ) ar . skipWhitespace ( ) ; ar . expect ( start , "at<seq2seq4repair_space>beginning<seq2seq4repair_space>of<seq2seq4repair_space>delimited<seq2seq4repair_space>list" ) ; List < Object > res = new ArrayList < Object > ( ) ; do { if ( skipWhitespace ) ar . skipWhitespace ( ) ; res . add ( elementType . readAndValidateFrom ( ar , context ) ) ; if ( ( skipWhitespace ) && ( ( delimiter ) != '<seq2seq4repair_space>' ) ) ar . skipWhitespace ( ) ; } while ( ar . tryExpect ( delimiter ) ) ; ar . expect ( end , "at<seq2seq4repair_space>end<seq2seq4repair_space>of<seq2seq4repair_space>delimited<seq2seq4repair_space>list" ) ; return res ; } public String name ( ) { } } public static class TCommandLikeArgumentsInBrackets implements ArgumentType { List < Argument > args ; ArgumentType stringReader ; public TCommandLikeArgumentsInBrackets ( char open , char close , List < Argument > args ) { } @ Override public Object readAndValidateFrom ( ArgumentReader ar , Context context ) throws ArgumentException { String argstr = ( ( String ) ( stringReader . readAndValidateFrom ( ar , context ) ) ) ; ArgumentReader subar = new ArgumentReader ( argstr , ar . getSubcommandLibrary ( ) ) ; return subar . readArguments ( args , context ) ; } @ Override public String name ( ) { } } public static abstract class TConstructorArgumentType implements ArgumentType { @ Override public Object readAndValidateFrom ( ArgumentReader ar , Context context ) throws ArgumentException { if ( ( ar . peekChar ( ) ) == '<' ) { String substr = ArgumentType . STRING_IN_ANGLE_BRACKETS . readAndValidateFrom ( ar , context ) ; ArgumentReader subar = new ArgumentReader ( substr , ar . getSubcommandLibrary ( ) ) ; return construct ( subar . readArguments ( args ( ) , context ) , context ) ; } else if ( allowNothing ( ) ) { return construct ( null , context ) ; } else { ar . syntaxError ( ( "Expected<seq2seq4repair_space>'<',<seq2seq4repair_space>got<seq2seq4repair_space>" + ( ar . peekChar ( ) ) ) ) ; return null ; } } public boolean allowNothing ( ) { } public abstract List < Argument > args ( ) { } public abstract Object construct ( Map < String , Object > args , Context ctx ) { } } public static abstract class TDispatchArgumentType implements ArgumentType { public Map < String , ArgumentType > subTypes ; public TDispatchArgumentType ( ) { } public Object readDefault ( ArgumentReader ar , Context context ) throws ArgumentException { } @ Override public Object readAndValidateFrom ( ArgumentReader ar , Context context ) throws ArgumentException { int pos = ar . position ( ) ; char c = ar . peekChar ( ) ; if ( subTypes . containsKey ( String . valueOf ( c ) ) ) { ar . readChar ( ) ; return subTypes . get ( String . valueOf ( c ) ) . readAndValidateFrom ( ar , context ) ; } else { <START_BUG> String name = ArgumentType . IDENTIFIER . readAndValidateFrom ( ar , context ) ; <END_BUG>
public class FunctionReference extends SpelNodeImpl { private final String name ; public FunctionReference ( String functionName , int pos , SpelNodeImpl ... arguments ) { } @ Override public TypedValue getValueInternal ( ExpressionState state ) throws EvaluationException { } private TypedValue executeFunctionJLRMethod ( ExpressionState state , Method method ) throws EvaluationException { Object [ ] functionArgs = getArguments ( state ) ; if ( ( ! ( method . isVarArgs ( ) ) ) && ( ( method . getParameterTypes ( ) . length ) != ( functionArgs . length ) ) ) { throw new org . springframework . expression . spel . SpelEvaluationException ( SpelMessage . INCORRECT_NUMBER_OF_ARGUMENTS_TO_FUNCTION , functionArgs . length , method . getParameterTypes ( ) . length ) ; } if ( ! ( Modifier . isStatic ( method . getModifiers ( ) ) ) ) { throw new org . springframework . expression . spel . SpelEvaluationException ( getStartPosition ( ) , SpelMessage . FUNCTION_MUST_BE_STATIC , ( ( ( method . getDeclaringClass ( ) . getName ( ) ) + "." ) + ( method . getName ( ) ) ) , name ) ; } if ( functionArgs != null ) { TypeConverter converter = state . getEvaluationContext ( ) . getTypeConverter ( ) ; ReflectionHelper . convertAllArguments ( converter , functionArgs , method ) ; } if ( method . isVarArgs ( ) ) { functionArgs = ReflectionHelper . setupArgumentsForVarargsInvocation ( method . getParameterTypes ( ) , functionArgs ) ; } try { ReflectionUtils . makeAccessible ( method ) ; Object result = method . invoke ( method . getClass ( ) , functionArgs ) ; <START_BUG> return new TypedValue ( result , new org . springframework . core . convert . TypeDescriptor ( new MethodParameter ( method , ( - 1 ) ) ) ) ; <END_BUG> } catch ( Exception ex ) { throw new org . springframework . expression . spel . SpelEvaluationException ( getStartPosition ( ) , ex , SpelMessage . EXCEPTION_DURING_FUNCTION_CALL , this . name , ex . getMessage ( ) ) ; } } @ Override public String toStringAST ( ) { } private Object [ ] getArguments ( ExpressionState state ) throws EvaluationException { } }
public class HiddenQuickActionSetup extends HiddenViewSetup { private HiddenQuickActionSetup . UnpressableLinearLayout mLinearLayout ; private int mImageWidth = LayoutParams . WRAP_CONTENT ; private int mImageHeight = LayoutParams . WRAP_CONTENT ; private HiddenQuickActionSetup . OnQuickActionListener mQuickActionListener ; private OnTouchListener mTouchListener ; private PopupWindow mIndicatorPopup ; private int mIndicatorDelay = 300 ; private ImageView mIndicatorImage ; private TextView mIndicatorTitle ; private Handler mPopupDelayHandler = new Handler ( ) ; private Runnable mIndicatorStart ; private View mClickedActionView ; private Rect mIndicatorSpacing ; private boolean mCloseSwipeableOnQuickAction = true ; public static interface OnQuickActionListener { public void onQuickAction ( AdapterView < ? > parent , View view , int position , int quickActionId ) { } } public HiddenQuickActionSetup ( Context context ) { } public void setBackgroundDrawable ( Drawable d ) { } public void setBackgroundResource ( int resId ) { } public void setBackgroundColor ( int color ) { } public void setViewPadding ( int left , int top , int right , int bottom ) { } public void setImageSize ( int width , int height ) { } public void setCloseSwipableOnQuickActionClick ( boolean close ) { } public void setIndicatorDelay ( int delay ) { } public void setIndicatorLayout ( int resId ) { } public void setIndicatorLayout ( View content ) { } public void setIndicatorImageSize ( int width , int height ) { } public void setIndicatorSpacing ( int left , int top , int right , int bottom ) { } public boolean addAction ( int actionId , int actionDescriptionResId , int drawableResId ) { } public boolean addAction ( int actionId , int actionDescriptionResId , Drawable drawable ) { } public boolean addAction ( int actionId , String actionDescription , int drawableResId ) { } public boolean addAction ( int actionId , String actionDescription , Drawable drawable ) { } public boolean removeAction ( int actionId ) { } public void setOnQuickActionListener ( HiddenQuickActionSetup . OnQuickActionListener l ) { } @ Override public View getHiddenView ( ) { } private void setupDefaultIndicator ( ) { } private void setupQuickActionTouchListener ( ) { mTouchListener = new OnTouchListener ( ) { @ Override public boolean onTouch ( View v , MotionEvent event ) { int a = event . getAction ( ) ; if ( a == ( MotionEvent . ACTION_DOWN ) ) { <START_BUG> if ( ! ( isHiddenViewInteractionPossible ( ) ) ) { <END_BUG> return false ; } Drawable drawable = ( ( ImageView ) ( ( ( android . view . ViewGroup ) ( v ) ) . getChildAt ( 0 ) ) ) . getDrawable ( ) ; if ( drawable instanceof StateListDrawable ) { drawable = ( ( StateListDrawable ) ( drawable ) ) . getCurrent ( ) ; } mIndicatorImage . setImageDrawable ( drawable ) ; mClickedActionView = v ; if ( ( mIndicatorDelay ) == 0 ) { mIndicatorStart . run ( ) ; } else if ( ( mIndicatorDelay ) > 0 ) { mPopupDelayHandler . postDelayed ( mIndicatorStart , mIndicatorDelay ) ; } v . setPressed ( true ) ; v . invalidate ( ) ; } else if ( ( a == ( MotionEvent . ACTION_UP ) ) || ( a == ( MotionEvent . ACTION_CANCEL ) ) ) { if ( ( a == ( MotionEvent . ACTION_UP ) ) && ( ( mQuickActionListener ) != null ) ) { if ( mCloseSwipeableOnQuickAction ) { closeHiddenView ( ) ; } mQuickActionListener . onQuickAction ( getCurrentListView ( ) , getCurrentSwipeableHiddenView ( ) , getCurrentPosition ( ) , ( ( HiddenQuickActionSetup . ActionInfo ) ( v . getTag ( ) ) ) . id ) ; } mPopupDelayHandler . removeCallbacks ( mIndicatorStart ) ; mIndicatorPopup . dismiss ( ) ; v . setPressed ( false ) ; v . invalidate ( ) ; } return true ; } } ; } private void setupShowPopupStart ( ) { } private class UnpressableLinearLayout extends LinearLayout { public UnpressableLinearLayout ( Context context ) { } @ Override public void dispatchSetPressed ( boolean pressed ) { } } private class ActionInfo { int id ; String description ; } }
private static final int numberOfPlayersInLineUp = 11 ; private static final int maximumNumberOfSubstitutions = 3 ; private int [ ] boundsLSP = new int [ ] { 5 , 5 , 5 , 1 , 130 , 20 } ; private int playersPerColumn = 15 ; private Spieltag spieltag ; private Ergebnis ergebnis ; private ArrayList < Spieler > kaderHome ; private ArrayList < Spieler > kaderAway ; private ArrayList < Spieler > eligiblePlayersListUpper = new ArrayList < > ( ) ; private ArrayList < Spieler > eligiblePlayersListLower = new ArrayList < > ( ) ; private boolean [ ] playerSelected ; private boolean editingFirstTeam ; private boolean enteringLineup ; private boolean enteringGoal ; private boolean enteringSubstitution ; private boolean enteringBooking ; private int goalDetails ; private int [ ] lineupHome ; private int [ ] lineupAway ; private ArrayList < Wechsel > substitutionsHome ; private ArrayList < Wechsel > substitutionsAway ; private ArrayList < Tor > goals ; private ArrayList < Karte > bookings ; private int changedElement = - 1 ; private boolean repaint ; private ArrayList < Integer > penaltiesHome ; private ArrayList < Integer > penaltiesAway ; private int latestPenalty ; private boolean isETpossible = false ; private JButton go ; private Rectangle RECGO = new Rectangle ( 700 , 10 , 90 , 40 ) ; public SpielInformationen ( Spieltag spieltag , int matchIndex , Spiel spiel , Ergebnis ergebnis ) { } public void initGUI ( ) { } private void displayGivenValues ( ) { } private void createPseudoGoals ( ) { } private void paintGoals ( ) { } private void paintSubstitutions ( boolean firstTeam ) { } private void paintBookings ( ) { } private void displayGoal ( Tor tor ) { } private void displaySubstitution ( Wechsel wechsel , final int index ) { } private void displayBooking ( Karte booking ) { int squadNumber = booking . getBookedPlayer ( ) . getSquadNumber ( ) ; boolean found = false ; boolean yellow = booking . isYellowCard ( ) ; boolean second = booking . isSecondBooking ( ) ; JLabel label = null ; if ( booking . isFirstTeam ( ) ) { for ( int i = 0 ; ( i < ( lineupHome . length ) ) && ( ! found ) ; i ++ ) { if ( ( lineupHome [ i ] ) == squadNumber ) { label = ( second ? jLblsSecBookingsHome : jLblsBookingsHome ) [ i ] ; found = true ; } } if ( ! found ) { int index = 0 ; for ( Wechsel wechsel : substitutionsHome ) { if ( ( wechsel . getEingewechselterSpieler ( ) . getSquadNumber ( ) ) == squadNumber ) { label = ( second ? jLblsSecBookingsHome : jLblsBookingsHome ) [ ( ( SpielInformationen . numberOfPlayersInLineUp ) + index ) ] ; break ; } index ++ ; } } if ( second && ( ! yellow ) ) { Point loc = label . getLocation ( ) ; label . setLocation ( ( ( loc . x ) + ( bDeltaX ) ) , ( ( loc . y ) + ( bDeltaY ) ) ) ; } } else { for ( int i = 0 ; ( i < ( lineupAway . length ) ) && ( ! found ) ; i ++ ) { if ( ( lineupAway [ i ] ) == squadNumber ) { label = ( second ? jLblsSecBookingsAway : jLblsBookingsAway ) [ i ] ; found = true ; } } if ( ! found ) { int index = 0 ; for ( Wechsel wechsel : substitutionsAway ) { if ( ( wechsel . getEingewechselterSpieler ( ) . getSquadNumber ( ) ) == squadNumber ) { label = ( second ? jLblsSecBookingsAway : jLblsBookingsAway ) [ ( ( SpielInformationen . numberOfPlayersInLineUp ) + index ) ] ; break ; } index ++ ; } } if ( second && ( ! yellow ) ) { Point loc = label . getLocation ( ) ; label . setLocation ( ( ( loc . x ) - ( bDeltaX ) ) , ( ( loc . y ) + ( bDeltaY ) ) ) ; } } <START_BUG> if ( second ) <END_BUG> label . setBackground ( colorRedCard ) ; else label . setBackground ( colorYellowCard ) ; alignCenter ( label ) ; label . setOpaque ( true ) ; } private void changeGoal ( int index ) { } private void changeSubstitution ( boolean firstTeam , int index ) { } private void changeBooking ( ) { } private void setAmGruenenTisch ( boolean isHomeTeam ) { } private void setErgebnis ( ) { } private void startPenaltyShootout ( ) { } private void showPenalties ( boolean show ) { } private void addPLabels ( int nOfLabels ) { } private void removePLabels ( int firstIndexToRemove ) { } private void changePenalty ( boolean firstTeam , int index ) { } private void finishPenaltyShootout ( ) { } private void startGame ( ) { } private void setLabelsVisible ( boolean value ) { } private void jBtnEingabeCancelledActionPerformed ( ) { } private void enterNewSubstitution ( boolean firstTeam ) { } private String [ ] getEligiblePlayersSub ( boolean subOff ) { } private void jBtnWechseleingabeCompletedActionPerformed ( ) { } private void enterNewGoal ( boolean firstTeam ) { } private void jChBLeftSelectionChanged ( ) { } private void jChBRightSelectionChanged ( ) { } private String [ ] getEligiblePlayers ( boolean upper ) { } private void jBtnToreingabeCompletedActionPerformed ( ) { } private void enterNewBooking ( boolean firstTeam ) { } private void jBtnKarteneingabeCompletedActionPerformed ( ) { } private void enterNewLineup ( boolean firstTeam ) { } private void jBtnLineupSelectionCancelActionPerformed ( ) { } private void playerSelected ( int index ) { } private void jBtnLineupSelectionCompletedActionPerformed ( ) { } private void validateMatchDataOnLineupChange ( ) { } public void goActionPerformed ( ) { } }
public class ClientUpdateComponent extends Component { public ClientUpdateComponent ( final DynmapCore plugin , ConfigurationNode configuration ) { } protected void buildClientUpdate ( ClientUpdateEvent e ) { DynmapWorld world = e . world ; JSONObject u = e . update ; long since = e . timestamp ; String worldName = world . getName ( ) ; int hideifshadow = configuration . getInteger ( "hideifshadow" , 15 ) ; int hideifunder = configuration . getInteger ( "hideifundercover" , 15 ) ; boolean hideifsneaking = configuration . getBoolean ( "hideifsneaking" , false ) ; JSONUtils . s ( u , "confighash" , core . getConfigHashcode ( ) ) ; JSONUtils . s ( u , "servertime" , ( ( world . getTime ( ) ) % 24000 ) ) ; JSONUtils . s ( u , "hasStorm" , world . hasStorm ( ) ) ; JSONUtils . s ( u , "isThundering" , world . isThundering ( ) ) ; JSONUtils . s ( u , "players" , new JSONArray ( ) ) ; List < DynmapPlayer > players = playerList . getVisiblePlayers ( ) ; for ( DynmapPlayer p : players ) { boolean hide = false ; DynmapLocation pl = p . getLocation ( ) ; DynmapWorld pw = core . getWorld ( pl . world ) ; <START_BUG> if ( pw != null ) <END_BUG> hide = true ; JSONObject jp = new JSONObject ( ) ; JSONUtils . s ( jp , "type" , "player" ) ; JSONUtils . s ( jp , "name" , Client . stripColor ( p . getDisplayName ( ) ) ) ; JSONUtils . s ( jp , "account" , p . getName ( ) ) ; if ( ( ! hide ) && ( hideifshadow < 15 ) ) { if ( ( pw . getLightLevel ( ( ( int ) ( pl . x ) ) , ( ( int ) ( pl . y ) ) , ( ( int ) ( pl . z ) ) ) ) <= hideifshadow ) hide = true ; } if ( ( ! hide ) && ( hideifunder < 15 ) ) { if ( pw . canGetSkyLightLevel ( ) ) { if ( ( pw . getSkyLightLevel ( ( ( int ) ( pl . x ) ) , ( ( int ) ( pl . y ) ) , ( ( int ) ( pl . z ) ) ) ) <= hideifunder ) hide = true ; } else { if ( ( pw . getHighestBlockYAt ( ( ( int ) ( pl . x ) ) , ( ( int ) ( pl . z ) ) ) ) > ( pl . y ) ) hide = true ; } } if ( ( ( ! hide ) && hideifsneaking ) && ( p . isSneaking ( ) ) ) hide = true ; DynmapWorld pworld = worldsLookup . get ( pl . world ) ; if ( ( ( ( ( configuration . getBoolean ( "sendposition" , true ) ) && ( configuration . getBoolean ( "sendpositon" , true ) ) ) && ( pworld != null ) ) && ( pworld . sendposition ) ) && ( ! hide ) ) { JSONUtils . s ( jp , "world" , pl . world ) ; JSONUtils . s ( jp , "x" , pl . x ) ; JSONUtils . s ( jp , "y" , pl . y ) ; JSONUtils . s ( jp , "z" , pl . z ) ; } else { JSONUtils . s ( jp , "world" , "-some-other-bogus-world-" ) ; JSONUtils . s ( jp , "x" , 0.0 ) ; JSONUtils . s ( jp , "y" , 64.0 ) ; JSONUtils . s ( jp , "z" , 0.0 ) ; } if ( ( ( ( configuration . getBoolean ( "sendhealth" , false ) ) && ( pworld != null ) ) && ( pworld . sendhealth ) ) && ( ! hide ) ) { JSONUtils . s ( jp , "health" , p . getHealth ( ) ) ; JSONUtils . s ( jp , "armor" , p . getArmorPoints ( ) ) ; } else { JSONUtils . s ( jp , "health" , 0 ) ; JSONUtils . s ( jp , "armor" , 0 ) ; } JSONUtils . a ( u , "players" , jp ) ; } if ( configuration . getBoolean ( "includehiddenplayers" , false ) ) { List < DynmapPlayer > hidden = playerList . getHiddenPlayers ( ) ; for ( DynmapPlayer p : hidden ) { JSONObject jp = new JSONObject ( ) ; JSONUtils . s ( jp , "type" , "player" ) ; JSONUtils . s ( jp , "name" , Client . stripColor ( p . getDisplayName ( ) ) ) ; JSONUtils . s ( jp , "account" , p . getName ( ) ) ; JSONUtils . s ( jp , "world" , "-hidden-player-" ) ; JSONUtils . s ( jp , "x" , 0.0 ) ; JSONUtils . s ( jp , "y" , 64.0 ) ; JSONUtils . s ( jp , "z" , 0.0 ) ; JSONUtils . s ( jp , "health" , 0 ) ; JSONUtils . s ( jp , "armor" , 0 ) ; JSONUtils . a ( u , "players" , jp ) ; } } JSONUtils . s ( u , "updates" , new JSONArray ( ) ) ; for ( Object update : mapManager . getWorldUpdates ( worldName , since ) ) { JSONUtils . a ( u , "updates" , ( ( Client . Update ) ( update ) ) ) ; } } }
public class ReturnStatement extends Statement { public Expression expression ; public TypeBinding expressionType ; public boolean isSynchronized ; public AstNode [ ] subroutines ; public LocalVariableBinding saveValueVariable ; public ReturnStatement ( Expression expr , int s , int e ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { } public void generateReturnBytecode ( BlockScope currentScope , CodeStream codeStream ) { } public void generateStoreSaveValueIfNecessary ( BlockScope currentScope , CodeStream codeStream ) { } public boolean needValue ( ) { } public void prepareSaveValueLocation ( TryStatement targetTryStatement ) { } public void resolve ( BlockScope scope ) { MethodScope methodScope = scope . methodScope ( ) ; MethodBinding methodBinding ; TypeBinding methodType = ( ( methodScope . referenceContext ) instanceof AbstractMethodDeclaration ) ? ( methodBinding = ( ( AbstractMethodDeclaration ) ( methodScope . referenceContext ) ) . binding ) == null ? null : methodBinding . returnType : VoidBinding ; if ( methodType == ( VoidBinding ) ) { if ( ( expression ) == null ) return ; if ( ( expressionType = expression . resolveType ( scope ) ) != null ) scope . problemReporter ( ) . attemptToReturnNonVoidExpression ( this , expressionType ) ; return ; } if ( ( expression ) == null ) { if ( methodType != null ) scope . problemReporter ( ) . shouldReturn ( methodType , this ) ; return ; } if ( ( expressionType = expression . resolveType ( scope ) ) == null ) return ; if ( ( methodType != null ) && ( expression . isConstantValueOfTypeAssignableToType ( expressionType , methodType ) ) ) { expression . implicitWidening ( methodType , expressionType ) ; return ; } if ( ( expressionType ) == ( VoidBinding ) ) { scope . problemReporter ( ) . attemptToReturnVoidValue ( this ) ; return ; } <START_BUG> if ( ( methodType != null ) && ( org . eclipse . jdt . internal . compiler . lookup . Scope . areTypesCompatible ( expressionType , methodType ) ) ) { <END_BUG> expression . implicitWidening ( methodType , expressionType ) ; return ; } if ( methodType != null ) { scope . problemReporter ( ) . typeMismatchErrorActualTypeExpectedType ( expression , expressionType , methodType ) ; } } public String toString ( int tab ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope scope ) { } }
public class PasswordCreatedialog { private static final String DUMMYTEXT = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" ; private Window mainwindow ; private Window thiswindow ; public PasswordCreatedialog ( ) { } public PasswordCreatedialog ( Window mainwindow ) { } public PasswordCreatedialog ( Object page ) { } public void main ( final SimpleCallback < char [ ] > sr ) { if ( ( mainwindow ) == null ) { JFrame jf = new JFrame ( ) ; jf . setTitle ( PasswordEncrypt_title . val ( ) ) ; jf . setResizable ( false ) ; jf . setIconImages ( icons ) ; jf . getContentPane ( ) . setLayout ( new BoxLayout ( jf . getContentPane ( ) , BoxLayout . Y_AXIS ) ) ; jf . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; thiswindow = jf ; } else { JDialog jd = new JDialog ( mainwindow ) ; jd . setModal ( true ) ; jd . setTitle ( PasswordEncrypt_title . val ( ) ) ; jd . setResizable ( false ) ; jd . setIconImages ( icons ) ; jd . getContentPane ( ) . setLayout ( new BoxLayout ( jd . getContentPane ( ) , BoxLayout . Y_AXIS ) ) ; jd . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; thiswindow = jd ; } JPanel line1 = new JPanel ( new FlowLayout ( FlowLayout . RIGHT ) ) ; JPanel line2 = new JPanel ( new FlowLayout ( FlowLayout . RIGHT ) ) ; JPanel lineok = new JPanel ( new GridBagLayout ( ) ) ; final JPasswordField tf = new JPasswordField ( ) ; tf . setPreferredSize ( new Dimension ( 200 , 25 ) ) ; final JPasswordField tf2 = new JPasswordField ( ) ; tf2 . setPreferredSize ( new Dimension ( 200 , 25 ) ) ; JButton b = new JButton ( "OK" ) ; ActionListener act = new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { char [ ] s1 = tf . getPassword ( ) ; char [ ] s2 = tf2 . getPassword ( ) ; if ( ( ( ( s1 == null ) || ( s2 == null ) ) || ( ( s1 . length ) == 0 ) ) || ( ( s2 . length ) == 0 ) ) return ; int minlen = CryptoCodes . STANDARD_PBKDF2_PWLEN ; tf . setText ( PasswordCreatedialog . DUMMYTEXT ) ; tf2 . setText ( PasswordCreatedialog . DUMMYTEXT ) ; tf . setText ( "" ) ; tf2 . setText ( "" ) ; if ( ( Arrays . equals ( s1 , s2 ) ) && ( ( s1 . length ) >= minlen ) ) { thiswindow . dispose ( ) ; CryptoUtils . kill ( s2 ) ; sr . callbackValue ( PasswordCreatedialog . this , s1 ) ; } else { CryptoUtils . kill ( s1 ) ; CryptoUtils . kill ( s2 ) ; tf . requestFocus ( ) ; if ( ( s1 . length ) < minlen ) JOptionPane . showMessageDialog ( thiswindow , PasswordEncrypt_len . msg ( minlen ) ) ; else JOptionPane . showMessageDialog ( thiswindow , PasswordEncrypt_nomatch ) ; } } } ; b . addActionListener ( act ) ; tf . addActionListener ( act ) ; tf2 . addActionListener ( act ) ; JLabel jl = new JLabel ( ( ( _T . PasswordEncrypt_label ) + ":<seq2seq4repair_space>" ) ) ; line1 . add ( jl ) ; line1 . add ( tf ) ; thiswindow . add ( line1 ) ; jl = new JLabel ( ( ( _T . PasswordEncrypt_retype ) + ":<seq2seq4repair_space>" ) ) ; line2 . add ( jl ) ; line2 . add ( tf2 ) ; thiswindow . add ( line2 ) ; b . setPreferredSize ( new Dimension ( 200 , 35 ) ) ; GridBagConstraints gbc = new GridBagConstraints ( ) ; gbc . insets = new Insets ( 5 , 5 , 5 , 5 ) ; gbc . fill = GridBagConstraints . BOTH ; gbc . weightx = gbc . weighty = 1.0 ; lineok . add ( b , gbc ) ; thiswindow . add ( lineok ) ; thiswindow . pack ( ) ; <START_BUG> thiswindow . setLocationRelativeTo ( null ) ; <END_BUG> thiswindow . setVisible ( true ) ; thiswindow . addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosed ( WindowEvent e ) { try { tf . setText ( PasswordCreatedialog . DUMMYTEXT ) ; tf2 . setText ( PasswordCreatedialog . DUMMYTEXT ) ; tf . setText ( "" ) ; tf2 . setText ( "" ) ; } catch ( Exception ex ) { } } } ) ; if ( Toolkit . getDefaultToolkit ( ) . getLockingKeyState ( KeyEvent . VK_CAPS_LOCK ) ) { JOptionPane . showMessageDialog ( thiswindow , Password_caps ) ; } } }
public class TopologyManager { private static Logger log = LoggerFactory . getLogger ( TopologyManager . class ) ; private static Random random = new Random ( ) ; public static List < WeightedLink > getDeterministicShortestPath ( Graph < Node , WeightedLink > topo , Configs configs , Node src , Node dst , int k , TrafficFlow flow ) { } public static List < WeightedLink > getRandomShortestPath ( Graph < Node , WeightedLink > topo , Configs configs , Node src , Node dst , int k ) { } public static List < WeightedLink > getShortestPath ( Graph < Node , WeightedLink > topo , Configs configs , Node src , Node dst ) { } public static List < List < WeightedLink > > getKShortestPaths ( Graph < Node , WeightedLink > topo , Configs configs , Node src , Node dst , int k ) { } public static Yen < Node , WeightedLink > buildShortestPathAlgo ( Graph < Node , WeightedLink > topology ) { } public static Graph < Node , WeightedLink > buildTopology ( Configs configs ) { } public static List < Switch > getSwitchesOnPath ( Graph < Node , WeightedLink > topology , List < WeightedLink > path ) { } public static List < Node > getNodesOnPath ( Graph < Node , WeightedLink > topology , List < WeightedLink > path ) { } public static boolean isSwitchOnPath ( Graph < Node , WeightedLink > topology , List < WeightedLink > path , Switch monitoringSwitch ) { } public static List < Switch > getMonitoringSwitches ( Graph < Node , WeightedLink > topology ) { } public static List < Host > getHosts ( Graph < Node , WeightedLink > topology , boolean includeMonitoringHosts ) { } public static List < MonitoringHost > getMonitoringHosts ( Graph < Node , WeightedLink > topology ) { } private static int flowHashCode ( TrafficFlow flow ) { } public static Switch getClosestMonitoringSwitch ( Graph < Node , WeightedLink > topology , TrafficFlow flow ) { List < Switch > onPathSwitches = flow . getOnPathMonitoringSwitches ( ) ; Switch candidateSw = null ; <START_BUG> if ( ( onPathSwitches != null ) && ( ( onPathSwitches . size ( ) ) > 1 ) ) { <END_BUG> candidateSw = onPathSwitches . get ( 0 ) ; } return candidateSw ; } public static MonitoringHost getClosestMonitoringHost ( Graph < Node , WeightedLink > topology , TrafficFlow flow ) { } }
public class WeldEjbServices implements EjbServices { private final ServiceRegistry serviceRegistry ; private volatile Map < String , InterceptorBindings > bindings = Collections . emptyMap ( ) ; public WeldEjbServices ( ServiceRegistry serviceRegistry ) { } @ Override public synchronized void registerInterceptors ( EjbDescriptor < ? > ejbDescriptor , InterceptorBindings interceptorBindings ) { } @ Override public SessionObjectReference resolveEjb ( EjbDescriptor < ? > ejbDescriptor ) { if ( ejbDescriptor . isStateful ( ) ) { return new StatefulSessionObjectReferenceImpl ( ( ( EjbDescriptorImpl < ? > ) ( ejbDescriptor ) ) ) ; } else { <START_BUG> return new org . jboss . as . weld . ejb . SessionObjectReferenceImpl ( ( ( EjbDescriptorImpl < ? > ) ( ejbDescriptor ) ) , serviceRegistry ) ; <END_BUG> } } @ Override public void cleanup ( ) { } public InterceptorBindings getBindings ( String ejbName ) { } }
public class JMXSubsystemTestCase extends AbstractSubsystemTest { private static final String LAUNCH_TYPE = "launch-type" ; private static final String TYPE_STANDALONE = "STANDALONE" ; public JMXSubsystemTestCase ( ) { } @ Test public void testParseEmptySubsystem ( ) throws Exception { } @ Test public void testParseSubsystemWithBadChild ( ) throws Exception { } @ Test public void testParseSubsystemWithBadAttribute ( ) throws Exception { } @ Test public void testParseSubsystemWithConnector ( ) throws Exception { } @ Test public void testParseSubsystemWithTwoConnectors ( ) throws Exception { } @ Test public void testParseSubsystemWithBadConnectorAttribute ( ) throws Exception { } @ Test public void testInstallIntoController ( ) throws Exception { } @ Test public void testParseAndMarshalModel1_0 ( ) throws Exception { } @ Test public void testParseAndMarshalModel1_1WithShowModel ( ) throws Exception { } @ Test public void testParseAndMarshalModelWithRemoteConnectorRef1_1 ( ) throws Exception { } @ Test public void testParseAndMarshalModel1_1 ( ) throws Exception { } @ Test public void testParseAndMarshalModel1_2WithShowModels ( ) throws Exception { } @ Test public void testParseAndMarshalModel1_2WithShowModelsAndOldPropertyFormat ( ) throws Exception { } @ Test public void testDescribeHandler ( ) throws Exception { } @ Test public void testShowModelAlias ( ) throws Exception { } @ Test public void testTransformationAS712 ( ) throws Exception { } @ Test public void testTransformationAS713 ( ) throws Exception { } private void testTransformation_1_0_0 ( ModelTestControllerVersion controllerVersion ) throws Exception { } @ Test public void testRejectExpressionsAS712 ( ) throws Exception { } @ Test public void testRejectExpressionsAS713 ( ) throws Exception { } private void testRejectExpressions_1_0_0 ( ModelTestControllerVersion controllerVersion ) throws Exception { } private List < FailedOperationTransformationConfig . AttributesPathAddressConfig < ? > > createChainedConfigList ( FailedOperationTransformationConfig < ? > ... cfgs ) { } private void check_1_0_0_Model ( ModelNode legacySubsystem , boolean remotingConnector , boolean showModel ) { } private void assertJmxConnectorAddress ( ModelNode address ) { } private void assertJmxSubsystemAddress ( ModelNode address ) { } private static ModelNode createOperation ( String name , String ... addressElements ) { } private static class BaseAdditionalInitalization extends AdditionalInitialization { @ Override protected void initializeExtraSubystemsAndModel ( ExtensionRegistry extensionRegistry , Resource rootResource , ManagementResourceRegistration rootRegistration ) { } @ Override protected void setupController ( ControllerInitializer controllerInitializer ) { } @ Override protected void addExtraServices ( final ServiceTarget target ) { <START_BUG> ManagementRemotingServices . installRemotingEndpoint ( target , MANAGEMENT_ENDPOINT , "loaclhost" , MANAGEMENT , null , null ) ; <END_BUG> ServiceName tmpDirPath = JBOSS . append ( "server" , "path" , "jboss.controller.temp.dir" ) ; RemotingServices . installSecurityServices ( target , "remote" , null , null , tmpDirPath , null , null ) ; RemotingServices . installConnectorServicesForSocketBinding ( target , MANAGEMENT_ENDPOINT , "remote" , JBOSS_BINDING_NAME . append ( "remote" ) , EMPTY , null , null ) ; } } private static class CorrectDomainNameConfig extends FailedOperationTransformationConfig . AttributesPathAddressConfig < JMXSubsystemTestCase . CorrectDomainNameConfig > { public CorrectDomainNameConfig ( AttributeDefinition ... attributes ) { } @ Override protected boolean isAttributeWritable ( String attributeName ) { } @ Override protected boolean checkValue ( String attrName , ModelNode attribute , boolean isWriteAttribute ) { } @ Override protected ModelNode correctValue ( ModelNode toResolve , boolean isWriteAttribute ) { } } private static class CorrectPropertyFormatConfig extends FailedOperationTransformationConfig . AttributesPathAddressConfig < JMXSubsystemTestCase . CorrectDomainNameConfig > { public CorrectPropertyFormatConfig ( AttributeDefinition ... attributes ) { } @ Override protected boolean isAttributeWritable ( String attributeName ) { } @ Override protected boolean checkValue ( String attrName , ModelNode attribute , boolean isWriteAttribute ) { } @ Override protected ModelNode correctValue ( ModelNode toResolve , boolean isWriteAttribute ) { } } }
public class Pdf417MobiDemo extends Activity { private static final int MY_REQUEST_CODE = 1337 ; private static final String TAG = "Pdf417MobiDemo" ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { } @ SuppressWarnings ( "deprecation" ) private void showVersionString ( ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } public void btnScan_click ( View v ) { } public void btnInfo_click ( View v ) { } private boolean checkIfDataIsUrlAndCreateIntent ( String data ) { } @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { if ( ( requestCode == ( Pdf417MobiDemo . MY_REQUEST_CODE ) ) && ( resultCode == ( Pdf417ScanActivity . RESULT_OK ) ) ) { Parcelable [ ] resultArray = data . getParcelableArrayExtra ( EXTRAS_RECOGNITION_RESULT_LIST ) ; StringBuilder sb = new StringBuilder ( ) ; for ( Parcelable p : resultArray ) { if ( p instanceof Pdf417ScanResult ) { Pdf417ScanResult result = ( ( Pdf417ScanResult ) ( p ) ) ; String barcodeData = result . getStringData ( ) ; boolean uncertainData = result . isUncertain ( ) ; BarcodeDetailedData rawData = result . getRawData ( ) ; byte [ ] rawDataBuffer = rawData . getAllData ( ) ; if ( checkIfDataIsUrlAndCreateIntent ( barcodeData ) ) { return ; } else { sb . append ( "PDF417<seq2seq4repair_space>scan<seq2seq4repair_space>data" ) ; if ( uncertainData ) { sb . append ( "This<seq2seq4repair_space>scan<seq2seq4repair_space>data<seq2seq4repair_space>is<seq2seq4repair_space>uncertain!\n\n" ) ; } sb . append ( "<seq2seq4repair_space>string<seq2seq4repair_space>data:\n" ) ; sb . append ( barcodeData ) ; if ( rawData != null ) { sb . append ( "\n\n" ) ; sb . append ( "PDF417<seq2seq4repair_space>raw<seq2seq4repair_space>data:\n" ) ; sb . append ( rawData . toString ( ) ) ; sb . append ( "\n" ) ; sb . append ( "PDF417<seq2seq4repair_space>raw<seq2seq4repair_space>data<seq2seq4repair_space>merged:\n" ) ; sb . append ( "{" ) ; for ( int i = 0 ; i < ( rawDataBuffer . length ) ; ++ i ) { sb . append ( ( ( ( int ) ( rawDataBuffer [ i ] ) ) & 255 ) ) ; if ( i != ( ( rawDataBuffer . length ) - 1 ) ) { sb . append ( ",<seq2seq4repair_space>" ) ; } } sb . append ( "}\n\n\n" ) ; } } } else if ( p instanceof BarDecoderScanResult ) { BarDecoderScanResult result = ( ( BarDecoderScanResult ) ( p ) ) ; BarcodeType type = result . getBarcodeType ( ) ; String barcodeData = result . getStringData ( ) ; if ( checkIfDataIsUrlAndCreateIntent ( barcodeData ) ) { return ; } else { sb . append ( type . name ( ) ) ; sb . append ( "<seq2seq4repair_space>string<seq2seq4repair_space>data:\n" ) ; sb . append ( barcodeData ) ; sb . append ( "\n\n\n" ) ; } } else <START_BUG> if ( p instanceof ZXingRecognizerSettings ) { <END_BUG> ZXingScanResult result = ( ( ZXingScanResult ) ( p ) ) ; BarcodeType type = result . getBarcodeType ( ) ; String barcodeData = result . getStringData ( ) ; if ( checkIfDataIsUrlAndCreateIntent ( barcodeData ) ) { return ; } else { sb . append ( type . name ( ) ) ; sb . append ( "<seq2seq4repair_space>string<seq2seq4repair_space>data:\n" ) ; sb . append ( barcodeData ) ; sb . append ( "\n\n\n" ) ; } } else if ( p instanceof USDLScanResult ) { USDLScanResult result = ( ( USDLScanResult ) ( p ) ) ; String name = result . getField ( kCustomerFullName ) ; Log . i ( Pdf417MobiDemo . TAG , ( "Customer<seq2seq4repair_space>full<seq2seq4repair_space>name<seq2seq4repair_space>is<seq2seq4repair_space>" + name ) ) ; sb . append ( result . getTitle ( ) ) ; sb . append ( "\n\n" ) ; sb . append ( result . toString ( ) ) ; } } Intent intent = new Intent ( Intent . ACTION_SEND ) ; intent . setType ( "text/plain" ) ; intent . putExtra ( EXTRA_TEXT , sb . toString ( ) ) ; startActivity ( Intent . createChooser ( intent , getString ( UseWith ) ) ) ; } } }
public class WeatherChildViewHolder extends ChildViewHolder { private LineChart lineChart ; public RelativeLayout backgroundLayout ; public WeatherChildViewHolder ( View itemView ) { } public void setLineChart ( WeatherChildGraph weatherChildGraph ) { lineChart . setDescription ( "" ) ; List < TimeData > timeDatasMax = weatherChildGraph . getPropMax ( ) ; List < TimeData > timeDatasMin = weatherChildGraph . getPropMin ( ) ; ArrayList < Entry > entriesMax = new ArrayList < > ( ) ; ArrayList < Entry > entriesMin = new ArrayList < > ( ) ; for ( int i = 0 ; i < ( timeDatasMax . size ( ) ) ; i ++ ) { TimeData timeDataMax = timeDatasMax . get ( i ) ; Entry entry = new Entry ( ( ( int ) ( timeDataMax . getData ( ) ) ) , i ) ; entriesMax . add ( entry ) ; TimeData timeDataMin = timeDatasMin . get ( i ) ; entry = new Entry ( ( ( int ) ( timeDataMin . getData ( ) ) ) , i ) ; entriesMin . add ( entry ) ; } LineDataSet lineDataSetMax = new LineDataSet ( entriesMax , ( "High<seq2seq4repair_space>" + ( weatherChildGraph . getProperty ( ) ) ) ) ; LineDataSet lineDataSetMin = new LineDataSet ( entriesMin , ( "Low<seq2seq4repair_space>" + ( weatherChildGraph . getProperty ( ) ) ) ) ; int blue = - 12627531 ; lineDataSetMax . setDrawCubic ( true ) ; lineDataSetMax . setAxisDependency ( LEFT ) ; lineDataSetMax . setLineWidth ( 4.0F ) ; lineDataSetMax . setColor ( RED ) ; lineDataSetMax . enableDashedLine ( 10.0F , 10.0F , 0.0F ) ; lineDataSetMax . setDrawCircles ( false ) ; lineDataSetMax . setDrawValues ( false ) ; lineDataSetMax . setFillColor ( RED ) ; lineDataSetMin . setDrawCubic ( true ) ; lineDataSetMin . setAxisDependency ( LEFT ) ; <START_BUG> lineDataSetMin . setLineWidth ( 2.0F ) ; <END_BUG> lineDataSetMin . setColor ( blue ) ; lineDataSetMin . enableDashedLine ( 10.0F , 10.0F , 0.0F ) ; lineDataSetMin . setDrawCircles ( false ) ; lineDataSetMin . setDrawValues ( false ) ; lineDataSetMin . setFillColor ( blue ) ; DateFormat df = new SimpleDateFormat ( "dd" ) ; ArrayList < String > labels = new ArrayList < > ( ) ; for ( int i = 0 ; i < ( timeDatasMax . size ( ) ) ; i ++ ) { TimeData timeDataItem = timeDatasMax . get ( i ) ; Date time = new Date ( ( ( ( long ) ( timeDataItem . getTime ( ) ) ) * 1000 ) ) ; String hour = df . format ( time ) ; labels . add ( hour ) ; } LineData data = new LineData ( labels , lineDataSetMax ) ; data . addDataSet ( lineDataSetMin ) ; lineChart . setTouchEnabled ( false ) ; lineChart . animateX ( 2000 ) ; lineChart . getXAxis ( ) . setPosition ( BOTTOM ) ; lineChart . getAxisRight ( ) . setDrawGridLines ( false ) ; lineChart . getAxisRight ( ) . setDrawLabels ( false ) ; lineChart . getAxisLeft ( ) . setDrawGridLines ( false ) ; lineChart . getAxisLeft ( ) . setLabelCount ( 4 , true ) ; lineChart . getAxisLeft ( ) . setTextColor ( WHITE ) ; lineChart . getXAxis ( ) . setTextColor ( WHITE ) ; lineChart . getLegend ( ) . setTextColor ( WHITE ) ; lineChart . setDrawGridBackground ( false ) ; lineChart . setHardwareAccelerationEnabled ( true ) ; lineChart . animateY ( 2000 ) ; lineChart . setData ( data ) ; } }
public class BootStrapperTest { @ Test public void testGuessToken ( ) throws IOException { StorageService ss = StorageService . instance ( ) ; generateFakeEndpoints ( 3 ) ; InetAddress one = InetAddress . getByName ( "127.0.0.2" ) ; InetAddress two = InetAddress . getByName ( "127.0.0.3" ) ; InetAddress three = InetAddress . getByName ( "127.0.0.4" ) ; Map < InetAddress , Double > load = new HashMap < InetAddress , Double > ( ) ; load . put ( one , 1.0 ) ; load . put ( two , 2.0 ) ; load . put ( three , 3.0 ) ; TokenMetadata tmd = ss . getTokenMetadata ( ) ; InetAddress source = BootStrapper . getBootstrapSource ( tmd , load ) ; assert three . equals ( source ) ; InetAddress myEndpoint = InetAddress . getByName ( "127.0.0.1" ) ; Range range3 = ss . getPrimaryRangeForEndPoint ( three ) ; <START_BUG> Token fakeToken = ( ( IPartitioner ) ( StorageService . getPartitioner ( ) ) ) . midpoint ( range3 . left ( ) , range3 . right ( ) ) ; <END_BUG> assert range3 . contains ( fakeToken ) ; ss . onChange ( myEndpoint , MOVE_STATE , new org . apache . cassandra . gms . ApplicationState ( ( ( ( StorageService . STATE_BOOTSTRAPPING ) + ( StorageService . Delimiter ) ) + ( ss . getPartitioner ( ) . getTokenFactory ( ) . toString ( fakeToken ) ) ) ) ) ; tmd = ss . getTokenMetadata ( ) ; InetAddress source2 = BootStrapper . getBootstrapSource ( tmd , load ) ; assert two . equals ( source2 ) : source2 ; } @ Test public void testSourceTargetComputation ( ) throws UnknownHostException { } private void testSourceTargetComputation ( int numOldNodes ) throws UnknownHostException { } private void generateFakeEndpoints ( int numOldNodes ) throws UnknownHostException { } }
public class EJJasperReports { static final Logger LOGGER = LoggerFactory . getLogger ( EJJasperReports . class ) ; static Map < String , Object > toParameters ( EJJasperReportParameter ... parameters ) { } public static JasperPrint fillReport ( String reportFile , JRDataSource dataSource , EJJasperReportParameter ... parameters ) { } public static JasperPrint fillReport ( InputStream reportFile , JRDataSource dataSource , EJJasperReportParameter ... parameters ) { } public static JasperPrint fillReport ( JasperReport reportFile , JRDataSource dataSource , EJJasperReportParameter ... parameters ) { } public static JasperPrint fillReport ( String reportFile , Connection connection , EJJasperReportParameter ... parameters ) { } public static JasperPrint fillReport ( EJReportFrameworkManager manager , final EJReport report , EJJasperReportParameter ... parameters ) { try { EJReportJasperReportBuilder builder = new EJReportJasperReportBuilder ( ) ; builder . buildDesign ( report ) ; long start = System . currentTimeMillis ( ) ; EJJasperReports . LOGGER . info ( ( "START<seq2seq4repair_space>Genarate<seq2seq4repair_space>EjReport<seq2seq4repair_space>-><seq2seq4repair_space>Jasper<seq2seq4repair_space>Report<seq2seq4repair_space>:" + ( report . getName ( ) ) ) ) ; JasperReport jasperReport = builder . toReport ( ) ; List < EJJasperReportParameter > reportParameters = new ArrayList < EJJasperReportParameter > ( ) ; for ( EJApplicationLevelParameter parameter : manager . getApplicationLevelParameters ( ) ) { EJJasperReportParameter jasperReportParameter = new EJJasperReportParameter ( parameter . getName ( ) , parameter . getValue ( ) ) ; reportParameters . add ( jasperReportParameter ) ; } Collection < EJReportParameter > allParameters = report . getParameterList ( ) . getAllParameters ( ) ; for ( EJReportParameter parameter : allParameters ) { EJJasperReportParameter jasperReportParameter = new EJJasperReportParameter ( parameter . getName ( ) , parameter . getValue ( ) ) ; reportParameters . add ( jasperReportParameter ) ; } EJReportBlockContext blockContext = new EJReportBlockContext ( ) { @ Override public JasperReport getBlockReport ( String blockName ) { EJReportBlock block = report . getBlock ( blockName ) ; EJReportJasperReportBuilder sbBuilder = new EJReportJasperReportBuilder ( ) ; sbBuilder . buildDesign ( block ) ; return sbBuilder . toReport ( ) ; } @ Override public JasperReport getBlockReportFixed ( String blockName ) { EJReportBlock block = report . getBlock ( blockName ) ; EJReportJasperReportBuilder sbBuilder = new EJReportJasperReportBuilder ( ) ; <START_BUG> sbBuilder . buildDesign ( block ) ; <END_BUG> return sbBuilder . toReport ( ) ; } } ; EJJasperReportParameter subRPTParameter = new EJJasperReportParameter ( "EJRJ_BLOCK_RPT" , blockContext ) ; reportParameters . add ( subRPTParameter ) ; reportParameters . addAll ( Arrays . asList ( parameters ) ) ; EJJasperReports . LOGGER . info ( ( ( ( "END<seq2seq4repair_space>Genarate<seq2seq4repair_space>EjReport<seq2seq4repair_space>-><seq2seq4repair_space>Jasper<seq2seq4repair_space>Report<seq2seq4repair_space>:" + ( report . getName ( ) ) ) + "<seq2seq4repair_space>TIME(sec):" ) + ( ( ( System . currentTimeMillis ( ) ) - start ) / 1000 ) ) ) ; EJJasperReports . LOGGER . info ( ( "START<seq2seq4repair_space>Filling<seq2seq4repair_space>Report<seq2seq4repair_space>:" + ( report . getName ( ) ) ) ) ; start = System . currentTimeMillis ( ) ; JasperPrint print = EJJasperReports . fillReport ( jasperReport , new org . entirej . report . jasper . data . EJReportDataSource ( report ) , reportParameters . toArray ( parameters ) ) ; report . getActionController ( ) . afterReport ( report ) ; EJJasperReports . LOGGER . info ( ( ( ( "END<seq2seq4repair_space>Filling<seq2seq4repair_space>Report<seq2seq4repair_space>:" + ( report . getName ( ) ) ) + "<seq2seq4repair_space>TIME(sec):" ) + ( ( ( System . currentTimeMillis ( ) ) - start ) / 1000 ) ) ) ; return print ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new EJReportRuntimeException ( e ) ; } } public static JasperPrint fillReport ( InputStream reportFile , Connection connection , EJJasperReportParameter ... parameters ) { } public static JasperPrint fillReport ( JasperReport reportFile , Connection connection , EJJasperReportParameter ... parameters ) { } public static void exportReport ( String reportFile , String outputFile , EJReportExportType type , JRDataSource dataSource , EJJasperReportParameter ... parameters ) { } public static void exportReport ( EJReportFrameworkManager manager , EJReport report , String outputFile , EJJasperReportParameter ... parameters ) { } public static void exportReport ( EJReportFrameworkManager manager , EJReport report , String outputFile , EJReportExportType type , EJJasperReportParameter ... parameters ) { } public static void exportReport ( String reportFile , String outputFile , EJReportExportType type , Connection connection , EJJasperReportParameter ... parameters ) { } public static void exportReport ( InputStream reportFile , String outputFile , EJReportExportType type , JRDataSource dataSource , EJJasperReportParameter ... parameters ) { } public static void exportReport ( InputStream reportFile , String outputFile , EJReportExportType type , Connection connection , EJJasperReportParameter ... parameters ) { } public static void exportReport ( EJReportExportType type , JasperPrint print , String outputFile ) { } public static void tempRUN ( String reportFile , JRDataSource dataSource ) { } public static void tempEJReportRun ( EJReportFrameworkManager manager , EJReport report , EJJasperReportParameter ... parameters ) { } private static void removeBlankPage ( List < JRPrintPage > pages ) { } }
public class CodeSplitGinMapperGenerator extends Generator { private static String NamePostfix = "Impl" ; public String generate ( TreeLogger logger , GeneratorContext context , String typeName ) throws UnableToCompleteException { } public SourceWriter getSourceWriter ( TreeLogger logger , GeneratorContext context , JClassType classType ) { } private JClassType getGinjectorType ( TreeLogger logger , TypeOracle typeOracle , JClassType classType , JClassType ginMapperType ) throws UnableToCompleteException , NotFoundException { } private List < JClassType > getCodeSplitPlaces ( TreeLogger logger , TypeOracle typeOracle , String mapperType ) throws UnableToCompleteException , NotFoundException { } private void writeGetMethod ( TreeLogger logger , SourceWriter sourceWriter , List < JClassType > codeSplitPlaces , JClassType ginType ) throws UnableToCompleteException , NotFoundException { sourceWriter . println ( ( ( "private<seq2seq4repair_space>static<seq2seq4repair_space>" + ( ginType . getQualifiedBinaryName ( ) ) ) + "<seq2seq4repair_space>ginjector;" ) ) ; sourceWriter . println ( ( ( "public<seq2seq4repair_space>" + ( ginType . getQualifiedBinaryName ( ) ) ) + "<seq2seq4repair_space>getGinjector()<seq2seq4repair_space>{" ) ) ; sourceWriter . indent ( ) ; sourceWriter . println ( "return<seq2seq4repair_space>ginjector;" ) ; sourceWriter . outdent ( ) ; sourceWriter . println ( "}" ) ; sourceWriter . println ( ) ; sourceWriter . println ( "<seq2seq4repair_space>public<seq2seq4repair_space>void<seq2seq4repair_space>preload()<seq2seq4repair_space>{" ) ; sourceWriter . indent ( ) ; sourceWriter . println ( "get(null,<seq2seq4repair_space>null);" ) ; sourceWriter . outdent ( ) ; sourceWriter . println ( "}" ) ; sourceWriter . println ( ) ; sourceWriter . println ( "@Override<seq2seq4repair_space>public<seq2seq4repair_space>void<seq2seq4repair_space>get(final<seq2seq4repair_space>SlottedPlace<seq2seq4repair_space>place,<seq2seq4repair_space>final<seq2seq4repair_space>Callback<?<seq2seq4repair_space>super<seq2seq4repair_space>Activity,<seq2seq4repair_space>?<seq2seq4repair_space>super<seq2seq4repair_space>Throwable><seq2seq4repair_space>callback)<seq2seq4repair_space>{" ) ; sourceWriter . indent ( ) ; sourceWriter . println ( "GWT.runAsync(new<seq2seq4repair_space>RunAsyncCallback()<seq2seq4repair_space>{" ) ; sourceWriter . indent ( ) ; sourceWriter . println ( "@Override<seq2seq4repair_space>public<seq2seq4repair_space>void<seq2seq4repair_space>onFailure(Throwable<seq2seq4repair_space>reason)<seq2seq4repair_space>{" ) ; sourceWriter . indent ( ) ; sourceWriter . println ( "callback.onFailure(reason);" ) ; sourceWriter . outdent ( ) ; sourceWriter . println ( "}" ) ; sourceWriter . println ( ) ; sourceWriter . println ( "@Override<seq2seq4repair_space>public<seq2seq4repair_space>void<seq2seq4repair_space>onSuccess()<seq2seq4repair_space>{" ) ; sourceWriter . indent ( ) ; <START_BUG> sourceWriter . println ( "if<seq2seq4repair_space>(callback<seq2seq4repair_space>==<seq2seq4repair_space>null)<seq2seq4repair_space>{return}" ) ; <END_BUG> sourceWriter . println ( "if<seq2seq4repair_space>(ginjector<seq2seq4repair_space>==<seq2seq4repair_space>null)<seq2seq4repair_space>{" ) ; sourceWriter . indent ( ) ; sourceWriter . println ( ( ( "ginjector<seq2seq4repair_space>=<seq2seq4repair_space>GWT.create(" + ( ginType . getQualifiedBinaryName ( ) ) ) + ".class);" ) ) ; sourceWriter . outdent ( ) ; sourceWriter . println ( "}" ) ; boolean first = true ; for ( JClassType place : codeSplitPlaces ) { generateIf ( logger , sourceWriter , place , ginType , first ) ; if ( first ) { first = false ; } } sourceWriter . println ( "}<seq2seq4repair_space>else<seq2seq4repair_space>{" ) ; sourceWriter . indent ( ) ; sourceWriter . println ( "callback.onFailure(new<seq2seq4repair_space>SlottedException(place.getClass().getName()<seq2seq4repair_space>+<seq2seq4repair_space>\"<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>found.\"));" ) ; sourceWriter . outdent ( ) ; sourceWriter . println ( "}" ) ; sourceWriter . outdent ( ) ; sourceWriter . println ( "}" ) ; sourceWriter . outdent ( ) ; sourceWriter . println ( "});" ) ; sourceWriter . outdent ( ) ; sourceWriter . println ( "}" ) ; } private void generateIf ( TreeLogger logger , SourceWriter sourceWriter , JClassType placeType , JClassType ginType , boolean first ) throws UnableToCompleteException , NotFoundException { } }
public class SignUpActivity extends Activity { protected EditText usernameEditText ; protected EditText passwordEditText ; protected EditText emailEditText ; protected Button signUpButton ; String username ; String password ; String email ; ParseFile file ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestWindowFeature ( FEATURE_INDETERMINATE_PROGRESS ) ; getActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; setContentView ( activity_sign_up ) ; usernameEditText = ( ( EditText ) ( findViewById ( usernameField ) ) ) ; passwordEditText = ( ( EditText ) ( findViewById ( passwordField ) ) ) ; emailEditText = ( ( EditText ) ( findViewById ( emailField ) ) ) ; signUpButton = ( ( Button ) ( findViewById ( signupButton ) ) ) ; signUpButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { username = usernameEditText . getText ( ) . toString ( ) ; password = passwordEditText . getText ( ) . toString ( ) ; email = emailEditText . getText ( ) . toString ( ) ; username = username . trim ( ) ; password = password . trim ( ) ; email = email . trim ( ) ; if ( ( ( username . isEmpty ( ) ) || ( password . isEmpty ( ) ) ) || ( email . isEmpty ( ) ) ) { AlertDialog . Builder builder = new AlertDialog . Builder ( SignUpActivity . this ) ; builder . setMessage ( signup_error_message ) . setTitle ( signup_error_title ) . setPositiveButton ( ok , null ) ; AlertDialog dialog = builder . create ( ) ; dialog . show ( ) ; } else { setProgressBarIndeterminateVisibility ( true ) ; ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; <START_BUG> Bitmap pictureBitMap = BitmapFactory . decodeResource ( getResources ( ) , default_avatar ) ; <END_BUG> pictureBitMap . compress ( JPEG , 75 , stream ) ; byte [ ] data = stream . toByteArray ( ) ; file = new ParseFile ( "default_picture.png" , data ) ; file . saveInBackground ( new SaveCallback ( ) { @ Override public void done ( ParseException e ) { ParseUser newUser = new ParseUser ( ) ; newUser . setUsername ( username ) ; newUser . setPassword ( password ) ; newUser . setEmail ( email ) ; newUser . put ( "Picture" , file ) ; newUser . put ( "Role" , "visitor" ) ; newUser . signUpInBackground ( new SignUpCallback ( ) { @ Override public void done ( ParseException e ) { setProgressBarIndeterminateVisibility ( false ) ; if ( e == null ) { Intent intent = new Intent ( SignUpActivity . this , MainActivity . class ) ; intent . addFlags ( FLAG_ACTIVITY_NEW_TASK ) ; intent . addFlags ( FLAG_ACTIVITY_CLEAR_TASK ) ; startActivity ( intent ) ; } else { AlertDialog . Builder builder = new AlertDialog . Builder ( SignUpActivity . this ) ; builder . setMessage ( e . getMessage ( ) ) . setTitle ( signup_error_title ) . setPositiveButton ( ok , null ) ; AlertDialog dialog = builder . create ( ) ; dialog . show ( ) ; } } } ) ; } } ) ; } } } ) ; } }
public class FieldReference extends Reference implements InvocationSite { public Expression receiver ; public char [ ] token ; public FieldBinding binding ; public FieldBinding codegenBinding ; public long nameSourcePosition ; MethodBinding syntheticReadAccessor ; MethodBinding syntheticWriteAccessor ; public TypeBinding receiverType ; public FieldReference ( char [ ] source , long pos ) { } public FlowInfo analyseAssignment ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , Assignment assignment , boolean isCompound ) { if ( isCompound ) { if ( ( ( ( binding . isBlankFinal ( ) ) && ( receiver . isThis ( ) ) ) && ( currentScope . allowBlankFinalFieldAssignment ( binding ) ) ) && ( ! ( flowInfo . isDefinitelyAssigned ( binding ) ) ) ) { currentScope . problemReporter ( ) . uninitializedBlankFinalField ( binding , this ) ; } manageSyntheticReadAccessIfNecessary ( currentScope , flowInfo ) ; } flowInfo = receiver . analyseCode ( currentScope , flowContext , flowInfo , ( ! ( binding . isStatic ( ) ) ) ) . unconditionalInits ( ) ; if ( ( assignment . expression ) != null ) { flowInfo = assignment . expression . analyseCode ( currentScope , flowContext , flowInfo ) . unconditionalInits ( ) ; } manageSyntheticWriteAccessIfNecessary ( currentScope , flowInfo ) ; if ( binding . isFinal ( ) ) { if ( ( ( ( ( ( binding . isBlankFinal ( ) ) && ( ! isCompound ) ) && ( receiver . isThis ( ) ) ) && ( ! ( ( receiver ) instanceof QualifiedThisReference ) ) ) && ( ( ( receiver . bits ) & ( ASTNode . ParenthesizedMASK ) ) == 0 ) ) && ( currentScope . allowBlankFinalFieldAssignment ( binding ) ) ) { if ( flowInfo . isPotentiallyAssigned ( binding ) ) { currentScope . problemReporter ( ) . duplicateInitializationOfBlankFinalField ( binding , this ) ; } else { <START_BUG> flowContext . recordSettingFinal ( binding , this ) ; <END_BUG> } flowInfo . markAsDefinitelyAssigned ( binding ) ; } else { currentScope . problemReporter ( ) . cannotAssignToFinalField ( binding , this ) ; } } return flowInfo ; } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , boolean valueRequired ) { } public FieldBinding fieldBinding ( ) { } public void generateAssignment ( BlockScope currentScope , CodeStream codeStream , Assignment assignment , boolean valueRequired ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } public void generateCompoundAssignment ( BlockScope currentScope , CodeStream codeStream , Expression expression , int operator , int assignmentImplicitConversion , boolean valueRequired ) { } public void generatePostIncrement ( BlockScope currentScope , CodeStream codeStream , CompoundAssignment postIncrement , boolean valueRequired ) { } public static final Constant getConstantFor ( FieldBinding binding , Reference reference , boolean isImplicit , Scope referenceScope ) { } public boolean isSuperAccess ( ) { } public boolean isTypeAccess ( ) { } public void manageSyntheticReadAccessIfNecessary ( BlockScope currentScope , FlowInfo flowInfo ) { } public void manageSyntheticWriteAccessIfNecessary ( BlockScope currentScope , FlowInfo flowInfo ) { } public StringBuffer printExpression ( int indent , StringBuffer output ) { } public TypeBinding resolveType ( BlockScope scope ) { } public void setActualReceiverType ( ReferenceBinding receiverType ) { } public void setDepth ( int depth ) { } public void setFieldIndex ( int index ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope scope ) { } }
public class CharEncoding { public static final String ISO_8859_1 = "ISO-8859-1" ; public static final String US_ASCII = "US-ASCII" ; public static final String UTF_16 = "UTF-16" ; public static final String UTF_16BE = "UTF-16BE" ; public static final String UTF_16LE = "UTF-16LE" ; public static final String UTF_8 = "UTF-8" ; <START_BUG> public static boolean isSupported ( String name ) { <END_BUG> if ( name == null ) { return false ; } try { return Charset . isSupported ( name ) ; } catch ( IllegalCharsetNameException ex ) { return false ; } } }
public class ReaperPlayerListener implements Listener { public ReaperPlayerListener ( ) { } @ EventHandler ( priority = EventPriority . HIGH ) public void onPlayerRespawn ( PlayerRespawnEvent event ) { if ( ( GraveyardUtils . useBed ( event . getPlayer ( ) ) ) && ( event . isBedSpawn ( ) ) ) { return ; } if ( event . getPlayer ( ) . hasPermission ( "graveyard.closest" ) ) { if ( ( SpawnPoint . getAllowedList ( event . getPlayer ( ) ) . size ( ) ) != 0 ) { Spawn closest = SpawnPoint . getClosestAllowed ( event . getPlayer ( ) ) ; if ( closest == null ) { return ; } else if ( ! ( closest . getSpawnMessage ( ) . equalsIgnoreCase ( "none" ) ) ) { <START_BUG> event . getPlayer ( ) . sendMessage ( closest . getSpawnMessage ( ) ) ; <END_BUG> } event . setRespawnLocation ( closest . getLocation ( ) ) ; } } } No newline ; at end ; of file ; }
public class PossibleMatch implements ICompilationUnit { public static final String NO_SOURCE_FILE_NAME = "NO<seq2seq4repair_space>SOURCE<seq2seq4repair_space>FILE<seq2seq4repair_space>NAME" ; public IResource resource ; public Openable openable ; public MatchingNodeSet nodeSet ; public char [ ] [ ] compoundName ; CompilationUnitDeclaration parsedUnit ; public SearchDocument document ; private String sourceFileName ; private char [ ] source ; public PossibleMatch ( MatchLocator locator , IResource resource , Openable openable , SearchDocument document , boolean mustResolve ) { } public void cleanUp ( ) { } public boolean equals ( Object obj ) { } public char [ ] getContents ( ) { } public char [ ] getFileName ( ) { } public char [ ] getMainTypeName ( ) { } public char [ ] [ ] getPackageName ( ) { } private char [ ] getQualifiedName ( ) { if ( ( this . openable ) instanceof CompilationUnit ) { <START_BUG> String fileName = this . resource . getFullPath ( ) . lastSegment ( ) ; <END_BUG> char [ ] mainTypeName = Util . getNameWithoutJavaLikeExtension ( fileName ) . toCharArray ( ) ; CompilationUnit cu = ( ( CompilationUnit ) ( this . openable ) ) ; return cu . getType ( new String ( mainTypeName ) ) . getFullyQualifiedName ( ) . toCharArray ( ) ; } else if ( ( this . openable ) instanceof ClassFile ) { String fileName = getSourceFileName ( ) ; if ( fileName == ( PossibleMatch . NO_SOURCE_FILE_NAME ) ) return ( ( ClassFile ) ( this . openable ) ) . getType ( ) . getFullyQualifiedName ( '.' ) . toCharArray ( ) ; int index = Util . indexOfJavaLikeExtension ( fileName ) ; String simpleName = ( index == ( - 1 ) ) ? fileName : fileName . substring ( 0 , index ) ; PackageFragment pkg = ( ( PackageFragment ) ( this . openable . getParent ( ) ) ) ; return Util . concatWith ( pkg . names , simpleName , '.' ) . toCharArray ( ) ; } return null ; } private String getSourceFileName ( ) { } public int hashCode ( ) { } public String toString ( ) { } }
public class SodaReporter { private String resultDir = "" ; private String reportLog = null ; private FileOutputStream reportFD = null ; private int Blocked = 0 ; private int Exceptions = 0 ; private int FailedAsserts = 0 ; private int PassedAsserts = 0 ; private int OtherErrors = 0 ; private int WatchDog = 0 ; private String LineSeparator = null ; private int SavePageNum = 0 ; private SodaBrowser browser = null ; private boolean isRestart = false ; private String testName = null ; private boolean saveOnWarning = false ; private boolean saveOnError = false ; private boolean saveOnAssertFailed = false ; private boolean saveOnException = false ; private boolean saveOnWatchDog = false ; public SodaReporter ( String reportName , String resultDir ) { } public void setTestName ( String name ) { } public void setIsRestTest ( boolean restart ) { } public void setSaveHTML ( String setting , SodaBrowser browser ) { } public String getLogFileName ( ) { } public SodaTestResults getResults ( ) { } private String replaceLineFeed ( String str ) { } private void _log ( String msg ) { } public void closeLog ( ) { } public void Log ( String msg ) { } public void Warn ( String msg ) { } public void ReportError ( String msg ) { } public void ReportWatchDog ( ) { } public void ReportBlocked ( ) { } public void ReportException ( Exception e ) { } public boolean isRegex ( String str ) { } public String strToRegex ( String val ) { } public boolean Assert ( String msg , boolean state , boolean expected ) { } public boolean Assert ( String value , String src ) { } public boolean AssertNot ( String value , String src ) { boolean result = false ; String msg = "" ; if ( isRegex ( value ) ) { value = this . strToRegex ( value ) ; if ( src . matches ( value ) ) { this . FailedAsserts += 1 ; msg = String . format ( "(!)Assert<seq2seq4repair_space>Failed,<seq2seq4repair_space>Found<seq2seq4repair_space>Unexpected<seq2seq4repair_space>text:<seq2seq4repair_space>'%s'." , value ) ; this . _log ( msg ) ; if ( this . saveOnAssertFailed ) { this . SavePage ( ) ; } result = false ; } else { this . PassedAsserts += 1 ; msg = String . format ( "Assert<seq2seq4repair_space>Passed<seq2seq4repair_space>did<seq2seq4repair_space>not<seq2seq4repair_space>find:<seq2seq4repair_space>'%s'<seq2seq4repair_space>as<seq2seq4repair_space>expected." , value ) ; this . Log ( msg ) ; result = true ; } } else { if ( src . contains ( value ) ) { this . FailedAsserts += 1 ; <START_BUG> msg = String . format ( "(!)Assert<seq2seq4repair_space>Passed,<seq2seq4repair_space>Found:<seq2seq4repair_space>'%s'." , value ) ; <END_BUG> this . _log ( msg ) ; if ( this . saveOnAssertFailed ) { this . SavePage ( ) ; } result = false ; } else { this . PassedAsserts += 1 ; msg = String . format ( "Assert<seq2seq4repair_space>Passed<seq2seq4repair_space>did<seq2seq4repair_space>not<seq2seq4repair_space>find:<seq2seq4repair_space>'%s'<seq2seq4repair_space>as<seq2seq4repair_space>expected." , value ) ; this . Log ( msg ) ; result = true ; } } return result ; } public void SavePage ( ) { } protected void finalize ( ) throws Throwable { } }
public class WebRequestCycle extends RequestCycle { private static final Log log = LogFactory . getLog ( WebRequestCycle . class ) ; public WebRequestCycle ( final WebSession session , final WebRequest request , final Response response ) { } public WebRequest getWebRequest ( ) { } public WebResponse getWebResponse ( ) { } public WebSession getWebSession ( ) { } public final void redirectTo ( final Page page ) { String redirectUrl = null ; ApplicationSettings settings = application . getSettings ( ) ; if ( ( ( settings . getRenderStrategy ( ) ) == ( ApplicationSettings . REDIRECT_TO_BUFFER ) ) && ( ( application ) instanceof WebApplication ) ) { final Response currentResponse = getResponse ( ) ; try { final BufferedResponse redirectResponse = new BufferedResponse ( ) { public String encodeURL ( String url ) { return currentResponse . encodeURL ( url ) ; } } ; redirectResponse . setCharacterEncoding ( currentResponse . getCharacterEncoding ( ) ) ; setResponse ( redirectResponse ) ; page . doRender ( ) ; setResponse ( currentResponse ) ; final String responseRedirect = redirectResponse . getRedirectUrl ( ) ; if ( responseRedirect != null ) { redirectUrl = responseRedirect ; } else if ( ( redirectResponse . getContentLength ( ) ) > 0 ) { redirectResponse . setCharacterEncoding ( currentResponse . getCharacterEncoding ( ) ) ; redirectResponse . filter ( ) ; redirectResponse . close ( ) ; redirectUrl = page . urlFor ( page , IRedirectListener . class ) ; <START_BUG> ( ( WebApplication ) ( application ) ) . addRedirect ( getWebRequest ( ) . getHttpServletRequest ( ) , redirectUrl , redirectResponse ) ; <END_BUG> } } catch ( RuntimeException ex ) { setResponse ( currentResponse ) ; WebRequestCycle . log . error ( ex . getMessage ( ) , ex ) ; IRequestCycleProcessor processor = getRequestCycleProcessor ( ) ; processor . respond ( ex , this ) ; return ; } } else { session . touch ( page ) ; page . internalEndRequest ( ) ; } if ( redirectUrl == null ) { redirectUrl = page . urlFor ( page , IRedirectListener . class ) ; } response . redirect ( redirectUrl ) ; } protected ClientInfo newClientInfo ( ) { } public IRequestCycleProcessor getRequestCycleProcessor ( ) { } }
public class DomainClientImpl implements DomainClient { private volatile DomainDeploymentManager deploymentManager ; private final ModelControllerClient delegate ; public DomainClientImpl ( InetAddress address , int port ) { } @ Override public OperationResult execute ( ModelNode operation , ResultHandler handler ) { } @ Override public ModelNode execute ( ModelNode operation ) throws IOException , CancellationException { } @ Override public OperationResult execute ( Operation operation , ResultHandler handler ) { } @ Override public ModelNode execute ( Operation operation ) throws IOException , CancellationException { } @ Override public byte [ ] addDeploymentContent ( InputStream stream ) { } @ Override public DomainDeploymentManager getDeploymentManager ( ) { } @ Override public List < String > getHostControllerNames ( ) { } @ Override public Map < ServerIdentity , ServerStatus > getServerStatuses ( ) { } private Set < String > getServerNames ( String host ) { ModelNode op = new ModelNode ( ) ; op . get ( "operation" ) . set ( "read-children-names" ) ; op . get ( "child-type" ) . set ( "server-config" ) ; <START_BUG> op . get ( "address" ) . set ( "host" , host ) ; <END_BUG> ModelNode result = executeForResult ( Factory . create ( op ) . build ( ) ) ; Set < String > servers = new HashSet < String > ( ) ; for ( ModelNode server : result . asList ( ) ) { servers . add ( server . asString ( ) ) ; } return servers ; } private ModelNode readAttribute ( String name , ModelNode address ) { } @ Override public ServerStatus startServer ( String hostControllerName , String serverName ) { } @ Override public ServerStatus stopServer ( String hostControllerName , String serverName , long gracefulShutdownTimeout , TimeUnit timeUnit ) { } @ Override public ServerStatus restartServer ( String hostControllerName , String serverName , long gracefulShutdownTimeout , TimeUnit timeUnit ) { } boolean isDeploymentNameUnique ( final String deploymentName ) { } @ Override public void close ( ) throws IOException { } ModelNode executeForResult ( Operation op ) { } }
public class RarConfigProcessor implements DeploymentUnitProcessor { private static ModuleIdentifier JAVAX_ID = ModuleIdentifier . create ( "javax.resource.api" ) ; private static ModuleIdentifier LOGGING_ID = ModuleIdentifier . create ( "org.jboss.logging" ) ; private static ModuleIdentifier IRON_JACAMAR_ID = ModuleIdentifier . create ( "org.jboss.ironjacamar.api" ) ; private static ModuleIdentifier IRON_JACAMAR_IMPL_ID = ModuleIdentifier . create ( "org.jboss.ironjacamar.impl" ) ; private static ModuleIdentifier NAMING_ID = ModuleIdentifier . create ( "org.jboss.as.naming" ) ; private static ModuleIdentifier VALIDATION_ID = ModuleIdentifier . create ( "javax.validation.api" ) ; private static ModuleIdentifier HIBERNATE_VALIDATOR_ID = ModuleIdentifier . create ( "org.hibernate.validator" ) ; private static ModuleIdentifier COMMON_CORE_ID = ModuleIdentifier . create ( "org.jboss.common-core" ) ; private static ModuleIdentifier SYSTEM_ID = ModuleIdentifier . create ( "javax.api" ) ; public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { if ( ( phaseContext . getDeploymentUnit ( ) . getAttachment ( ATTACHMENT_KEY ) ) == null ) { return ; } final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; <START_BUG> final ModuleLoader moduleLoader = Module . getSystemModuleLoader ( ) ; <END_BUG> final ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( MODULE_SPECIFICATION ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . JAVAX_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . LOGGING_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . IRON_JACAMAR_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . IRON_JACAMAR_IMPL_ID , false , true , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . SYSTEM_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . NAMING_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . VALIDATION_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . HIBERNATE_VALIDATOR_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . COMMON_CORE_ID , false , false , false ) ) ; } public void undeploy ( final DeploymentUnit context ) { } }
public class ComplexTest { private double inf = Double . POSITIVE_INFINITY ; private double neginf = Double . NEGATIVE_INFINITY ; private double nan = Double . NaN ; private double pi = FastMath . PI ; private Complex oneInf = new Complex ( 1 , inf ) ; private Complex oneNegInf = new Complex ( 1 , neginf ) ; private Complex infOne = new Complex ( inf , 1 ) ; private Complex infZero = new Complex ( inf , 0 ) ; private Complex infNaN = new Complex ( inf , nan ) ; private Complex infNegInf = new Complex ( inf , neginf ) ; private Complex infInf = new Complex ( inf , inf ) ; private Complex negInfInf = new Complex ( neginf , inf ) ; private Complex negInfZero = new Complex ( neginf , 0 ) ; private Complex negInfOne = new Complex ( neginf , 1 ) ; private Complex negInfNaN = new Complex ( neginf , nan ) ; private Complex negInfNegInf = new Complex ( neginf , neginf ) ; private Complex oneNaN = new Complex ( 1 , nan ) ; private Complex zeroInf = new Complex ( 0 , inf ) ; private Complex zeroNaN = new Complex ( 0 , nan ) ; private Complex nanInf = new Complex ( nan , inf ) ; private Complex nanNegInf = new Complex ( nan , neginf ) ; private Complex nanZero = new Complex ( nan , 0 ) ; @ Test public void testConstructor ( ) { } @ Test public void testConstructorNaN ( ) { } @ Test public void testAbs ( ) { } @ Test public void testAbsNaN ( ) { } @ Test public void testAbsInfinite ( ) { } @ Test public void testAdd ( ) { } @ Test public void testAddNaN ( ) { } @ Test public void testAddInf ( ) { } @ Test public void testScalarAdd ( ) { } @ Test public void testScalarAddNaN ( ) { } @ Test public void testScalarAddInf ( ) { } @ Test public void testConjugate ( ) { } @ Test public void testConjugateNaN ( ) { } @ Test public void testConjugateInfiinite ( ) { } @ Test public void testDivide ( ) { } @ Test public void testDivideReal ( ) { } @ Test public void testDivideImaginary ( ) { } @ Test public void testDivideInf ( ) { } @ Test public void testDivideZero ( ) { } @ Test public void testDivideZeroZero ( ) { } @ Test public void testDivideNaN ( ) { } @ Test public void testDivideNaNInf ( ) { } @ Test public void testScalarDivide ( ) { } @ Test public void testScalarDivideNaN ( ) { } @ Test public void testScalarDivideInf ( ) { } @ Test public void testScalarDivideZero ( ) { } @ Test public void testReciprocal ( ) { } @ Test public void testReciprocalReal ( ) { } @ Test public void testReciprocalImaginary ( ) { } @ Test public void testReciprocalInf ( ) { } @ Test public void testReciprocalZero ( ) { <START_BUG> Assert . assertEquals ( ZERO . reciprocal ( ) , NaN ) ; <END_BUG> } @ Test public void testReciprocalNaN ( ) { } @ Test public void testMultiply ( ) { } @ Test public void testMultiplyNaN ( ) { } @ Test public void testMultiplyInfInf ( ) { } @ Test public void testMultiplyNaNInf ( ) { } @ Test public void testScalarMultiply ( ) { } @ Test public void testScalarMultiplyNaN ( ) { } @ Test public void testScalarMultiplyInf ( ) { } @ Test public void testNegate ( ) { } @ Test public void testNegateNaN ( ) { } @ Test public void testSubtract ( ) { } @ Test public void testSubtractNaN ( ) { } @ Test public void testSubtractInf ( ) { } @ Test public void testScalarSubtract ( ) { } @ Test public void testScalarSubtractNaN ( ) { } @ Test public void testScalarSubtractInf ( ) { } @ Test public void testEqualsNull ( ) { } @ Test public void testEqualsClass ( ) { } @ Test public void testEqualsSame ( ) { } @ Test public void testEqualsTrue ( ) { } @ Test public void testEqualsRealDifference ( ) { } @ Test public void testEqualsImaginaryDifference ( ) { } @ Test public void testEqualsNaN ( ) { } @ Test public void testHashCode ( ) { } @ Test public void testAcos ( ) { } @ Test public void testAcosInf ( ) { } @ Test public void testAcosNaN ( ) { } @ Test public void testAsin ( ) { } @ Test public void testAsinNaN ( ) { } @ Test public void testAsinInf ( ) { } @ Test public void testAtan ( ) { } @ Test public void testAtanInf ( ) { } @ Test public void testAtanI ( ) { } @ Test public void testAtanNaN ( ) { } @ Test public void testCos ( ) { } @ Test public void testCosNaN ( ) { } @ Test public void testCosInf ( ) { } @ Test public void testCosh ( ) { } @ Test public void testCoshNaN ( ) { } @ Test public void testCoshInf ( ) { } @ Test public void testExp ( ) { } @ Test public void testExpNaN ( ) { } @ Test public void testExpInf ( ) { } @ Test public void testLog ( ) { } @ Test public void testLogNaN ( ) { } @ Test public void testLogInf ( ) { } @ Test public void testLogZero ( ) { } @ Test public void testPow ( ) { } @ Test public void testPowNaNBase ( ) { } @ Test public void testPowNaNExponent ( ) { }
while ( act <= ( ParserBasicInformation . NUM_RULES ) ) { do { tempStackTop -= ( Parser . rhs [ act ] ) - 1 ; act = Parser . ntAction ( tempStack [ tempStackTop ] , Parser . lhs [ act ] ) ; } while ( act <= ( ParserBasicInformation . NUM_RULES ) ) ; if ( ( ( tempStackTop ) + 1 ) >= ( stackLength ) ) reallocateStacks ( ) ; pos = ( pos < ( tempStackTop ) ) ? pos : tempStackTop ; tempStack [ ( ( tempStackTop ) + 1 ) ] = act ; act = Parser . tAction ( act , tok ) ; } while ( ( act > ( ParserBasicInformation . ERROR_ACTION ) ) || ( act < ( ParserBasicInformation . ACCEPT_ACTION ) ) ) { nextStackTop = ( tempStackTop ) + 1 ; for ( int i = next_pos + 1 ; i <= ( nextStackTop ) ; i ++ ) nextStack [ i ] = tempStack [ i ] ; for ( int i = pos + 1 ; i <= ( nextStackTop ) ; i ++ ) { locationStack [ i ] = locationStack [ stateStackTop ] ; locationStartStack [ i ] = locationStartStack [ stateStackTop ] ; } if ( act > ( ParserBasicInformation . ERROR_ACTION ) ) { act -= ParserBasicInformation . ERROR_ACTION ; do { nextStackTop -= ( Parser . rhs [ act ] ) - 1 ; act = Parser . ntAction ( nextStack [ nextStackTop ] , Parser . lhs [ act ] ) ; } while ( act <= ( ParserBasicInformation . NUM_RULES ) ) ; pos = ( pos < ( nextStackTop ) ) ? pos : nextStackTop ; } if ( ( ( nextStackTop ) + 1 ) >= ( stackLength ) ) reallocateStacks ( ) ; tempStackTop = nextStackTop ; nextStack [ ( ++ ( nextStackTop ) ) ] = act ; next_pos = nextStackTop ; currentToken = lexStream . getToken ( ) ; tok = lexStream . kind ( currentToken ) ; act = Parser . tAction ( act , tok ) ; while ( act <= ( ParserBasicInformation . NUM_RULES ) ) { do { int lhs_symbol = Parser . lhs [ act ] ; if ( DiagnoseParser . DEBUG ) { System . out . println ( Parser . name [ Parser . non_terminal_index [ lhs_symbol ] ] ) ; } tempStackTop -= ( Parser . rhs [ act ] ) - 1 ; act = ( ( tempStackTop ) > next_pos ) ? tempStack [ tempStackTop ] : nextStack [ tempStackTop ] ; act = Parser . ntAction ( act , lhs_symbol ) ; } while ( act <= ( ParserBasicInformation . NUM_RULES ) ) ; if ( ( ( tempStackTop ) + 1 ) >= ( stackLength ) ) reallocateStacks ( ) ; next_pos = ( next_pos < ( tempStackTop ) ) ? next_pos : tempStackTop ; tempStack [ ( ( tempStackTop ) + 1 ) ] = act ; act = Parser . tAction ( act , tok ) ; } if ( act != ( ParserBasicInformation . ERROR_ACTION ) ) { prevStackTop = stateStackTop ; for ( int i = prev_pos + 1 ; i <= ( prevStackTop ) ; i ++ ) prevStack [ i ] = stack [ i ] ; prev_pos = pos ; stateStackTop = nextStackTop ; for ( int i = pos + 1 ; i <= ( stateStackTop ) ; i ++ ) stack [ i ] = nextStack [ i ] ; locationStack [ stateStackTop ] = currentToken ; locationStartStack [ stateStackTop ] = lexStream . start ( currentToken ) ; pos = next_pos ; } } if ( act == ( ParserBasicInformation . ERROR_ACTION ) ) { DiagnoseParser . RepairCandidate candidate = errorRecovery ( currentToken , forceRecoveryAfterLBracketMissing ) ; forceRecoveryAfterLBracketMissing = false ; if ( parser . reportOnlyOneSyntaxError ) { return ; } <START_BUG> if ( ( this . parser . problemReporter ( ) . globalOptions . maxProblemsPerUnit ) < ( this . parser . compilationUnit . compilationResult . problemCount ) ) { <END_BUG> return ; } act = stack [ stateStackTop ] ; if ( ( candidate . symbol ) == 0 ) { break ; } else if ( ( candidate . symbol ) > ( ParserBasicInformation . NT_OFFSET ) ) { int lhs_symbol = ( candidate . symbol ) - ( ParserBasicInformation . NT_OFFSET ) ; if ( DiagnoseParser . DEBUG ) { System . out . println ( Parser . name [ Parser . non_terminal_index [ lhs_symbol ] ] ) ; } act = Parser . ntAction ( act , lhs_symbol ) ; while ( act <= ( ParserBasicInformation . NUM_RULES ) ) { stateStackTop -= ( Parser . rhs [ act ] ) - 1 ; act = Parser . ntAction ( stack [ stateStackTop ] , Parser . lhs [ act ] ) ; } stack [ ( ++ ( stateStackTop ) ) ] = act ; currentToken = lexStream . getToken ( ) ; tok = lexStream . kind ( currentToken ) ; locationStack [ stateStackTop ] = currentToken ; locationStartStack [ stateStackTop ] = lexStream . start ( currentToken ) ; } else { tok = candidate . symbol ; locationStack [ stateStackTop ] = candidate . location ; locationStartStack [ stateStackTop ] = lexStream . start ( candidate . location ) ; } } } while ( act != ( ParserBasicInformation . ACCEPT_ACTION ) ) ; return ; } private DiagnoseParser . RepairCandidate errorRecovery ( int error_token , boolean forcedError ) { } private DiagnoseParser . RepairCandidate primaryPhase ( int error_token ) { } private int mergeCandidate ( int state , int buffer_position ) { } private DiagnoseParser . PrimaryRepairInfo checkPrimaryDistance ( int [ ] stck , int stack_top , DiagnoseParser . PrimaryRepairInfo repair ) { } private DiagnoseParser . RepairCandidate primaryDiagnosis ( DiagnoseParser . PrimaryRepairInfo repair ) { }
public class SWIPrologSolver implements Solver { private boolean loaded ; private HlclProgram hlclProgram ; private String programPath = null ; private Query qr ; boolean sucessfullLoad ; private Map < String , Variable > vars ; public static final String PROGRAM_INVOCATION = "productline(L)" ; public SWIPrologSolver ( ) { } public SWIPrologSolver ( HlclProgram hlclProgram ) { } public int getSolutionsCount ( ) { } @ Override public boolean isSatisfiable ( String programPath ) { } @ Override @ Deprecated public void setProductLine ( AbstractModel pl ) { } @ Override public void solve ( Configuration config , ConfigurationOptions options ) { } private void doQuery ( Configuration config , ConfigurationOptions options ) { <START_BUG> if ( ( ( hlclProgram ) == null ) && ( ( options . getProgramPath ( ) ) == null ) ) { <END_BUG> throw new TechnicalException ( "HlclProgram<seq2seq4repair_space>was<seq2seq4repair_space>not<seq2seq4repair_space>initialized" ) ; } else if ( ( hlclProgram ) == null ) { programPath = options . getProgramPath ( ) ; } else { HlclProgram modifiedCopy = new HlclProgram ( ) ; modifiedCopy . addAll ( hlclProgram . subList ( 0 , hlclProgram . size ( ) ) ) ; PrologTransformParameters params = addParametersToProgram ( modifiedCopy , options ) ; programPath = createPrologFile ( modifiedCopy , params ) ; Set < Identifier > identifiers = HlclUtil . getUsedIdentifiers ( hlclProgram ) ; for ( Identifier id : identifiers ) { vars . put ( id . getId ( ) , new Variable ( id . getId ( ) ) ) ; } } loadSWIProgram ( programPath ) ; } private void consultProgram ( Configuration config , ConfigurationOptions options ) { } private static Compound addSubQueries ( List < Compound > parts ) { } @ Override public boolean hasNextSolution ( ) { } @ Override public Configuration getSolution ( ) { } private Configuration makeConfiguration ( Hashtable < Variable , Term > configurationHashSet ) { } private boolean loadSWIProgram ( String temporalPath ) { } @ Override public void nextSolution ( ) { } @ Override public Object getProductLine ( ) { } @ Override public Map < String , List < Integer > > reduceDomain ( Configuration config , ConfigurationOptions params ) { } private static List < Integer > getSolutionValues ( Term [ ] terms , List < Integer > values ) { } private PrologTransformParameters addParametersToProgram ( HlclProgram prog , ConfigurationOptions options ) { } private PrologTransformParameters getParamsFor ( ConfigurationOptions options ) { } private String createPrologFile ( HlclProgram hlclProgram , PrologTransformParameters params ) { } @ Override public void setHLCLProgram ( HlclProgram hlclProgram ) { } @ Override public boolean hasSolution ( ) { } public HlclProgram getHlclProgram ( ) { } }
public Object removeMetaProperty ( String key ) { } public void addMetaProperties ( Map < String , Object > allAtOnce ) { } public void clearMetaProperties ( ) { } public static class StackEntry { final String cubeName ; final Map < String , Object > coord ; public StackEntry ( String name , Map < String , Object > coordinate ) { } public String toString ( ) { } } void addAdvice ( Advice advice , String method ) { } public List < Advice > getAdvices ( String method ) { } void clearAdvices ( ) { } public NCube ( String name ) { } public String getStatus ( ) { } public String getVersion ( ) { } public void setApplicationID ( ApplicationID appId ) { } public ApplicationID getApplicationID ( ) { } public String getName ( ) { } public T removeCell ( final Map < String , Object > coordinate ) { } public T removeCellById ( final Set < Long > coordinate ) { } public boolean containsCell ( final Map < String , Object > coordinate ) { } public boolean containsCell ( final Map < String , Object > coordinate , boolean useDefault ) { } public boolean containsCellById ( final Set < Long > coordinate ) { } public T setCell ( final T value , final Map < String , Object > coordinate ) { } public T setCellById ( final T value , final Set < Long > coordinate ) { } private void clearScopeKeyCaches ( ) { } public T getCellByIdNoExecute ( final Set < Long > coordinate ) { } public T getCell ( final Map < String , Object > coordinate ) { } public T getCell ( final Map < String , Object > coordinate , final Map < String , Object > output ) { final RuleInfo ruleInfo = NCube . getRuleInfo ( output ) ; Map < String , Object > input = validateCoordinate ( coordinate , false ) ; boolean run = true ; T lastExecutedStatementValue = null ; final List < Binding > bindings = ruleInfo . getAxisBindings ( ) ; final int depth = NCube . executionStack . get ( ) . size ( ) ; final String [ ] axisNames = axisList . keySet ( ) . toArray ( new String [ ] { } ) ; final Collection < Axis > axes = axisList . values ( ) ; while ( run ) { run = false ; final Map < String , List < Column > > columnToAxisBindings = bindCoordinateToAxisColumns ( input ) ; final Map < String , Integer > counters = NCube . getCountersPerAxis ( axisList . keySet ( ) ) ; final Map < Long , Object > cachedConditionValues = new HashMap < > ( ) ; final Map < String , Integer > conditionsFiredCountPerAxis = new HashMap < > ( ) ; try { Map < String , Object > ctx = prepareExecutionContext ( input , output ) ; do { final Binding binding = new Binding ( name , depth ) ; for ( final Axis axis : axes ) { final String axisName = axis . getName ( ) ; final Column boundColumn = columnToAxisBindings . get ( axisName ) . get ( ( ( counters . get ( axisName ) ) - 1 ) ) ; if ( ( axis . getType ( ) ) == ( AxisType . RULE ) ) { Object conditionValue ; if ( ! ( cachedConditionValues . containsKey ( boundColumn . id ) ) ) { CommandCell cmd = ( ( CommandCell ) ( boundColumn . getValue ( ) ) ) ; final Integer count = conditionsFiredCountPerAxis . get ( axisName ) ; conditionValue = ( cmd == null ) ? NCube . isZero ( count ) : cmd . execute ( ctx ) ; final boolean conditionAnswer = NCube . isTrue ( conditionValue ) ; cachedConditionValues . put ( boundColumn . id , conditionAnswer ) ; if ( conditionAnswer ) { conditionsFiredCountPerAxis . put ( axisName , ( count == null ? 1 : count + 1 ) ) ; if ( ! ( axis . isFireAll ( ) ) ) { counters . put ( axisName , 1 ) ; List < Column > boundCols = new ArrayList < > ( ) ; boundCols . add ( boundColumn ) ; columnToAxisBindings . put ( axisName , boundCols ) ; } } } else { conditionValue = cachedConditionValues . get ( boundColumn . id ) ; } <START_BUG> if ( Boolean . TRUE . equals ( conditionValue ) ) { <END_BUG> binding . bind ( axisName , boundColumn ) ; } else { break ; } } else { binding . bind ( axisName , boundColumn ) ; } } if ( ( binding . getNumBoundAxes ( ) ) == ( axisNames . length ) ) { bindings . add ( binding ) ; try { lastExecutedStatementValue = getCellById ( binding . getBoundColsForAxis ( ) , input , output ) ; binding . setValue ( lastExecutedStatementValue ) ; } catch ( RuleStop e ) { binding . setValue ( "[RuleStop]" ) ; ruleInfo . ruleStopThrown ( ) ; throw e ; } catch ( RuleJump e ) { binding . setValue ( "[RuleJump]" ) ; throw e ; } catch ( Exception e ) { String msg = e . getMessage ( ) ; if ( StringUtilities . isEmpty ( msg ) ) { msg = e . getClass ( ) . getName ( ) ; } binding . setValue ( ( ( "[" + msg ) + "]" ) ) ; throw e ; } } } while ( NCube . incrementVariableRadixCount ( counters , columnToAxisBindings , axisNames ) ) ; ensureAllRuleAxesBound ( coordinate , conditionsFiredCountPerAxis ) ; } catch ( RuleStop ignored ) { ruleInfo . ruleStopThrown ( ) ;
public class ReturnStatement extends Statement { public Expression expression ; public boolean isSynchronized ; public SubRoutineStatement [ ] subroutines ; public boolean isAnySubRoutineEscaping = false ; public LocalVariableBinding saveValueVariable ; public ReturnStatement ( Expression expr , int s , int e ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { } public void generateReturnBytecode ( CodeStream codeStream ) { } public void generateStoreSaveValueIfNecessary ( CodeStream codeStream ) { } public boolean needValue ( ) { } public void prepareSaveValueLocation ( TryStatement targetTryStatement ) { } public StringBuffer printStatement ( int tab , StringBuffer output ) { } public void resolve ( BlockScope scope ) { MethodScope methodScope = scope . methodScope ( ) ; MethodBinding methodBinding ; TypeBinding methodType = ( ( methodScope . referenceContext ) instanceof AbstractMethodDeclaration ) ? ( methodBinding = ( ( AbstractMethodDeclaration ) ( methodScope . referenceContext ) ) . binding ) == null ? null : methodBinding . returnType : VoidBinding ; TypeBinding expressionType ; if ( methodType == ( VoidBinding ) ) { if ( ( expression ) == null ) return ; if ( ( expressionType = expression . resolveType ( scope ) ) != null ) scope . problemReporter ( ) . attemptToReturnNonVoidExpression ( this , expressionType ) ; return ; } if ( ( expression ) == null ) { if ( methodType != null ) scope . problemReporter ( ) . shouldReturn ( methodType , this ) ; return ; } expression . setExpectedType ( methodType ) ; if ( ( expressionType = expression . resolveType ( scope ) ) == null ) return ; if ( expressionType == ( VoidBinding ) ) { scope . problemReporter ( ) . attemptToReturnVoidValue ( this ) ; return ; } if ( methodType == null ) return ; <START_BUG> if ( ( expressionType . isRawType ( ) ) && ( ( methodType . isBoundParameterizedType ( ) ) || ( methodType . isGenericType ( ) ) ) ) { <END_BUG> scope . problemReporter ( ) . unsafeRawConversion ( this . expression , expressionType , methodType ) ; } if ( expression . isConstantValueOfTypeAssignableToType ( expressionType , methodType ) ) { expression . computeConversion ( scope , methodType , expressionType ) ; return ; } if ( expressionType . isCompatibleWith ( methodType ) ) { expression . computeConversion ( scope , methodType , expressionType ) ; return ; } scope . problemReporter ( ) . typeMismatchError ( expressionType , methodType , expression ) ; } public void traverse ( ASTVisitor visitor , BlockScope scope ) { } }
public class PanelTest extends WicketTestCase { public PanelTest ( String name ) { } public void testRenderHomePage_1 ( ) throws Exception { boolean hit = false ; try { executeTest ( PanelPage_1 . class , "Dummy.html" ) ; } catch ( MarkupException mex ) { hit = true ; assertNotNull ( mex . getMarkupStream ( ) ) ; <START_BUG> assertTrue ( mex . getMessage ( ) . contains ( "does<seq2seq4repair_space>not<seq2seq4repair_space>have<seq2seq4repair_space>a<seq2seq4repair_space>close<seq2seq4repair_space>tag" ) ) ; <END_BUG> assertTrue ( mex . getMessage ( ) . contains ( "SimplePanel_1.html" ) ) ; } assertTrue ( "Did<seq2seq4repair_space>expect<seq2seq4repair_space>a<seq2seq4repair_space>MarkupException" , hit ) ; } public void testRenderHomePage_2 ( ) throws Exception { } public void testPanel3 ( ) throws Exception { } public void testPanel4 ( ) throws Exception { } public void testInlinePanel ( ) throws Exception { } public void testInlinePanel_2 ( ) throws Exception { } public void testInlinePanel_3 ( ) throws Exception { } public void testInlinePanel_4 ( ) throws Exception { } public void testInlinePanel_5 ( ) throws Exception { } public void testInlinePanel_6 ( ) throws Exception { } public void testPanelWithAttributeModifier ( ) throws Exception { } public void testInlinePanel_7 ( ) throws Exception { } public void testInlinePanel_8 ( ) throws Exception { } public void testStartPanel ( ) { } }
public class Publisher { private String press ; private int edition ; private Date publishDate ; private SimpleDateFormat formator = new SimpleDateFormat ( "MMMMMMMMM<seq2seq4repair_space>dd,yyyy" , Locale . ENGLISH ) ; public Publisher ( String press , int edition , Date publishDate ) { } public String getPress ( ) { } public void setPress ( String press ) { } public int getEdition ( ) { } public void setEdition ( int edition ) { } public Date getPublishDate ( ) { <START_BUG> return publishDate ; <END_BUG> } public void setPublishDate ( Date publishDate ) { } public String getGetDisplayPublishDate ( ) { } }
public class TabIdentTest { private TabIdent t ; @ Before public void init ( ) { } @ Test public void searchIdentTest ( ) { t . addVariable ( "john" , ENTIER ) ; Ident i = t . searchIdent ( "john" ) ; assertEquals ( i . getType ( ) , ENTIER ) ; assertEquals ( errorLog , "" ) ; t . addVariable ( "fail" , FONCTION ) ; assertEquals ( t . searchIdent ( "fail" ) , null ) ; <START_BUG> assertNotEquals ( errorLog , "" ) ; <END_BUG> } @ Test public void searchFnTest ( ) { } }
public class SegmentTest { @ Test public void testDistance ( ) { Vector2D start = new Vector2D ( 2 , 2 ) ; Vector2D end = new Vector2D ( ( - 2 ) , ( - 2 ) ) ; <START_BUG> Segment segment = new Segment ( start , end , new Line ( start , end ) ) ; <END_BUG> Assert . assertEquals ( FastMath . sqrt ( 2 ) , segment . distance ( new Vector2D ( 1 , ( - 1 ) ) ) , 1.0E-10 ) ; Assert . assertEquals ( FastMath . sin ( ( ( Math . PI ) / 4.0 ) ) , segment . distance ( new Vector2D ( 0 , ( - 1 ) ) ) , 1.0E-10 ) ; Assert . assertEquals ( FastMath . sqrt ( 8 ) , segment . distance ( new Vector2D ( 0 , 4 ) ) , 1.0E-10 ) ; Assert . assertEquals ( FastMath . sqrt ( 8 ) , segment . distance ( new Vector2D ( 0 , ( - 4 ) ) ) , 1.0E-10 ) ; } }
public abstract class MarkupContainer extends Component { private static final long serialVersionUID = 1L ; private static final Logger log = LoggerFactory . getLogger ( MarkupContainer . class ) ; private Object children ; private transient MarkupStream markupStream ; public MarkupContainer ( final String id ) { } public MarkupContainer ( final String id , IModel < ? > model ) { } public final MarkupContainer add ( final Component ... childs ) { } public final MarkupContainer addOrReplace ( final Component ... childs ) { } public final boolean autoAdd ( final Component component , final MarkupStream markupStream ) { } @ Deprecated public final boolean autoAdd ( final Component component ) { } public final boolean contains ( final Component component , final boolean recurse ) { } @ Override public final Component get ( final String path ) { } public MarkupStream getAssociatedMarkupStream ( final boolean throwException ) { } public final MarkupStream getMarkupStream ( ) { } public String getMarkupType ( ) { } public void internalAdd ( final Component child ) { } public boolean isTransparentResolver ( ) { } public Iterator < ? extends Component > iterator ( ) { } @ SuppressWarnings ( "unchecked" ) public final Iterator < Component > iterator ( Comparator < Component > comparator ) { } public final < C extends Component > IResourceStream newMarkupResourceStream ( Class < C > containerClass ) { } public void remove ( final Component component ) { } public final void remove ( final String id ) { } public final void removeAll ( ) { } public final void renderAssociatedMarkup ( final String openTagName , final String exceptionMessage ) { } public final MarkupContainer replace ( final Component child ) { } @ Override public MarkupContainer setDefaultModel ( final IModel < ? > model ) { } public final int size ( ) { } @ Override public String toString ( ) { } @ Override public String toString ( final boolean detailed ) { final StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "[MarkupContainer<seq2seq4repair_space>" ) ; <START_BUG> buffer . append ( super . toString ( true ) ) ; <END_BUG> if ( detailed ) { if ( ( getMarkupStream ( ) ) != null ) { buffer . append ( ( ",<seq2seq4repair_space>markupStream<seq2seq4repair_space>=<seq2seq4repair_space>" + ( getMarkupStream ( ) ) ) ) ; } if ( ( children_size ( ) ) != 0 ) { buffer . append ( ",<seq2seq4repair_space>children<seq2seq4repair_space>=<seq2seq4repair_space>" ) ; final int size = children_size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { final Component child = children_get ( i ) ; if ( i != 0 ) { buffer . append ( '<seq2seq4repair_space>' ) ; } buffer . append ( child . toString ( ) ) ; } } } buffer . append ( ']' ) ; return buffer . toString ( ) ; } public final < S extends Component > Object visitChildren ( final Class < ? > clazz , final IVisitor < S > visitor ) { } public final Object visitChildren ( final IVisitor < Component > visitor ) { } private final void addedComponent ( final Component component ) { } private final void children_add ( final Component child ) { } public final Component get ( int index ) { } private final Component children_get ( int index ) { } private final Object postprocess ( Object object , boolean reconstruct , MarkupContainer parent , int index ) { } private final Object children_get ( int index , boolean reconstruct ) { } private final String getId ( Object object ) { } private final Component children_get ( final String id ) { } private final int children_indexOf ( Component child ) { } private final Component children_remove ( Component component ) { } private final Component children_remove ( int index ) { } private final Object children_set ( int index , Object child , boolean reconstruct ) { } private final Component children_set ( int index , Component child ) { } private final int children_size ( ) { } private final Component put ( final Component child ) { } private final void removedComponent ( final Component component ) { } private final void renderNext ( final MarkupStream markupStream ) { } @ Override protected final MarkupStream findMarkupStream ( ) { } @ Override protected void onComponentTagBody ( final MarkupStream markupStream , final ComponentTag openTag ) { } @ Override protected void onRender ( final MarkupStream markupStream ) { } protected void renderAll ( final MarkupStream markupStream ) { } protected final void renderComponentTagBody ( final MarkupStream markupStream , final ComponentTag openTag ) { } @ Override protected final void setMarkupStream ( final MarkupStream markupStream ) { } private static class ComponentSourceEntry extends org . apache . wicket . ComponentSourceEntry { private ComponentSourceEntry ( MarkupContainer container , Component component , IComponentSource componentSource ) { } private static final long serialVersionUID = 1L ; @ Override protected void setChild ( MarkupContainer parent , int index , Component child ) { } } @ Override void detachChildren ( ) { } @ Override void internalMarkRendering ( boolean setRenderingFlag ) { } private Component [ ] copyChildren ( ) { } @ Override void onBeforeRenderChildren ( ) { } @ Override void onAfterRenderChildren ( ) { } public boolean hasAssociatedMarkup ( ) { } @ Override void setRenderAllowed ( ) { } private static class ChildList extends AbstractList < Object > implements IClusterable { private static final long serialVersionUID = - 7861580911447631127L ; private int size ; private Object [ ] childs ; public ChildList ( Object children ) { } @ Override public Object get ( int index ) { } @ Override public int size ( ) { } @ Override public boolean add ( Object o ) { } @ Override public void add ( int index , Object element ) { }
public class ToolTip extends Widget { Shell parent ; Shell tip ; TrayItem item ; int x ; int y ; int [ ] borderPolygon ; boolean spikeAbove ; boolean autohide ; Listener listener ; Listener parentListener ; TextLayout layoutText ; TextLayout layoutMessage ; Region region ; Font boldFont ; Runnable runnable ; static final int BORDER = 5 ; static final int PADDING = 5 ; static final int INSET = 4 ; static final int TIP_HEIGHT = 20 ; static final int IMAGE_SIZE = 16 ; static final int DELAY = 10000 ; public ToolTip ( Shell parent , int style ) { } static int checkStyle ( int style ) { } public void addSelectionListener ( SelectionListener listener ) { } void configure ( ) { } public boolean getAutoHide ( ) { } Point getSize ( int maxWidth ) { } public String getMessage ( ) { } public Shell getParent ( ) { } public String getText ( ) { } public boolean getVisible ( ) { } public boolean isVisible ( ) { } void onDispose ( Event event ) { } void onMouseDown ( Event event ) { <START_BUG> notifyListeners ( Selection , new Event ( ) ) ; <END_BUG> setVisible ( false ) ; } void onPaint ( Event event ) { } public void removeSelectionListener ( SelectionListener listener ) { } public void setAutoHide ( boolean autohide ) { } public void setLocation ( int x , int y ) { } public void setLocation ( Point location ) { } public void setMessage ( String string ) { } public void setText ( String string ) { } public void setVisible ( boolean visible ) { } }
public class CameraActivity extends Activity implements onBtnClickedListener , onSettingsInterface , Preference . OnPreferenceChangeListener , SurfaceHolder . Callback { private static final String TAG = "CameraActivity" ; private Camera mCamera ; private int mCameraId ; private Parameters mParams ; private SurfaceHolder mSurfaceHolder ; private CameraSettings mSettings ; private boolean mOpenCameraFail = false ; private boolean isPreviewing = false ; private ImageSaverThread mImageSaver ; private CameraFragment mCameraFragment ; private SettingFragment mSettingFragment ; private Preference mPictureSizePref ; private boolean isInitialedFlag = false ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } @ Override protected void onResume ( ) { } @ Override protected void onStart ( ) { } @ Override protected void onPause ( ) { } @ Override protected void onStop ( ) { } @ Override protected void onDestroy ( ) { } @ Override public void onSettingsBtnClicked ( ) { } @ Override public boolean onPreferenceChange ( Preference preference , Object newValue ) { } @ Override public void initialPref ( Preference pref ) { } @ Override public void surfaceCreated ( SurfaceHolder holder ) { } @ Override public void surfaceChanged ( SurfaceHolder holder , int format , int width , int height ) { } @ Override public void surfaceDestroyed ( SurfaceHolder holder ) { } public void openSettingsFlag ( ) { } public void doStartPreview ( SurfaceHolder holder ) { } public void doStopPreview ( ) { } Thread mCameraOpenThread = new Thread ( new Runnable ( ) { public void run ( ) { } } ) ; public void openCamera ( ) { } public void releaseCamera ( ) { } public void doTakePicture ( ) { } private Camera . ShutterCallback mShutterCallback = new CameraActivity . ShutterCallback ( ) ; private PictureCallback mRowPicture = new CameraActivity . RawPictureCallback ( ) ; private final class ShutterCallback implements Camera . ShutterCallback { public void onShutter ( ) { } } private final class RawPictureCallback implements Camera . PictureCallback { public void onPictureTaken ( byte [ ] rawData , Camera camera ) { } } private PictureCallback mPicture = new Camera . PictureCallback ( ) { @ Override public void onPictureTaken ( byte [ ] data , Camera camera ) { } } ; public void setFocusMode ( ) { } public void zoom ( int progress ) { } public void zoom ( boolean isUp ) { } public void changePicSize ( String size ) { } public void onBackPressed ( ) { } public boolean onKeyDown ( int keyCode , KeyEvent event ) { switch ( keyCode ) { case KeyEvent . KEYCODE_VOLUME_DOWN : zoom ( false ) ; return true ; case KeyEvent . KEYCODE_VOLUME_UP : zoom ( true ) ; return true ; } <START_BUG> return super . onKeyUp ( keyCode , event ) ; <END_BUG> } }
public class HeadToHeadActivity extends BaseToolbarListActivity { private static final String CNAME = "com.garpr.android.activities.HeadToHeadActivity" ; private static final String EXTRA_PLAYER = ( HeadToHeadActivity . CNAME ) + ".EXTRA_PLAYER" ; private static final String EXTRA_OPPONENT = ( HeadToHeadActivity . CNAME ) + ".EXTRA_OPPONENT" ; private static final String KEY_BUNDLE = "KEY_BUNDLE" ; private static final String KEY_SHOWING = "KEY_SHOWING" ; private static final String TAG = "HeadToHeadActivity" ; private ArrayList < HeadToHeadActivity . ListItem > mListItems ; private ArrayList < HeadToHeadActivity . ListItem > mListItemsShown ; private ArrayList < HeadToHeadActivity . ListItem > mLoseListItems ; private ArrayList < HeadToHeadActivity . ListItem > mWinListItems ; private boolean mSetMenuItemsVisible ; private HeadToHeadBundle mBundle ; private MenuItem mShow ; private MenuItem mShowAll ; private MenuItem mShowLoses ; private MenuItem mShowWins ; private Player mOpponent ; private Player mPlayer ; private Result mShowing ; public static void start ( final Activity activity , final Player player , final Player opponent ) { } private void createListItems ( ) { } private ArrayList < HeadToHeadActivity . ListItem > createSortedListItems ( final Result result ) { } private void fetchMatches ( ) { } @ Override protected String getActivityName ( ) { } @ Override protected String getErrorText ( ) { } @ Override protected int getOptionsMenu ( ) { } private boolean isMenuNull ( ) { } @ Override protected void onCreate ( final Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setTitle ( getString ( x_vs_y , mPlayer . getName ( ) , mOpponent . getName ( ) ) ) ; if ( ( savedInstanceState != null ) && ( ! ( savedInstanceState . isEmpty ( ) ) ) ) { mBundle = savedInstanceState . getParcelable ( HeadToHeadActivity . KEY_BUNDLE ) ; mShowing = savedInstanceState . getParcelable ( HeadToHeadActivity . KEY_SHOWING ) ; } if ( ( mBundle ) == null ) { fetchMatches ( ) ; } else { <START_BUG> createListItems ( ) ; <END_BUG> } } @ Override public boolean onOptionsItemSelected ( final MenuItem item ) { } @ Override public boolean onPrepareOptionsMenu ( final Menu menu ) { } @ Override public void onRefresh ( ) { } @ Override protected void onSaveInstanceState ( final Bundle outState ) { } private void prepareList ( ) { } @ Override protected void readIntentData ( final Intent intent ) { } @ Override protected void setAdapter ( final BaseListAdapter adapter ) { } @ Override protected boolean showDrawerIndicator ( ) { } private void show ( final Result result ) { } private void showMenuItems ( ) { } private static final class ListItem { private Match mMatch ; private String mDate ; private String mHeader ; private HeadToHeadActivity . ListItem . Type mType ; private static HeadToHeadActivity . ListItem createDate ( final String date ) { } private static HeadToHeadActivity . ListItem createHeader ( final String header ) { } private static HeadToHeadActivity . ListItem createTournament ( final Match match ) { } @ Override public boolean equals ( final Object o ) { } private boolean isDate ( ) { } private boolean isHeader ( ) { } private boolean isTournament ( ) { } @ Override public String toString ( ) { } private static enum Type { DATE , HEADER , TOURNAMENT ; @ Override public String toString ( ) { } } } private final class MatchesAdapter extends BaseListAdapter { private static final String TAG = "MatchesAdapter" ; private final int mColorLose ; private final int mColorWin ; private MatchesAdapter ( ) { } private void bindDateViewHolder ( final HeadToHeadActivity . DateViewHolder holder , final HeadToHeadActivity . ListItem listItem ) { } private void bindHeaderViewHolder ( final HeadToHeadActivity . HeaderViewHolder holder , final HeadToHeadActivity . ListItem listItem ) { } private void bindTournamentViewHolder ( final HeadToHeadActivity . TournamentViewHolder holder , final HeadToHeadActivity . ListItem listItem ) { } @ Override public String getAdapterName ( ) { } @ Override public int getItemCount ( ) { } @ Override public long getItemId ( final int position ) { } @ Override public int getItemViewType ( final int position ) { } @ Override public void onBindViewHolder ( final RecyclerView . ViewHolder holder , final int position ) { } @ Override public ViewHolder onCreateViewHolder ( final ViewGroup parent , final int viewType ) { } } private static final class DateViewHolder extends RecyclerView . ViewHolder { private final TextView mDate ; private DateViewHolder ( final View view ) { } } private static final class HeaderViewHolder extends RecyclerView . ViewHolder { private final TextView mHeader ; private HeaderViewHolder ( final View view ) { } } private static final class TournamentViewHolder extends RecyclerView . ViewHolder { private final TextView mDate ; private final TextView mName ; private TournamentViewHolder ( final View view ) { } } }
public class Wizard extends Panel implements IWizard , IWizardModelListener { public static final String BUTTONS_ID = "buttons" ; public static final String FEEDBACK_ID = "feedback" ; public static final String HEADER_ID = "header" ; public static final String OVERVIEW_ID = "overview" ; public static final String FORM_ID = "form" ; public static final String VIEW_ID = "view" ; private static final long serialVersionUID = 1L ; private IWizardStep activeStep ; private Form form ; private IWizardModel wizardModel ; public Wizard ( String id ) { } public Wizard ( String id , boolean addDefaultCssStyle ) { } public Wizard ( String id , IWizardModel wizardModel ) { } public Wizard ( String id , IWizardModel wizardModel , boolean addDefaultCssStyle ) { } public final void addDefaultCssStyle ( ) { } public final IWizardStep getActiveStep ( ) { } public Form getForm ( ) { } public final IWizardModel getWizardModel ( ) { } public boolean isVersioned ( ) { } public void onActiveStepChanged ( IWizardStep newStep ) { } public void onCancel ( ) { } public void onFinish ( ) { } protected void init ( IWizardModel wizardModel ) { } protected Component newButtonBar ( String id ) { } protected FeedbackPanel newFeedbackPanel ( String id ) { } protected Form newForm ( String id ) { } protected void onBeforeRender ( ) { super . onBeforeRender ( ) ; <START_BUG> Component buttonBar = get ( Wizard . BUTTONS_ID ) ; <END_BUG> if ( buttonBar instanceof IDefaultButtonProvider ) { IFormSubmittingComponent defaultButton = ( ( IDefaultButtonProvider ) ( buttonBar ) ) . getDefaultButton ( wizardModel ) ; form . setDefaultButton ( defaultButton ) ; } } protected Component newOverviewBar ( String id ) { } }
public class WorkingSetManager implements IWorkingSetManager { private static final String WORKING_SET_STATE_FILENAME = "workingsets.xml" ; private static final int MRU_SIZE = 5 ; private SortedSet workingSets = new TreeSet ( new WorkingSetComparator ( ) ) ; private List recentWorkingSets = new ArrayList ( ) ; private ListenerList propertyChangeListeners = new ListenerList ( ) ; public void addRecentWorkingSet ( IWorkingSet workingSet ) { } public void addWorkingSet ( IWorkingSet workingSet ) { } public void addPropertyChangeListener ( IPropertyChangeListener listener ) { } public IWorkingSet createWorkingSet ( String name , IAdaptable [ ] elements ) { } public IWorkingSetEditWizard createWorkingSetEditWizard ( IWorkingSet workingSet ) { } public IWorkingSetSelectionDialog createWorkingSetSelectionDialog ( Shell parent ) { } public IWorkingSetSelectionDialog createWorkingSetSelectionDialog ( Shell parent , boolean multi ) { } public boolean equals ( Object object ) { } private void firePropertyChange ( String changeId , Object oldValue , Object newValue ) { } public IWorkingSet [ ] getRecentWorkingSets ( ) { } public IWorkingSet getWorkingSet ( String name ) { } public int hashCode ( ) { } public IWorkingSet [ ] getWorkingSets ( ) { } private File getWorkingSetStateFile ( ) { } public void removePropertyChangeListener ( IPropertyChangeListener listener ) { } public void removeWorkingSet ( IWorkingSet workingSet ) { } private void restoreMruList ( IMemento memento ) { } public void restoreState ( ) { File stateFile = getWorkingSetStateFile ( ) ; if ( stateFile . exists ( ) ) { try { FileInputStream input = new FileInputStream ( stateFile ) ; <START_BUG> InputStreamReader reader = new InputStreamReader ( input , "utf-8" ) ; <END_BUG> IMemento memento = XMLMemento . createReadRoot ( reader ) ; restoreWorkingSetState ( memento ) ; restoreMruList ( memento ) ; reader . close ( ) ; } catch ( IOException e ) { MessageDialog . openError ( ( ( Shell ) ( null ) ) , WorkbenchMessages . getString ( "ProblemRestoringWorkingSetState.title" ) , WorkbenchMessages . getString ( "ProblemRestoringWorkingSetState.message" ) ) ; } catch ( WorkbenchException e ) { ErrorDialog . openError ( ( ( Shell ) ( null ) ) , WorkbenchMessages . getString ( "ProblemRestoringWorkingSetState.title" ) , WorkbenchMessages . getString ( "ProblemRestoringWorkingSetState.message" ) , e . getStatus ( ) ) ; } } } private IWorkingSet restoreWorkingSet ( IMemento memento ) { } private void restoreWorkingSetState ( IMemento memento ) { } private void saveState ( ) { } private void saveMruList ( IMemento memento ) { } private void saveWorkingSetState ( IMemento memento ) { } public void workingSetChanged ( IWorkingSet changedWorkingSet , String propertyChangeId ) { } }
@ Controller public class ProfileController { @ RequestMapping ( "/profile" ) public String getProfile ( String id , Model model ) throws JSONException { SteamProfile profile = null ; try { profile = Profiles . getSteamUser ( id ) ; } catch ( Exception e ) { if ( e instanceof APIException ) { <START_BUG> return "error?=" + ( e . getMessage ( ) ) ; <END_BUG> } } if ( profile == null ) { return "index" ; } model . addAttribute ( "full_avatar_url" , profile . getFullAvatarUrl ( ) ) ; model . addAttribute ( "personal_name" , profile . getPersonaName ( ) ) ; model . addAttribute ( "url" , profile . getSteamCommunityUrl ( ) ) ; if ( ( ( profile . getCountryCode ( ) ) != null ) && ( steam_countries . has ( profile . getCountryCode ( ) ) ) ) { JSONObject countryData = steam_countries . getJSONObject ( profile . getCountryCode ( ) ) ; model . addAttribute ( "country" , countryData . getString ( "name" ) ) ; System . out . println ( ( ( profile . getCountryCode ( ) . toLowerCase ( ) ) + ".png" ) ) ; model . addAttribute ( "country_flag" , ( ( "/assets/images/country_flags/" + ( profile . getCountryCode ( ) . toLowerCase ( ) ) ) + ".png" ) ) ; } else { model . addAttribute ( "country" , "" ) ; model . addAttribute ( "country_flag" , "/assets/images/country_flags/_United<seq2seq4repair_space>Nations.png" ) ; } List < SteamGame > games = null ; try { games = Games . getPlayedSteamGames ( id ) ; } catch ( Exception e ) { if ( e instanceof APIException ) { return "error?=" + ( e . getMessage ( ) ) ; } } if ( games == null ) { return "index" ; } model . addAttribute ( "games" , games ) ; List < GameAchievement > achievements = Achievements . getUnlockedAchievements ( id ) ; model . addAttribute ( "achievements" , achievements ) ; return "profile" ; } No newline ; at end ; of file ; }
public class ExternalLink extends AbstractLink { private static final long serialVersionUID = 1L ; private final IModel < ? > label ; private boolean contextRelative = false ; private PopupSettings popupSettings = null ; public ExternalLink ( final String id , final String href , final String label ) { } public ExternalLink ( final String id , final String href ) { } public ExternalLink ( final String id , final IModel < String > href , final IModel < ? > label ) { } public ExternalLink ( final String id , final IModel < String > href ) { } public final PopupSettings getPopupSettings ( ) { } public final ExternalLink setPopupSettings ( final PopupSettings popupSettings ) { } @ Override protected void onComponentTag ( final ComponentTag tag ) { super . onComponentTag ( tag ) ; if ( ( isLinkEnabled ( ) ) == false ) { disableLink ( tag ) ; } else if ( ( getDefaultModel ( ) ) != null ) { Object hrefValue = getDefaultModelObject ( ) ; if ( hrefValue != null ) { String url = hrefValue . toString ( ) ; if ( contextRelative ) { if ( ( ( url . length ( ) ) > 0 ) && ( ( url . charAt ( 0 ) ) == '/' ) ) { url = url . substring ( 1 ) ; } <START_BUG> url = UrlUtils . rewriteToContextRelative ( url , RequestCycle . get ( ) . getRequest ( ) ) ; <END_BUG> } if ( ( ( tag . getName ( ) . equalsIgnoreCase ( "a" ) ) || ( tag . getName ( ) . equalsIgnoreCase ( "link" ) ) ) || ( tag . getName ( ) . equalsIgnoreCase ( "area" ) ) ) { tag . put ( "href" , Strings . replaceAll ( url , "&" , "&amp;" ) ) ; if ( ( popupSettings ) != null ) { tag . put ( "onclick" , popupSettings . getPopupJavaScript ( ) ) ; } } else { if ( ( popupSettings ) != null ) { popupSettings . setTarget ( ( ( "'" + url ) + "'" ) ) ; String popupScript = popupSettings . getPopupJavaScript ( ) ; tag . put ( "onclick" , popupScript ) ; } else { tag . put ( "onclick" , ( ( "window.location.href='" + url ) + "';return<seq2seq4repair_space>false;" ) ) ; } } } } } @ Override protected void onComponentTagBody ( final MarkupStream markupStream , final ComponentTag openTag ) { } public boolean isContextRelative ( ) { } public ExternalLink setContextRelative ( final boolean contextRelative ) { } public IModel < ? > getLabel ( ) { } }
public class IntervalConditionalEvaluator implements IEvaluator < IntervalDomainValue , IntervalDomainState , CodeBlock , IBoogieVar > { private final Set < String > mVariables ; private IEvaluator < IntervalDomainValue , IntervalDomainState , CodeBlock , IBoogieVar > mConditionEvaluator ; private IEvaluator < IntervalDomainValue , IntervalDomainState , CodeBlock , IBoogieVar > mNegatedConditionEvaluator ; private IEvaluator < IntervalDomainValue , IntervalDomainState , CodeBlock , IBoogieVar > mIfEvaluator ; private IEvaluator < IntervalDomainValue , IntervalDomainState , CodeBlock , IBoogieVar > mElseEvaluator ; protected IntervalConditionalEvaluator ( ) { } @ Override public List < IEvaluationResult < IntervalDomainValue > > evaluate ( IntervalDomainState currentState ) { } @ Override public void addSubEvaluator ( IEvaluator < IntervalDomainValue , IntervalDomainState , CodeBlock , IBoogieVar > evaluator ) { } @ Override public Set < String > getVarIdentifiers ( ) { } @ Override public boolean hasFreeOperands ( ) { } @ Override public boolean containsBool ( ) { <START_BUG> return true ; <END_BUG> } @ Override public String toString ( ) { } @ Override public List < IntervalDomainState > inverseEvaluate ( IEvaluationResult < IntervalDomainValue > computedValue , IntervalDomainState currentState ) { } }
public class Text extends Scrollable { int txnObject ; int txnFrameID ; int textLimit = Text . LIMIT ; int tabs = 8 ; char echoCharacter ; boolean doubleClick ; String hiddenText ; ControlEditTextSelectionRec selection ; public static final int LIMIT ; public static final String DELIMITER ; static final char PASSWORD = '¥' ; public Text ( Composite parent , int style ) { } public void addModifyListener ( ModifyListener listener ) { } public void addSelectionListener ( SelectionListener listener ) { } public void addVerifyListener ( VerifyListener listener ) { } public void append ( String string ) { } static int checkStyle ( int style ) { } int callFocusEventHandler ( int nextHandler , int theEvent ) { } public void clearSelection ( ) { } public Point computeSize ( int wHint , int hHint , boolean changed ) { } public Rectangle computeTrim ( int x , int y , int width , int height ) { } public void copy ( ) { } void copy ( char [ ] buffer ) { } void createHandle ( ) { } ScrollBar createScrollBar ( int style ) { } void createWidget ( ) { } public void cut ( ) { } Color defaultBackground ( ) { } Color defaultForeground ( ) { } void drawBackground ( int control , int context ) { if ( ! ( OS . HIVIEW ) ) { <START_BUG> drawFocus ( control , context , ( ( hasFocus ( ) ) && ( drawFocusRing ( ) ) ) , hasBorder ( ) , getParentBackground ( ) , inset ( ) ) ; <END_BUG> } } void drawWidget ( int control , int context , int damageRgn , int visibleRgn , int theEvent ) { } public int getCaretLineNumber ( ) { } public Point getCaretLocation ( ) { } public int getCaretPosition ( ) { } public int getCharCount ( ) { } String getClipboardText ( ) { } public boolean getDoubleClickEnabled ( ) { } public char getEchoChar ( ) { } public boolean getEditable ( ) { } Rect getInset ( ) { } public int getLineCount ( ) { } public String getLineDelimiter ( ) { } public int getLineHeight ( ) { } public int getOrientation ( ) { } public Point getSelection ( ) { } public int getSelectionCount ( ) { } public String getSelectionText ( ) { } public int getTabs ( ) { } public String getText ( ) { } public String getText ( int start , int end ) { } char [ ] getEditText ( int start , int end , boolean hidden ) { } public int getTextLimit ( ) { } public int getTopIndex ( ) { } public int getTopPixel ( ) { } String getTXNText ( int iStartOffset , int iEndOffset ) { } Rect inset ( ) { } public void insert ( String string ) { } void insertEditText ( String string ) { } int kEventControlActivate ( int nextHandler , int theEvent , int userData ) { } int kEventControlBoundsChanged ( int nextHandler , int theEvent , int userData ) { } int kEventControlClick ( int nextHandler , int theEvent , int userData ) { } int kEventControlDeactivate ( int nextHandler , int theEvent , int userData ) { } int kEventControlGetFocusPart ( int nextHandler , int theEvent , int userData ) { } int kEventMouseDown ( int nextHandler , int theEvent , int userData ) { } int kEventControlSetCursor ( int nextHandler , int theEvent , int userData ) { } int kEventControlSetFocusPart ( int nextHandler , int theEvent , int userData ) { } int kEventUnicodeKeyPressed ( int nextHandler , int theEvent , int userData ) { } org . eclipse . swt . internal . carbon . Point measureSpace ( ) { } public void paste ( ) { } void releaseWidget ( ) { } public void removeModifyListener ( ModifyListener listener ) { } public void removeSelectionListener ( SelectionListener listener ) { } public void removeVerifyListener ( VerifyListener listener ) { } void resetVisibleRegion ( int control ) { } public void selectAll ( ) { } boolean sendKeyEvent ( int type , Event event ) { } void setBackground ( float [ ] color ) { } int setBounds ( int x , int y , int width , int height , boolean move , boolean resize , boolean events ) { } public void setDoubleClickEnabled ( boolean doubleClick ) { } public void setEchoChar ( char echo ) { } public void setEditable ( boolean editable ) { } void setForeground ( float [ ] color ) { } void setFontStyle ( Font font ) { } public void setOrientation ( int orientation ) { } public void setSelection ( int start ) { } public void setSelection ( int start , int end ) { } public void setSelection ( Point selection ) { } public void setTabs ( int tabs ) { } public void setText ( String string ) { } void setEditText ( String string ) { } void setTXNBounds ( ) { } void setTXNText ( int iStartOffset , int iEndOffset , String string ) { } public void setTextLimit ( int limit ) { } public void setTopIndex ( int index ) { } public void showSelection ( ) { } int traversalCode ( int key , int theEvent ) { } String verifyText ( String string , int start , int end , Event keyEvent ) { } }
public class EslClient { private String baseURL ; private PackageService packageService ; private SessionService sessionService ; private FieldSummaryService fieldSummaryService ; private AuditService auditService ; private EventNotificationService eventNotificationService ; private AuthenticationTokensService authenticationTokensService ; private GroupService groupService ; private CustomFieldService customFieldService ; private AccountService accountService ; private ApprovalService approvalService ; private ReminderService reminderService ; private TemplateService templateService ; private AttachmentRequirementService attachmentRequirementService ; private LayoutService layoutService ; private QRCodeService qrCodeService ; public EslClient ( String apiKey , String baseURL ) { } public EslClient ( String apiKey , String baseURL , boolean allowAllSSLCertificates ) { } public EslClient ( String apiKey , String baseURL , ProxyConfiguration proxyConfiguration ) { } public EslClient ( String apiKey , String baseURL , boolean allowAllSSLCertificates , ProxyConfiguration proxyConfiguration ) { } private void init ( RestClient client ) { } String getBaseURL ( ) { } public PackageService getPackageService ( ) { } @ SuppressWarnings ( "unused" ) public SessionService getSessionService ( ) { } public FieldSummaryService getFieldSummaryService ( ) { } @ SuppressWarnings ( "unused" ) public AuditService getAuditService ( ) { } public EventNotificationService getEventNotificationService ( ) { } public AuthenticationTokensService getAuthenticationTokensService ( ) { } public CustomFieldService getCustomFieldService ( ) { } public PackageId createPackage ( DocumentPackage documentPackage ) { } public void updatePackage ( PackageId packageId , DocumentPackage documentPackage ) { } public void changePackageStatusToDraft ( PackageId packageId ) { } public PackageId createPackageOneStep ( DocumentPackage documentPackage ) { } private void validateSignatures ( DocumentPackage documentPackage ) { } private void validateMixingSignatureAndAcceptance ( Document document ) { } private boolean checkAcceptanceSignatureStyle ( Document document ) { } private void setSdkVersion ( DocumentPackage documentPackage ) { } private boolean isSdkVersionSet ( DocumentPackage documentPackage ) { <START_BUG> if ( ( documentPackage . getAttributes ( ) ) == null ) { <END_BUG> return false ; } return documentPackage . getAttributes ( ) . getContents ( ) . containsKey ( "sdk" ) ; } public PackageId createAndSendPackage ( DocumentPackage documentPackage ) { } public PackageId createPackageFromTemplate ( DocumentPackage documentPackage , PackageId packageId ) { } public void sendPackage ( PackageId id ) { } public List < FieldSummary > getFieldValues ( PackageId packageId ) { } @ Deprecated public SessionToken createSenderSessionToken ( ) { } @ Deprecated public SessionToken createSignerSessionToken ( PackageId packageId , String signerId ) throws EslException { } @ Deprecated public SessionToken createSessionToken ( PackageId packageId , String signerId ) throws EslException { } public DocumentPackage getPackage ( PackageId packageId ) { } public byte [ ] downloadDocument ( PackageId packageId , String documentId ) { } public byte [ ] downloadOriginalDocument ( PackageId packageId , String documentId ) { } public byte [ ] downloadEvidenceSummary ( PackageId packageId ) { } public byte [ ] downloadZippedDocuments ( PackageId packageId ) { } public SigningStatus getSigningStatus ( PackageId packageId , SignerId signerId , DocumentId documentId ) { } public Document uploadDocument ( String fileName , byte [ ] fileContent , Document document , DocumentPackage documentPackage ) { } public Document uploadDocument ( Document document , DocumentPackage documentPackage ) { } public GroupService getGroupService ( ) { } public AccountService getAccountService ( ) { } public ApprovalService getApprovalService ( ) { } public ReminderService getReminderService ( ) { } public TemplateService getTemplateService ( ) { } public AttachmentRequirementService getAttachmentRequirementService ( ) { } public LayoutService getLayoutService ( ) { } public QRCodeService getQrCodeService ( ) { } No newline ; at end ; of file ; }
public class AjaxGetSprintBacklogDateInfoActionTest extends MockStrutsTestCase { private CreateProject mCP ; private CreateSprint mCS ; private Configuration mConfig ; private IProject mIProject ; private long mSprintId ; private IUserSession mUserSession ; private final String mActionPath = "/AjaxGetSprintBacklogDateInfo" ; public AjaxGetSprintBacklogDateInfoActionTest ( String testName ) { } protected void setUp ( ) throws Exception { } protected void tearDown ( ) throws Exception { } public void testGetSprintBacklogDateInfoAction ( ) { List < String > sprintIdList = mCS . getSprintIDList ( ) ; String projectName = mIProject . getName ( ) ; request . setHeader ( "Referer" , ( "?PID=" + projectName ) ) ; addRequestParameter ( "SprintID" , sprintIdList . get ( 0 ) ) ; request . getSession ( ) . setAttribute ( "UserSession" , mConfig . getUserSession ( ) ) ; actionPerform ( ) ; verifyNoActionErrors ( ) ; verifyNoActionMessages ( ) ; int availableDays = new ntut . csie . ezScrum . web . logic . SprintBacklogLogic ( mIProject , mUserSession , String . valueOf ( mSprintId ) ) . getSprintAvailableDays ( mSprintId ) ; <START_BUG> List < String > dateList = getWorkDate ( mCS . Today , availableDays ) ; <END_BUG> StringBuilder expectedResponseText = new StringBuilder ( ) ; expectedResponseText . append ( "{\"Dates\":[" ) ; for ( int i = 0 ; i < ( dateList . size ( ) ) ; i ++ ) { expectedResponseText . append ( "{\"Id\":\"Date_" ) . append ( ( i + 1 ) ) . append ( "\"," ) . append ( "\"Name\":\"" ) . append ( dateList . get ( i ) ) . append ( "\"}" ) ; if ( i != ( ( dateList . size ( ) ) - 1 ) ) { expectedResponseText . append ( "," ) ; } } expectedResponseText . append ( "]}" ) ; String actualResponseText = response . getWriterBuffer ( ) . toString ( ) ; assertEquals ( expectedResponseText . toString ( ) , actualResponseText ) ; } private List < String > getWorkDate ( Date startDate , int availableDays ) { } }
public final class Program { String name ; String command ; String iconName ; Program ( ) { } public static Program findProgram ( String extension ) { } public static String [ ] getExtensions ( ) { } static String getKeyValue ( String string , boolean expand ) { } static Program getProgram ( String key ) { String name = Program . getKeyValue ( key , false ) ; if ( ( name == null ) || ( ( name . length ( ) ) == 0 ) ) { name = key ; } String DEFAULT_COMMAND = "\\shell" ; String defaultCommand = Program . getKeyValue ( ( key + DEFAULT_COMMAND ) , true ) ; <START_BUG> if ( defaultCommand == null ) <END_BUG> defaultCommand = "open" ; String COMMAND = ( "\\shell\\" + defaultCommand ) + "\\command" ; String command = Program . getKeyValue ( ( key + COMMAND ) , true ) ; if ( ( command == null ) || ( ( command . length ( ) ) == 0 ) ) return null ; String DEFAULT_ICON = "\\DefaultIcon" ; String iconName = Program . getKeyValue ( ( key + DEFAULT_ICON ) , true ) ; if ( ( iconName == null ) || ( ( iconName . length ( ) ) == 0 ) ) return null ; Program program = new Program ( ) ; program . name = name ; program . command = command ; program . iconName = iconName ; return program ; } public static Program [ ] getPrograms ( ) { } public static boolean launch ( String fileName ) { } public boolean execute ( String fileName ) { } public ImageData getImageData ( ) { } public String getName ( ) { } public boolean equals ( Object other ) { } public int hashCode ( ) { } public String toString ( ) { } }
class SecurityBreachHandler { private final Logger logger = LogManager . getLogger ( this . getClass ( ) ) ; private final String toAddress ; private static boolean exists = false ; public static SecurityBreachHandler createBreachHandler ( String toAddress ) throws IllegalAccessException { } private SecurityBreachHandler ( String toAddress ) { } public void handleBreach ( Exception e , Class [ ] classesStack ) { } private void sendErrorReport ( String subject , Exception e , Class [ ] classesStack ) { } private String generateContent ( Exception excep , Class [ ] classesStack ) { String intro = "An<seq2seq4repair_space>attempted<seq2seq4repair_space>security<seq2seq4repair_space>breach<seq2seq4repair_space>was<seq2seq4repair_space>discovered<seq2seq4repair_space>in<seq2seq4repair_space>Izou:<seq2seq4repair_space>\n\n\n" ; String exception = "EXCEPTION:<seq2seq4repair_space>\n\n" ; <START_BUG> exception += excep . getMessage ( ) ; <END_BUG> StackTraceElement [ ] stackTraceElements = excep . getStackTrace ( ) ; for ( StackTraceElement element : stackTraceElements ) { exception += ( element . toString ( ) ) + "\n" ; } exception += "\n\n\n" ; String classesStackString = "" ; if ( classesStack != null ) { classesStackString = "CLASS<seq2seq4repair_space>STACK:\n\n" ; for ( int i = 0 ; i < ( classesStack . length ) ; i ++ ) { Class clazz = classesStack [ i ] ; classesStackString += ( "Class<seq2seq4repair_space>" + i ) + ":<seq2seq4repair_space>\n" ; classesStackString += ( clazz . toString ( ) ) + "\n" ; classesStackString += ( "Class<seq2seq4repair_space>Loader<seq2seq4repair_space>" + i ) + ":<seq2seq4repair_space>\n" ; ClassLoader classLoader = clazz . getClassLoader ( ) ; if ( classLoader == null ) { classesStackString += "null\n" ; } else { classesStackString += ( clazz . getClassLoader ( ) . toString ( ) ) + "\n" ; } } } return ( intro + exception ) + classesStackString ; } }
public class MatchAll extends Query { private static final Logger fileLog = LoggerFactory . getLogger ( "match_all" ) ; public MatchAll ( ) { } @ Override protected void execute ( Client esClient , String index , boolean verbose ) { <START_BUG> this . searchResponse = esClient . prepareSearch ( index ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . get ( ) ; <END_BUG> printResult ( ) ; } @ Override protected void printResult ( ) { } @ Override protected void printQueryStatistics ( ) { } }
public class ShowViewDialog extends Dialog implements IDoubleClickListener , ISelectionChangedListener { private static final String DIALOG_SETTING_SECTION_NAME = "ShowViewDialog" ; private static final int LIST_HEIGHT = 300 ; private static final int LIST_WIDTH = 250 ; private static final String STORE_EXPANDED_CATEGORIES_ID = ( ShowViewDialog . DIALOG_SETTING_SECTION_NAME ) + ".STORE_EXPANDED_CATEGORIES_ID" ; private static final String STORE_SELECTED_VIEW_ID = ( ShowViewDialog . DIALOG_SETTING_SECTION_NAME ) + ".STORE_SELECTED_VIEW_ID" ; private FilteredTree filteredTree ; private Button okButton ; private IViewDescriptor [ ] viewDescs = new IViewDescriptor [ 0 ] ; private IViewRegistry viewReg ; private IWorkbenchWindow window ; private Color dimmedForeground ; public ShowViewDialog ( IWorkbenchWindow window , IViewRegistry viewReg ) { } protected void buttonPressed ( int buttonId ) { } protected void cancelPressed ( ) { } protected void configureShell ( Shell shell ) { } protected void createButtonsForButtonBar ( Composite parent ) { } protected Control createDialogArea ( Composite parent ) { } private static RGB blend ( RGB c1 , RGB c2 , int ratio ) { } private static int blend ( int v1 , int v2 , int ratio ) { } private void createFilteredTreeViewer ( Composite parent ) { PatternFilter filter = new ViewPatternFilter ( ) ; int styleBits = ( ( ( SWT . MULTI ) | ( SWT . H_SCROLL ) ) | ( SWT . V_SCROLL ) ) | ( SWT . BORDER ) ; filteredTree = new FilteredTree ( parent , styleBits , filter ) ; filteredTree . setBackground ( parent . getDisplay ( ) . getSystemColor ( COLOR_WIDGET_BACKGROUND ) ) ; TreeViewer treeViewer = filteredTree . getViewer ( ) ; Control treeControl = treeViewer . getControl ( ) ; RGB dimmedRGB = ShowViewDialog . blend ( treeControl . getForeground ( ) . getRGB ( ) , treeControl . getBackground ( ) . getRGB ( ) , 60 ) ; dimmedForeground = new Color ( treeControl . getDisplay ( ) , dimmedRGB ) ; treeControl . addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent e ) { dimmedForeground . dispose ( ) ; } } ) ; treeViewer . setLabelProvider ( new ViewLabelProvider ( window , dimmedForeground ) ) ; treeViewer . setContentProvider ( new ViewContentProvider ( ) ) ; <START_BUG> treeViewer . setSorter ( new ViewSorter ( ( ( ViewRegistry ) ( viewReg ) ) ) ) ; <END_BUG> treeViewer . setInput ( viewReg ) ; treeViewer . addSelectionChangedListener ( this ) ; treeViewer . addDoubleClickListener ( this ) ; treeViewer . addFilter ( new CapabilityFilter ( ) ) ; if ( hasAtMostOneView ( filteredTree . getViewer ( ) ) ) { Text filterText = filteredTree . getFilterControl ( ) ; if ( filterText != null ) { filterText . setEnabled ( false ) ; } } applyDialogFont ( filteredTree ) ; } private boolean hasAtMostOneView ( TreeViewer tree ) { } public void doubleClick ( DoubleClickEvent event ) { } protected IDialogSettings getDialogSettings ( ) { } public IViewDescriptor [ ] getSelection ( ) { } private void layoutTopControl ( Control control ) { } protected void restoreWidgetValues ( ) { } protected void saveWidgetValues ( ) { } public void selectionChanged ( SelectionChangedEvent event ) { } protected void updateButtons ( ) { } protected void updateSelection ( SelectionChangedEvent event ) { } }
public class BookDetailFragment extends Fragment implements LoaderManager . LoaderCallbacks < Cursor > { public static final String EAN_KEY = "EAN" ; private static final int LOADER_ID = 10 ; private View rootView ; private String ean ; private ShareActionProvider shareActionProvider ; public BookDetailFragment ( ) { } @ Override public void onCreate ( Bundle savedInstanceState ) { } @ Override public View onCreateView ( final LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { } @ Override public void onCreateOptionsMenu ( Menu menu , MenuInflater inflater ) { } @ Override public Loader < Cursor > onCreateLoader ( int id , Bundle args ) { } @ Override public void onLoadFinished ( Loader < Cursor > loader , Cursor data ) { } @ Override public void onLoaderReset ( Loader < Cursor > loader ) { } @ Override public void onPause ( ) { super . onDestroyView ( ) ; <START_BUG> if ( ( MainActivity . IS_TABLET ) && ( ( rootView . findViewById ( right_container ) ) == null ) ) { <END_BUG> getActivity ( ) . getSupportFragmentManager ( ) . popBackStack ( ) ; } } No newline ; at end ; of file ; }
public class Promise < A > extends SettableListenableFuture < A > implements MappableListenableFuture < A > , ListenableFutureCallback < A > { static class JoinedPromise < A , B > extends Promise < Tuple2 < A , B > > { final AtomicReference < A > a = new AtomicReference < > ( ) ; final AtomicReference < B > b = new AtomicReference < > ( ) ; CountDownLatch cdl = new CountDownLatch ( 2 ) ; < X > void addLatchedListener ( AtomicReference < X > ref , ListenableFuture < X > lfx ) { } public JoinedPromise ( ListenableFuture < A > lfa , ListenableFuture < B > lfb ) { } } public Promise ( ) { } public Promise ( ListenableFuture < A > other ) { } @ Override public < B > Promise < B > map ( Function < ? super A , B > f ) { } @ Override public < B > Promise < B > flatMap ( Function < ? super A , ListenableFuture < B > > f ) { } @ Override public < B > Promise < Tuple2 < A , B > > join ( ListenableFuture < B > bf ) { } @ Override public Promise < A > rescue ( Function < Throwable , A > f ) { final Promise < A > rescued = new Promise < > ( ) ; Promise . addCallback ( new ListenableFutureCallback < A > ( ) { @ Override public void onFailure ( Throwable throwable ) { rescued . set ( f . apply ( throwable ) ) ; } @ Override public void onSuccess ( A a ) { <START_BUG> set ( a ) ; <END_BUG> } } ) ; return rescued ; } @ Override public void onFailure ( Throwable throwable ) { } @ Override public void onSuccess ( A o ) { } }
public class MergeAction extends AbstractOpenAction implements PropertyChangeListener { private static final long serialVersionUID = 1L ; private static final Logger LOGGER = Logger . getLogger ( MergeAction . class . getName ( ) ) ; private static final String ERR_FILE = "You<seq2seq4repair_space>can't<seq2seq4repair_space>merge<seq2seq4repair_space>a<seq2seq4repair_space>plan<seq2seq4repair_space>into<seq2seq4repair_space>itself!" ; private static final String ERR_SITE = "The<seq2seq4repair_space>plan<seq2seq4repair_space>you<seq2seq4repair_space>selected<seq2seq4repair_space>is<seq2seq4repair_space>from<seq2seq4repair_space>the<seq2seq4repair_space>other<seq2seq4repair_space>site!" ; private static final String ERR_NIGHT = "The<seq2seq4repair_space>plan<seq2seq4repair_space>you<seq2seq4repair_space>selected<seq2seq4repair_space>seems<seq2seq4repair_space>to<seq2seq4repair_space>be<seq2seq4repair_space>from<seq2seq4repair_space>another<seq2seq4repair_space>night!" ; private static final String PROMPT = "This<seq2seq4repair_space>command<seq2seq4repair_space>opens<seq2seq4repair_space>another<seq2seq4repair_space>plan<seq2seq4repair_space>and<seq2seq4repair_space>adds<seq2seq4repair_space>its<seq2seq4repair_space>variants<seq2seq4repair_space>to<seq2seq4repair_space>the<seq2seq4repair_space>current<seq2seq4repair_space>plan.\n" + "Is<seq2seq4repair_space>this<seq2seq4repair_space>what<seq2seq4repair_space>you<seq2seq4repair_space>want<seq2seq4repair_space>to<seq2seq4repair_space>do?" ; public MergeAction ( IShell shell , KeyChain authClient ) { } @ Override protected void asyncActionPerformed ( ActionEvent e ) { IShell shell = getShell ( ) ; try { shell . getPeer ( ) . getGlassPane ( ) . setVisible ( true ) ; Schedule current = ( ( Schedule ) ( shell . getModel ( ) ) ) ; if ( current == null ) { MergeAction . LOGGER . warning ( "Model<seq2seq4repair_space>is<seq2seq4repair_space>null.<seq2seq4repair_space>Shouldn't<seq2seq4repair_space>be<seq2seq4repair_space>possible." ) ; return ; } int opt = JOptionPane . showConfirmDialog ( shell . getPeer ( ) , MergeAction . PROMPT , "Merge<seq2seq4repair_space>Plans" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( opt != ( JOptionPane . YES_OPTION ) ) return ; Schedule other = open ( ) ; if ( other != null ) { if ( other . getFile ( ) . equals ( current . getFile ( ) ) ) { JOptionPane . showMessageDialog ( shell . getPeer ( ) , MergeAction . ERR_FILE , "Cannot<seq2seq4repair_space>Merge" , JOptionPane . ERROR_MESSAGE ) ; return ; } if ( ( current . getSite ( ) ) != ( other . getSite ( ) ) ) { JOptionPane . showMessageDialog ( shell . getPeer ( ) , MergeAction . ERR_SITE , "Cannot<seq2seq4repair_space>Merge" , JOptionPane . ERROR_MESSAGE ) ; return ; } TwilightBoundedNight prevNight = new TwilightBoundedNight ( TwilightBoundType . NAUTICAL , current . getStart ( ) , current . getSite ( ) ) ; TwilightBoundedNight nextNight = new TwilightBoundedNight ( TwilightBoundType . NAUTICAL , other . getStart ( ) , other . getSite ( ) ) ; if ( ( prevNight . getStartTime ( ) ) != ( nextNight . getStartTime ( ) ) ) { JOptionPane . showMessageDialog ( shell . getPeer ( ) , MergeAction . ERR_NIGHT , "Cannot<seq2seq4repair_space>Merge" , JOptionPane . ERROR_MESSAGE ) ; return ; } for ( String semester : other . getExtraSemesters ( ) ) <START_BUG> current . addExtraSemseter ( semester ) ; <END_BUG> for ( Enum < ? > facility : other . getFacilities ( ) ) current . addFacility ( facility ) ; for ( Variant variant : other . getVariants ( ) ) current . duplicateVariant ( variant ) ; new RefreshAction ( shell , authClient ) . asyncActionPerformed ( e ) ; } } finally { shell . getPeer ( ) . getGlassPane ( ) . setVisible ( false ) ; } } public void propertyChange ( PropertyChangeEvent evt ) { } }
public class FieldReference extends Reference implements InvocationSite { public Expression receiver ; public char [ ] token ; public FieldBinding binding ; public FieldBinding codegenBinding ; public long nameSourcePosition ; MethodBinding syntheticReadAccessor ; MethodBinding syntheticWriteAccessor ; public TypeBinding receiverType ; public FieldReference ( char [ ] source , long pos ) { } public FlowInfo analyseAssignment ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , Assignment assignment , boolean isCompound ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , boolean valueRequired ) { } public FieldBinding fieldBinding ( ) { } public void generateAssignment ( BlockScope currentScope , CodeStream codeStream , Assignment assignment , boolean valueRequired ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } public void generateCompoundAssignment ( BlockScope currentScope , CodeStream codeStream , Expression expression , int operator , int assignmentImplicitConversion , boolean valueRequired ) { } public void generatePostIncrement ( BlockScope currentScope , CodeStream codeStream , CompoundAssignment postIncrement , boolean valueRequired ) { } public static final Constant getConstantFor ( FieldBinding binding , Reference reference , boolean isImplicit , Scope referenceScope ) { } public boolean isSuperAccess ( ) { } public boolean isTypeAccess ( ) { } public void manageSyntheticReadAccessIfNecessary ( BlockScope currentScope , FlowInfo flowInfo ) { } public void manageSyntheticWriteAccessIfNecessary ( BlockScope currentScope , FlowInfo flowInfo ) { } public TypeBinding resolveType ( BlockScope scope ) { this . receiverType = receiver . resolveType ( scope ) ; if ( ( this . receiverType ) == null ) { constant = NotAConstant ; return null ; } this . codegenBinding = this . binding = scope . getField ( this . receiverType , token , this ) ; if ( ! ( binding . isValidBinding ( ) ) ) { constant = NotAConstant ; scope . problemReporter ( ) . invalidField ( this , this . receiverType ) ; return null ; } <START_BUG> if ( isFieldUseDeprecated ( binding , scope ) ) <END_BUG> scope . problemReporter ( ) . deprecatedField ( binding , this ) ; boolean isImplicitThisRcv = receiver . isImplicitThis ( ) ; constant = FieldReference . getConstantFor ( binding , this , isImplicitThisRcv , scope ) ; if ( ! isImplicitThisRcv ) { constant = NotAConstant ; } if ( binding . isStatic ( ) ) { if ( ! ( ( isImplicitThisRcv || ( receiver . isSuper ( ) ) ) || ( ( ( receiver ) instanceof NameReference ) && ( ( ( ( ( NameReference ) ( receiver ) ) . bits ) & ( BindingIds . TYPE ) ) != 0 ) ) ) ) { scope . problemReporter ( ) . unnecessaryReceiverForStaticField ( this , binding ) ; } } return this . resolvedType = binding . type ; } public void setActualReceiverType ( ReferenceBinding receiverType ) { } public void setDepth ( int depth ) { } public void setFieldIndex ( int index ) { } public String toStringExpression ( ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope scope ) { } }
public class ParsedRaDeploymentProcessor implements DeploymentUnitProcessor { public static final Logger log = Logger . getLogger ( "org.jboss.as.connector.deployer.radeployer" ) ; public ParsedRaDeploymentProcessor ( ) { } public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final ConnectorXmlDescriptor connectorXmlDescriptor = phaseContext . getDeploymentUnit ( ) . getAttachment ( ATTACHMENT_KEY ) ; if ( connectorXmlDescriptor == null ) { return ; } final IronJacamarXmlDescriptor ironJacamarXmlDescriptor = phaseContext . getAttachment ( IronJacamarXmlDescriptor . ATTACHMENT_KEY ) ; final Module module = phaseContext . getAttachment ( MODULE ) ; if ( module == null ) throw new DeploymentUnitProcessingException ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>get<seq2seq4repair_space>module<seq2seq4repair_space>attachment<seq2seq4repair_space>for<seq2seq4repair_space>" + ( phaseContext . getDeploymentUnit ( ) ) ) ) ; final ClassLoader classLoader = module . getClassLoader ( ) ; Connector cmd = ( connectorXmlDescriptor != null ) ? connectorXmlDescriptor . getConnector ( ) : null ; final IronJacamar ijmd = ( ironJacamarXmlDescriptor != null ) ? ironJacamarXmlDescriptor . getIronJacamar ( ) : null ; try { Annotations annotator = new Annotations ( ) ; AnnotationRepository repository = new org . jboss . as . connector . annotations . repository . jandex . JandexAnnotationRepositoryImpl ( phaseContext . getAttachment ( ANNOTATION_INDEX ) , classLoader ) ; cmd = annotator . merge ( cmd , repository , classLoader ) ; cmd . validate ( ) ; cmd = new Merger ( ) . mergeConnectorWithCommonIronJacamar ( ijmd , cmd ) ; final ResourceAdapterDeploymentService raDeployementService = new ResourceAdapterDeploymentService ( connectorXmlDescriptor , cmd , ijmd , module ) ; final ServiceTarget serviceTarget = phaseContext . getServiceTarget ( ) ; <START_BUG> serviceTarget . addService ( RESOURCE_ADAPTER_SERVICE_PREFIX . append ( connectorXmlDescriptor . getDeploymentName ( ) ) , raDeployementService ) . addDependency ( IRONJACAMAR_MDR , MetadataRepository . class , raDeployementService . getMdrInjector ( ) ) . addDependency ( RESOURCE_ADAPTER_REGISTRY_SERVICE , ResourceAdapterDeploymentRegistry . class , raDeployementService . getRegistryInjector ( ) ) . addDependency ( JNDI_STRATEGY_SERVICE , JndiStrategy . class , raDeployementService . getJndiInjector ( ) ) . addDependency ( JBOSS_TXN_TRANSACTION_MANAGER , TransactionManagerService . class , raDeployementService . getTxmInjector ( ) ) . addDependency ( CONNECTOR_CONFIG_SERVICE , ConnectorSubsystemConfiguration . class , raDeployementService . getConfigInjector ( ) ) . addDependency ( SERVICE_NAME ) . setInitialMode ( ACTIVE ) . install ( ) ; <END_BUG> } catch ( Throwable t ) { throw new DeploymentUnitProcessingException ( t ) ; } } public void undeploy ( final DeploymentUnit context ) { } }
public class OSGiSubsystemSupport { private static final Logger log = Logger . getLogger ( OSGiSubsystemSupport . class ) ; public static final byte [ ] BLANK_SHA1 = new byte [ 20 ] ; private static final AtomicInteger archiveCount = new AtomicInteger ( ) ; private final ServiceContainer serviceContainer ; private OSGiSubsystemState subsystemState ; private DeploymentChain deploymentChain ; private Selector selector ; public OSGiSubsystemSupport ( ) throws Exception { } public OSGiSubsystemSupport ( final OSGiSubsystemState subsystemState ) throws Exception { } public ServiceContainer getServiceContainer ( ) { } public ModuleLoader getClassifyingModuleLoader ( ) { } public OSGiSubsystemSupport . TestModuleLoader getTestModuleLoader ( ) { } public DeploymentChain getDeploymentChain ( ) { } public String getUniqueName ( String prefix ) { } public void assertServiceUp ( ServiceName serviceName ) { } public void assertServiceDown ( ServiceName serviceName ) { } public void shutdown ( ) { } public void removeDeploymentChain ( ) { } public void setupServices ( final BatchBuilder batchBuilder ) throws Exception { } public void setupEnvironmentServices ( final BatchBuilder batchBuilder ) { } public void setupModuleLoaderServices ( final BatchBuilder batchBuilder ) { } public void setupDeploymentServices ( final BatchBuilder batchBuilder ) { } public void setupFrameworkServices ( final BatchBuilder batchBuilder ) { batchBuilder . addService ( SERVICE_NAME , new MBeanServerService ( ) ) ; OSGiSubsystemSupport . TestBundleManagerService . addService ( batchBuilder ) ; <START_BUG> FrameworkService . addService ( batchBuilder , IMMEDIATE ) ; <END_BUG> PackageAdminService . addService ( batchBuilder ) ; } private Selector getDeploymentChainSelector ( ) { } public BundleManager getBundleManager ( ) { } public BundleContext getSystemContext ( ) { } public Configuration getSubsystemConfig ( ) { } public void assertLoadClass ( ModuleIdentifier identifier , String className ) throws Exception { } public void assertLoadClass ( ModuleIdentifier identifier , String className , ModuleIdentifier exporterId ) throws Exception { } public void assertLoadClassFails ( ModuleIdentifier identifier , String className ) throws Exception { } public Class < ? > loadClass ( ModuleIdentifier identifier , String className ) throws Exception { } public Module loadModule ( ModuleIdentifier identifier ) throws ModuleLoadException { } public Bundle executeDeploy ( final JavaArchive archive ) throws Exception { } public void executeUndeploy ( final JavaArchive archive ) throws Exception { } List < ServiceName > runWithLatchedBatch ( final OSGiSubsystemSupport . BatchedWork work ) throws Exception { } public interface BatchedWork { void execute ( final BatchBuilder batchBuilder ) throws Exception { } } private static class TestServiceListener extends AbstractServiceListener < Object > { final List < ServiceName > registeredServices = new ArrayList < ServiceName > ( ) ; final List < ServiceName > startedServices = new ArrayList < ServiceName > ( ) ; final List < ServiceName > failedServices = new ArrayList < ServiceName > ( ) ; final Map < Mode , List < ServiceName > > initialModes ; private final AtomicInteger count = new AtomicInteger ( 1 ) ; private final Runnable finishTask ; public TestServiceListener ( Runnable finishTask , Map < Mode , List < ServiceName > > initialModes ) { } public void listenerAdded ( final ServiceController < ? extends Object > controller ) { } public void serviceStarted ( final ServiceController < ? extends Object > controller ) { } public void serviceFailed ( ServiceController < ? extends Object > controller , StartException reason ) { } @ Override public void serviceRemoved ( ServiceController < ? extends Object > controller ) { } public void finishBatch ( ) { } private void batchComplete ( ) { } } public static class TestModuleLoader extends ModuleLoader implements Service < OSGiSubsystemSupport . TestModuleLoader > { public static final ServiceName SERVICE_NAME = JBOSS . append ( "module" , "loader" , "support" ) ; private String prefix ; private Map < ModuleIdentifier , ModuleSpec > modules = new HashMap < ModuleIdentifier , ModuleSpec > ( ) ; private Injector < ClassifyingModuleLoaderService > injector ; TestModuleLoader ( String prefix ) { } public void addModuleSpec ( ModuleSpec moduleSpec ) { } @ Override protected ModuleSpec findModule ( ModuleIdentifier identifier ) throws ModuleLoadException { } public static OSGiSubsystemSupport . TestModuleLoader getServiceValue ( ServiceContainer container ) { } public synchronized void start ( StartContext context ) throws StartException { } public synchronized void stop ( StopContext context ) { } public synchronized OSGiSubsystemSupport . TestModuleLoader getValue ( ) throws IllegalStateException { } @ Override public String toString ( ) { } } static class TestBundleManagerService implements Service < BundleManager > { public static final ServiceName SERVICE_NAME = BundleManagerService . SERVICE_NAME ; private static final Logger log = Logger . getLogger ( "org.jboss.as.osgi" ) ; private InjectedValue < Configuration > injectedConfig = new InjectedValue < Configuration > ( ) ; private InjectedValue < ClassifyingModuleLoaderService > injectedModuleLoader = new InjectedValue < ClassifyingModuleLoaderService > ( ) ; private Injector < ClassifyingModuleLoaderService > moduleLoaderInjector ; private BundleManager bundleManager ; public static void addService ( final BatchBuilder batchBuilder ) { } public static BundleManager getServiceValue ( ServiceContainer container ) { } public synchronized void start ( StartContext context ) throws StartException { } public synchronized void stop ( StopContext context ) { } @ Override public BundleManager getValue ( ) throws IllegalStateException { } } static class TestServerDeploymentRepository implements ServerDeploymentRepository , Service < ServerDeploymentRepository > { private Map < String , JavaArchive > repository = new HashMap < String , JavaArchive > ( ) ; public static OSGiSubsystemSupport . TestServerDeploymentRepository getServiceValue ( ServiceContainer container ) { } public void registerDeploymentArchive ( String name , JavaArchive archive ) { } @ Override public void start ( StartContext context ) throws StartException { } @ Override public void stop ( StopContext context ) { } @ Override public ServerDeploymentRepository getValue ( ) throws IllegalStateException { } @ Override public byte [ ] addDeploymentContent ( String name , String runtimeName , InputStream stream ) throws IOException { } @ Override public Closeable mountDeploymentContent ( String name , String runtimeName , byte [ ] deploymentHash , VirtualFile mountPoint ) throws IOException { } } }
public class EnchantManager { private static HashSet < CEnchantment > enchantments = new HashSet < CEnchantment > ( ) ; private static Enchantment glowEnchantment ; private static int maxEnchants = - 1 ; private static String lorePrefix ; private static String enchantBookName ; private static Enchantment registerGlowEnchantment ( ) { } public static ItemStack addEnchant ( ItemStack item , CEnchantment ce ) { } public static ItemStack addEnchant ( ItemStack item , CEnchantment ce , int level ) { } public static ItemStack addEnchantments ( ItemStack item , HashMap < CEnchantment , Integer > list ) { } public static boolean hasEnchant ( ItemStack item , CEnchantment ce ) { } public static void removeEnchant ( ItemStack item , CEnchantment ce ) { } public static CEnchantment getEnchantment ( String name ) { } public static HashSet < CEnchantment > getEnchantments ( ) { } public static HashSet < CEnchantment > getEnchantments ( List < String > lore ) { } public static HashMap < CEnchantment , Integer > getEnchantmentLevels ( List < String > lore ) { } public static Boolean hasEnchantments ( ItemStack toTest ) { } public static boolean isEnchantmentBook ( ItemStack i ) { } public static boolean isEnchantable ( String mat ) { <START_BUG> if ( ( ( ( ( ( ( ( ( mat . contains ( "HELMET" ) ) || ( mat . contains ( "CHESTPLATE" ) ) ) || ( mat . contains ( "LEGGINGS" ) ) ) || ( mat . contains ( "BOOTS" ) ) ) || ( mat . contains ( "SWORD" ) ) ) || ( mat . contains ( "PICKAXE" ) ) ) || ( mat . contains ( "AXE" ) ) ) || ( mat . contains ( "SPADE" ) ) ) || ( mat . contains ( "HOE" ) ) ) <END_BUG> return true ; if ( ( ( config . getBoolean ( "Global.Runecrafting.Disenchanting" ) ) && ( mat . equals ( "BOOK" ) ) ) || ( ( config . getBoolean ( "Global.Runecrafting.CanStackEnchantments" ) ) && ( mat . equals ( "ENCHANTED_BOOK" ) ) ) ) return true ; return false ; } public static Boolean containsEnchantment ( List < String > toTest ) { } public static Boolean containsEnchantment ( String toTest ) { } public static Boolean containsEnchantment ( List < String > toTest , CEnchantment ce ) { } public static Boolean containsEnchantment ( String toTest , CEnchantment ce ) { } public static String getLorePrefix ( ) { } public static int getMaxEnchants ( ) { } public static Enchantment getGlowEnchantment ( ) { } public static int getLevel ( String checkEnchant ) { } public static String intToLevel ( int i ) { } public static int levelToInt ( String level ) { } public static String getEnchantBookName ( ) { } public static ItemStack getEnchantBook ( CEnchantment ce ) { } public static ItemStack getEnchantBook ( CEnchantment ce , int level ) { } public static ItemStack getEnchantBook ( HashMap < CEnchantment , Integer > list ) { } public static void setLorePrefix ( String newPrefix ) { } public static void setMaxEnchants ( int newMax ) { } public static void setEnchantBookName ( String newName ) { } }
public class NativeTest { private static int execIntIntInt ( int a0 , int a1 , byte [ ] code , int size ) { } private static float execFloatFloatFloat ( float a0 , float a1 , byte [ ] code , int size ) { } public static void main ( String [ ] args ) throws IOException , ClassNotFoundException , SecurityException { } private static void generateCode ( X86Assembler os , String className ) throws ClassNotFoundException , MalformedURLException { VmByteCode code = NativeTest . loadByteCode ( className ) ; X86CodeGenerator x86cg = null ; IRControlFlowGraph cfg = new IRControlFlowGraph ( code ) ; BytecodeViewer bv = new BytecodeViewer ( ) ; BytecodeParser . parse ( code , bv ) ; System . out . println ( cfg ) ; <START_BUG> IRGenerator irg = new IRGenerator ( cfg ) ; <END_BUG> BytecodeParser . parse ( code , irg ) ; } private static VmByteCode loadByteCode ( String className ) throws ClassNotFoundException , MalformedURLException { } public static void printQuadDetail ( Quad quad ) { } }
public class JavadocAllocationExpression extends AllocationExpression { public int tagSourceStart ; public int tagSourceEnd ; public int tagValue ; public boolean superAccess = false ; public JavadocAllocationExpression ( long pos ) { } private TypeBinding internalResolveType ( Scope scope ) { this . constant = NotAConstant ; if ( ( this . type ) == null ) { this . resolvedType = scope . enclosingSourceType ( ) ; } else if ( ( scope . kind ) == ( Scope . CLASS_SCOPE ) ) { this . resolvedType = this . type . resolveType ( ( ( ClassScope ) ( scope ) ) ) ; } else { <START_BUG> this . resolvedType = this . type . resolveType ( ( ( BlockScope ) ( scope ) ) ) ; <END_BUG> } TypeBinding [ ] argumentTypes = NoParameters ; if ( ( this . arguments ) != null ) { boolean argHasError = false ; int length = this . arguments . length ; argumentTypes = new TypeBinding [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { Expression argument = this . arguments [ i ] ; if ( ( scope . kind ) == ( Scope . CLASS_SCOPE ) ) { argumentTypes [ i ] = argument . resolveType ( ( ( ClassScope ) ( scope ) ) ) ; } else { argumentTypes [ i ] = argument . resolveType ( ( ( BlockScope ) ( scope ) ) ) ; } if ( ( argumentTypes [ i ] ) == null ) { argHasError = true ; } } if ( argHasError ) { return null ; } } if ( ( this . resolvedType ) == null ) { return null ; } this . superAccess = scope . enclosingSourceType ( ) . isCompatibleWith ( this . resolvedType ) ; ReferenceBinding allocationType = ( ( ReferenceBinding ) ( this . resolvedType ) ) ; this . binding = scope . getConstructor ( allocationType , argumentTypes , this ) ; if ( ! ( this . binding . isValidBinding ( ) ) ) { MethodBinding methodBinding = scope . getMethod ( this . resolvedType , this . resolvedType . sourceName ( ) , argumentTypes , this ) ; if ( methodBinding . isValidBinding ( ) ) { this . binding = methodBinding ; } else { if ( ( this . binding . declaringClass ) == null ) { this . binding . declaringClass = allocationType ; } scope . problemReporter ( ) . javadocInvalidConstructor ( this , this . binding , scope . getDeclarationModifiers ( ) ) ; } return this . resolvedType ; } if ( isMethodUseDeprecated ( this . binding , scope ) ) { scope . problemReporter ( ) . javadocDeprecatedMethod ( this . binding , this , scope . getDeclarationModifiers ( ) ) ; } return allocationType ; } public boolean isSuperAccess ( ) { } public TypeBinding resolveType ( BlockScope scope ) { } public TypeBinding resolveType ( ClassScope scope ) { } }
@ Override public void onAttach ( Activity activity ) { } @ Override public View onCreateView ( final LayoutInflater inflater , final ViewGroup container , final Bundle savedInstanceState ) { } @ Override public void onActivityCreated ( final Bundle savedInstanceState ) { } @ Override public void onStart ( ) { } @ Override public void onSaveInstanceState ( final Bundle outState ) { } @ Override public void onStop ( ) { } @ Override public void onDestroyView ( ) { } @ Override public void onCreateOptionsMenu ( final Menu menu , final MenuInflater inflater ) { } @ Override public void onPrepareOptionsMenu ( final Menu menu ) { } @ Override public boolean onOptionsItemSelected ( final MenuItem item ) { } @ Override public void onBaseViewCreated ( final View view , final Bundle savedInstanceState ) { } @ Override public boolean handleKeyboardShortcutSingle ( @ NonNull KeyboardShortcutsHandler handler , int keyCode , @ NonNull KeyEvent event ) { } @ Override public boolean handleKeyboardShortcutRepeat ( @ NonNull final KeyboardShortcutsHandler handler , final int keyCode , final int repeatCount , @ NonNull final KeyEvent event ) { } private boolean handleFragmentKeyboardShortcutRepeat ( @ NonNull KeyboardShortcutsHandler handler , int keyCode , int repeatCount , @ NonNull KeyEvent event ) { } private boolean handleFragmentKeyboardShortcutSingle ( @ NonNull KeyboardShortcutsHandler handler , int keyCode , @ NonNull KeyEvent event ) { } private Fragment getKeyboardShortcutRecipient ( ) { } @ Override protected void fitSystemWindows ( Rect insets ) { } @ Override public void onClick ( final View view ) { } @ Override public void onLinkClick ( final String link , final String orig , final long accountId , long extraId , final int type , final boolean sensitive , int start , int end ) { } @ Override public void onSharedPreferenceChanged ( final SharedPreferences sharedPreferences , final String key ) { } @ Override public void onSizeChanged ( final View view , final int w , final int h , final int oldw , final int oldh ) { } @ Override public boolean onTouch ( final View v , final MotionEvent event ) { } @ Override public boolean scrollToStart ( ) { } @ Override public boolean triggerRefresh ( ) { } public void setListShown ( boolean shown ) { } private void getFriendship ( ) { } private void getUserInfo ( final boolean omitIntentExtra ) { } private static void setCompatToolbarOverlayAlpha ( FragmentActivity activity , float alpha ) { } private void setUiColor ( int color ) { } private void setupBaseActionBar ( ) { } private void setupUserPages ( ) { } private void updateFollowProgressState ( ) { } private void updateRefreshState ( ) { } private void updateScrollOffset ( int offset ) { final View space = mProfileBannerSpace ; final ProfileBannerImageView profileBannerView = mProfileBannerView ; final View profileBannerContainer = mProfileBannerContainer ; final int spaceHeight = space . getHeight ( ) ; final float factor = MathUtils . clamp ( ( offset / ( ( float ) ( spaceHeight ) ) ) , 0 , 1 ) ; profileBannerContainer . setTranslationY ( Math . max ( ( - offset ) , ( - spaceHeight ) ) ) ; profileBannerView . setTranslationY ( ( ( Math . min ( offset , spaceHeight ) ) / 2 ) ) ; if ( ( ( mActionBarBackground ) != null ) && ( ( mTintedStatusContent ) != null ) ) { mActionBarBackground . setFactor ( factor ) ; mTintedStatusContent . setFactor ( factor ) ; final float profileContentHeight = ( mProfileNameContainer . getHeight ( ) ) + ( mProfileDetailsContainer . getHeight ( ) ) ; final float tabOutlineAlphaFactor ; if ( ( offset - spaceHeight ) > 0 ) { tabOutlineAlphaFactor = 1.0F - ( MathUtils . clamp ( ( ( offset - spaceHeight ) / profileContentHeight ) , 0 , 1 ) ) ; } else { tabOutlineAlphaFactor = 1.0F ; } mActionBarBackground . setOutlineAlphaFactor ( tabOutlineAlphaFactor ) ; final ThemedAppCompatActivity activity = ( ( ThemedAppCompatActivity ) ( getActivity ( ) ) ) ; if ( ( VERSION . SDK_INT ) < ( VERSION_CODES . LOLLIPOP ) ) { UserFragment . setCompatToolbarOverlayAlpha ( activity , ( factor * tabOutlineAlphaFactor ) ) ; } final Drawable drawable = mPagerIndicator . getBackground ( ) ; final int stackedTabColor ; final int themeId = activity . getCurrentThemeResourceId ( ) ; if ( drawable instanceof ColorDrawable ) { <START_BUG> stackedTabColor = mUserUiColor ; <END_BUG> final int tabColor = ( ( Integer ) ( UserFragment . sArgbEvaluator . evaluate ( tabOutlineAlphaFactor , stackedTabColor , mCardBackgroundColor ) ) ) ; ( ( ColorDrawable ) ( drawable ) ) . setColor ( tabColor ) ; final int contrastColor = TwidereColorUtils . getContrastYIQ ( tabColor , 192 ) ; mPagerIndicator . setIconColor ( contrastColor ) ; mPagerIndicator . setLabelColor ( contrastColor ) ; mPagerIndicator . setStripColor ( contrastColor ) ; } else { return ; } final int barColor = ( ( Integer ) ( UserFragment . sArgbEvaluator . evaluate ( factor , mActionBarShadowColor , stackedTabColor ) ) ) ; final int itemColor = ThemeUtils . getContrastActionBarItemColor ( activity , themeId , barColor ) ; if ( ( mActionBarHomeAsUpIndicator ) != null ) { mActionBarHomeAsUpIndicator . setColorFilter ( itemColor , SRC_ATOP ) ; } final View actionBarView = activity . getWindow ( ) . findViewById ( action_bar ) ; if ( actionBarView instanceof Toolbar ) { final Toolbar toolbar = ( ( Toolbar ) ( actionBarView ) ) ; toolbar . setTitleTextColor ( itemColor ) ; toolbar . setSubtitleTextColor ( itemColor ) ; ThemeUtils . setActionBarOverflowColor ( toolbar , itemColor ) ; ThemeUtils . wrapToolbarMenuIcon ( ViewUtils . findViewByType ( actionBarView , ActionMenuView . class ) , itemColor , itemColor ) ; } mPagerIndicator . updateAppearance ( ) ; } updateTitleAlpha ( ) ; } private void updateTitleAlpha ( ) { } private static class ActionBarDrawable extends LayerDrawable { private final Drawable mShadowDrawable ; private final ColorDrawable mColorDrawable ; private float mFactor ;
