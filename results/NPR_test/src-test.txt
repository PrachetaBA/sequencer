public class InvalidMatrixExceptionTest extends TestCase { public void testConstructorMessage ( ) { String msg = "message" ; <START_BUG> InvalidMatrixException ex = new InvalidMatrixException ( msg , new Object [ 0 ] ) ; <END_BUG> assertEquals ( msg , ex . getMessage ( ) ) ; } }
public class AboutPluginsDialog extends ProductInfoDialog { private static final int TABLE_HEIGHT = 200 ; private static final IPath baseNLPath = new Path ( "$nl$" ) ; private static final String PLUGININFO = "about.html" ; private static final int MORE_ID = ( IDialogConstants . CLIENT_ID ) + 1 ; private Table vendorInfo ; private Button moreInfo ; private String title ; private String message ; private String helpContextId ; private String [ ] columnTitles = new String [ ] { WorkbenchMessages . AboutPluginsDialog_provider , WorkbenchMessages . AboutPluginsDialog_pluginName , WorkbenchMessages . AboutPluginsDialog_version , WorkbenchMessages . AboutPluginsDialog_pluginId } ; private String productName ; private AboutBundleData [ ] bundleInfos ; private int lastColumnChosen = 0 ; private boolean reverseSort = false ; private AboutBundleData lastSelection = null ; public AboutPluginsDialog ( Shell parentShell , String productName ) { } public AboutPluginsDialog ( Shell parentShell , String productName , Bundle [ ] bundles , String title , String message , String helpContextId ) { } protected void buttonPressed ( int buttonId ) { } protected void configureShell ( Shell newShell ) { } protected void createButtonsForButtonBar ( Composite parent ) { } protected Control createDialogArea ( Composite parent ) { } protected void createTable ( Composite parent ) { } private boolean selectionHasInfo ( ) { } private boolean tableHasSelection ( ) { } protected void handleMoreInfoPressed ( ) { } private void sort ( int column ) { } private void refreshTable ( int col ) { } private static String [ ] createRow ( AboutBundleData info ) { } private URL getMoreInfoURL ( AboutBundleData bundleInfo , boolean makeLocal ) { Bundle bundle = Platform . getBundle ( bundleInfo . getId ( ) ) ; if ( bundle == null ) return null ; URL aboutUrl = Platform . find ( bundle , AboutPluginsDialog . baseNLPath . append ( AboutPluginsDialog . PLUGININFO ) , null ) ; if ( ! makeLocal ) { return aboutUrl ; } if ( aboutUrl != null ) { try { URL result = Platform . asLocalURL ( aboutUrl ) ; try { <START_BUG> URL about = new URL ( aboutUrl , "about" ) ; <END_BUG> if ( about != null ) Platform . asLocalURL ( about ) ; } catch ( IOException e ) { } return result ; } catch ( IOException e ) { } } return null ; } }
public class NumberUtils { public static final Long LONG_ZERO = Long . valueOf ( 0L ) ; public static final Long LONG_ONE = Long . valueOf ( 1L ) ; public static final Long LONG_MINUS_ONE = Long . valueOf ( ( - 1L ) ) ; public static final Integer INTEGER_ZERO = Integer . valueOf ( 0 ) ; public static final Integer INTEGER_ONE = Integer . valueOf ( 1 ) ; public static final Integer INTEGER_MINUS_ONE = Integer . valueOf ( ( - 1 ) ) ; public static final Short SHORT_ZERO = Short . valueOf ( ( ( short ) ( 0 ) ) ) ; public static final Short SHORT_ONE = Short . valueOf ( ( ( short ) ( 1 ) ) ) ; public static final Short SHORT_MINUS_ONE = Short . valueOf ( ( ( short ) ( - 1 ) ) ) ; public static final Byte BYTE_ZERO = Byte . valueOf ( ( ( byte ) ( 0 ) ) ) ; public static final Byte BYTE_ONE = Byte . valueOf ( ( ( byte ) ( 1 ) ) ) ; public static final Byte BYTE_MINUS_ONE = Byte . valueOf ( ( ( byte ) ( - 1 ) ) ) ; public static final Double DOUBLE_ZERO = Double . valueOf ( 0.0 ) ; public static final Double DOUBLE_ONE = Double . valueOf ( 1.0 ) ; public static final Double DOUBLE_MINUS_ONE = Double . valueOf ( ( - 1.0 ) ) ; public static final Float FLOAT_ZERO = Float . valueOf ( 0.0F ) ; public static final Float FLOAT_ONE = Float . valueOf ( 1.0F ) ; public static final Float FLOAT_MINUS_ONE = Float . valueOf ( ( - 1.0F ) ) ; public NumberUtils ( ) { } public static int toInt ( final String str ) { } public static int toInt ( final String str , final int defaultValue ) { } public static long toLong ( final String str ) { } public static long toLong ( final String str , final long defaultValue ) { } public static float toFloat ( final String str ) { } public static float toFloat ( final String str , final float defaultValue ) { } public static double toDouble ( final String str ) { } public static double toDouble ( final String str , final double defaultValue ) { } public static byte toByte ( final String str ) { } public static byte toByte ( final String str , final byte defaultValue ) { } public static short toShort ( final String str ) { } public static short toShort ( final String str , final short defaultValue ) { } public static Number createNumber ( final String str ) throws NumberFormatException { } private static boolean isAllZeros ( final String str ) { } public static Float createFloat ( final String str ) { } public static Double createDouble ( final String str ) { } public static Integer createInteger ( final String str ) { } public static Long createLong ( final String str ) { } public static BigInteger createBigInteger ( final String str ) { if ( str == null ) { return null ; } int pos = 0 ; int radix = 10 ; boolean negate = false ; if ( str . startsWith ( "-" ) ) { negate = true ; pos = 1 ; } <START_BUG> if ( ( str . startsWith ( "0x" , pos ) ) || ( str . startsWith ( "0x" , pos ) ) ) { <END_BUG> radix = 16 ; pos += 2 ; } else if ( str . startsWith ( "#" , pos ) ) { radix = 16 ; pos ++ ; } else if ( ( str . startsWith ( "0" , pos ) ) && ( ( str . length ( ) ) > ( pos + 1 ) ) ) { radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ; return negate ? value . negate ( ) : value ; } public static BigDecimal createBigDecimal ( final String str ) { } public static long min ( final long ... array ) { } public static int min ( final int ... array ) { } public static short min ( final short ... array ) { } public static byte min ( final byte ... array ) { } public static double min ( final double ... array ) { } public static float min ( final float ... array ) { } public static long max ( final long ... array ) { } public static int max ( final int ... array ) { } public static short max ( final short ... array ) { } public static byte max ( final byte ... array ) { } public static double max ( final double ... array ) { } public static float max ( final float ... array ) { } private static void validateArray ( final Object array ) { } public static long min ( long a , final long b , final long c ) { } public static int min ( int a , final int b , final int c ) { } public static short min ( short a , final short b , final short c ) { } public static byte min ( byte a , final byte b , final byte c ) { } public static double min ( final double a , final double b , final double c ) { } public static float min ( final float a , final float b , final float c ) { } public static long max ( long a , final long b , final long c ) { }
public class Main { private static final int nTrialsPerPaper = 12 ; private Indexer < String > wordIndexer ; private Indexer < PaperAbstract > paperIndexer ; private Terms terms ; private KNNSimilarityCache knnSimilarityCache ; private KNNGraphDistanceCache knnGraphDistanceCache ; private static MetadataLogger metadataLogger ; private static Random randGen ; public List < TrainingPaper > trainingSet ; public List < PredictionPaper > testingSet ; private Baseline baseline ; private CommonNeighbors cn ; private DTRandomWalkPredictor dtRWPredictor ; private KNN knn ; private KNNWithCitation knnc ; private LSI lsi ; public Main ( long randomSeed ) { } public void load_data ( String filename , double trainPercent ) { } private void splitByTrainPercent ( double trainPercent , List < PaperAbstract > documents ) { } public void splitHeldoutWords ( double testWordPercent ) { } public static Random getRandomGenerator ( ) { } public static MetadataLogger getMetadataLogger ( ) { } public double [ ] evaluate ( PredictionPaper testingPaper , Integer [ ] prediction , int size , int k ) { } public static void printResults ( double [ ] results ) { } public static void printResults ( File output , double [ ] results ) { } public void runClusteringMethods ( File outputDir , int [ ] ks ) { int size = ( trainingSet . size ( ) ) + ( testingSet . size ( ) ) ; if ( Main . testIsEnabled ( "baseline" ) ) { baseline = new Baseline ( trainingSet , terms ) ; runClusteringMethod ( testingSet , baseline , outputDir , ks , size ) ; } if ( Main . testIsEnabled ( "dtrw" ) ) { int rwLength = Integer . getInteger ( "plusone.dtrw.walkLength" , 4 ) ; boolean stoch = Boolean . getBoolean ( "plusone.dtrw.stochastic" ) ; int nSampleWalks = Integer . getInteger ( "plusone.dtrw.nSampleWalks" ) ; System . out . println ( ( "Random<seq2seq4repair_space>walk<seq2seq4repair_space>length:<seq2seq4repair_space>" + rwLength ) ) ; if ( stoch ) System . out . println ( ( ( "Stochastic<seq2seq4repair_space>random<seq2seq4repair_space>walk:<seq2seq4repair_space>" + nSampleWalks ) + "<seq2seq4repair_space>samples." ) ) ; boolean finalIdf = Boolean . getBoolean ( "plusone.dtrw.finalIdf" ) ; boolean ndiw = Boolean . getBoolean ( "plusone.dtrw.normalizeDocsInWord" ) ; Boolean nwid = Boolean . getBoolean ( "plusone.dtrw.normalizeWordsInDoc" ) ; dtRWPredictor = new DTRandomWalkPredictor ( trainingSet , terms , rwLength , stoch , nSampleWalks , finalIdf , nwid , ndiw ) ; runClusteringMethod ( testingSet , dtRWPredictor , outputDir , ks , size ) ; } int [ ] closest_k = Main . parseIntList ( System . getProperty ( "plusone.closestKValues" , "1,3,5,10,25,50,100,250,500,1000,10000,100000" ) ) ; KNNSimilarityCacheLocalSVDish KNNSVDcache = null ; LocalSVDish localSVD ; KNNLocalSVDish knnSVD ; if ( Main . testIsEnabled ( "svdishknn" ) ) { int [ ] TODOpar = new int [ ] { 50 , 50 , 50 } ; localSVD = new LocalSVDish ( 3 , TODOpar , TODOpar , TODOpar , TODOpar , TODOpar , trainingSet , terms . size ( ) ) ; KNNSVDcache = new KNNSimilarityCacheLocalSVDish ( trainingSet , testingSet , localSVD ) ; } for ( int ck = 0 ; ck < ( closest_k . length ) ; ck ++ ) { if ( Main . testIsEnabled ( "knn" ) ) { knn = new KNN ( closest_k [ ck ] , trainingSet , paperIndexer , terms , knnSimilarityCache ) ; runClusteringMethod ( testingSet , knn , outputDir , ks , size ) ; } <START_BUG> if ( Main . testIsEnabled ( "KNNLocalSVDish" ) ) { <END_BUG> knnSVD = new KNNLocalSVDish ( closest_k [ ck ] , trainingSet , paperIndexer , terms , KNNSVDcache ) ; runClusteringMethod ( testingSet , knnSVD , outputDir , ks , size ) ; } if ( Main . testIsEnabled ( "knnc" ) ) { knnc = new KNNWithCitation ( closest_k [ ck ] , trainingSet , paperIndexer , knnSimilarityCache , knnGraphDistanceCache , terms ) ; runClusteringMethod ( testingSet , knnc , outputDir , ks , size ) ; } } int [ ] dimensions = Main . parseIntList ( System . getProperty ( "plusone.svdDimensions" , "1,5,10,20" ) ) ; for ( int dk = 0 ; dk < ( dimensions . length ) ; dk ++ ) { if ( Main . testIsEnabled ( "lsi" ) ) { lsi = new LSI ( dimensions [ dk ] , trainingSet , terms ) ; runClusteringMethod ( testingSet , lsi , outputDir , ks , size ) ; } } } public void runClusteringMethod ( List < PredictionPaper > testingSet , ClusteringTest test , File outputDir , int [ ] ks , int size ) { } static double [ ] parseDoubleList ( String s ) { } static int [ ] parseIntList ( String s ) { } static Boolean testIsEnabled ( String testName ) { } public static void main ( String [ ] args ) { } No newline ; at end ; of file ; }
public class DRFATest { static Category cat = Category . getInstance ( DRFATest . class ) ; static int limit ; public static void main ( String [ ] argv ) { } static void usage ( String msg ) { } static void init ( String limitStr ) { } static void test ( ) { } static void delay ( int amount ) { try { <START_BUG> Thread . currentThread ( ) . sleep ( amount ) ; <END_BUG> } catch ( Exception e ) { } } }
public class Main { public static void main ( String [ ] args ) { } private static boolean isNailgun ; public static boolean isNailgun ( ) { } public static void nailMain ( NGContext context ) { } private final Provider < KExceptionManager > kem ; private final Provider < FrontEnd > frontEnd ; private final SimpleScope requestScope ; @ Inject public Main ( Provider < KExceptionManager > kem , Provider < FrontEnd > frontEnd , @ Named ( "requestScope" ) SimpleScope requestScope ) { } public SimpleScope getRequestScope ( ) { } public int runApplication ( String tool , String [ ] args , File workingDir , Map < String , String > env ) { } public int runApplication ( ) { KExceptionManager kem = this . kem . get ( ) ; kem . installForUncaughtExceptions ( ) ; try { <START_BUG> int retval = frontend . get ( ) . main ( ) ; <END_BUG> return retval ; } catch ( ProvisionException e ) { for ( Message m : e . getErrorMessages ( ) ) { if ( ! ( ( m . getCause ( ) ) instanceof KEMException ) ) { throw e ; } else { KEMException ex = ( ( KEMException ) ( m . getCause ( ) ) ) ; ex . register ( kem ) ; } } kem . print ( ) ; return 1 ; } } public static void seedInjector ( SimpleScope scope , String tool , String [ ] args , File workingDir , Map < String , String > env ) { } public static Injector getInjector ( String tool ) { } private static void invalidJarArguments ( ) { } }
public class ResponseEntity < T > extends HttpEntity < T > { private final HttpStatus statusCode ; public ResponseEntity ( HttpStatus statusCode ) { } public ResponseEntity ( T body , HttpStatus statusCode ) { } public ResponseEntity ( MultiValueMap < String , String > headers , HttpStatus statusCode ) { } public ResponseEntity ( T body , MultiValueMap < String , String > headers , HttpStatus statusCode ) { } public HttpStatus getStatusCode ( ) { } @ Override public boolean equals ( Object other ) { } @ Override public int hashCode ( ) { } @ Override public String toString ( ) { } public static ResponseEntity . BodyBuilder status ( HttpStatus status ) { } public static ResponseEntity . BodyBuilder status ( int status ) { } public static ResponseEntity . BodyBuilder ok ( ) { } public static < T > ResponseEntity < T > ok ( T body ) { } public static ResponseEntity . BodyBuilder created ( URI location ) { } public static ResponseEntity . BodyBuilder accepted ( ) { } public static ResponseEntity . HeadersBuilder < ? > noContent ( ) { } public static ResponseEntity . BodyBuilder badRequest ( ) { } public static ResponseEntity . HeadersBuilder < ? > notFound ( ) { } <START_BUG> public static ResponseEntity . HeadersBuilder < ? > unprocessableEntity ( ) { <END_BUG> return ResponseEntity . status ( UNPROCESSABLE_ENTITY ) ; } public interface HeadersBuilder < B extends ResponseEntity . HeadersBuilder < B > > { B header ( String headerName , String ... headerValues ) { } B headers ( HttpHeaders headers ) { } B allow ( HttpMethod ... allowedMethods ) { } B eTag ( String eTag ) { } B lastModified ( long lastModified ) { } B location ( URI location ) { } ResponseEntity < Void > build ( ) { } } public interface BodyBuilder extends ResponseEntity . HeadersBuilder < ResponseEntity . BodyBuilder > { ResponseEntity . BodyBuilder contentLength ( long contentLength ) { } ResponseEntity . BodyBuilder contentType ( MediaType contentType ) { } < T > ResponseEntity < T > body ( T body ) { } } private static class DefaultBuilder implements ResponseEntity . BodyBuilder { private final HttpStatus status ; private final HttpHeaders headers = new HttpHeaders ( ) ; public DefaultBuilder ( HttpStatus status ) { } @ Override public ResponseEntity . BodyBuilder header ( String headerName , String ... headerValues ) { } @ Override public ResponseEntity . BodyBuilder headers ( HttpHeaders headers ) { } @ Override public ResponseEntity . BodyBuilder allow ( HttpMethod ... allowedMethods ) { } @ Override public ResponseEntity . BodyBuilder contentLength ( long contentLength ) { } @ Override public ResponseEntity . BodyBuilder contentType ( MediaType contentType ) { } @ Override public ResponseEntity . BodyBuilder eTag ( String eTag ) { } @ Override public ResponseEntity . BodyBuilder lastModified ( long date ) { } @ Override public ResponseEntity . BodyBuilder location ( URI location ) { } @ Override public ResponseEntity < Void > build ( ) { } @ Override public < T > ResponseEntity < T > body ( T body ) { } } }
public class DanceWithDragonsConstructor extends MatrixConstructor { public static final String CHARACTER_FILE_NAME = "src/main/resources/data/characters/dwd-list-no-dup.txt" ; public static final String TEXT_FILE_NAME = "src/main/resources/text/dancewithdragons.txt" ; public static final int BOOK_NUMBER = 5 ; public static void main ( String [ ] args ) { int fileNum = 1 ; String fileDesc = "no-dup" ; DanceWithDragonsConstructor dwdConstructor = new DanceWithDragonsConstructor ( 15 , 4 ) ; <START_BUG> dwdConstructor . constructMatrix ( LOG_FILE_MATRIX ) ; <END_BUG> dwdConstructor . writeFiles ( fileNum , fileDesc , LOG_FOLDER , false ) ; } public DanceWithDragonsConstructor ( int radius , int noise ) { } }
public class SarStructureProcessor implements DeploymentUnitProcessor { private static final String SAR_EXTENSION = ".sar" ; private static final String JAR_EXTENSION = ".jar" ; private static final SuffixMatchFilter CHILD_ARCHIVE_FILTER = new SuffixMatchFilter ( SarStructureProcessor . JAR_EXTENSION , VisitorAttributes . RECURSE_LEAVES_ONLY ) ; private static Closeable NO_OP_CLOSEABLE = new Closeable ( ) { public void close ( ) throws IOException { } } ; @ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; final ResourceRoot resourceRoot = deploymentUnit . getAttachment ( DEPLOYMENT_ROOT ) ; if ( resourceRoot == null ) { return ; } final VirtualFile deploymentRoot = resourceRoot . getRoot ( ) ; if ( ( deploymentRoot == null ) || ( ! ( deploymentRoot . exists ( ) ) ) ) { return ; } final String deploymentRootName = deploymentRoot . getName ( ) . toLowerCase ( Locale . ENGLISH ) ; if ( ! ( deploymentRootName . endsWith ( SarStructureProcessor . SAR_EXTENSION ) ) ) { return ; } ModuleRootMarker . mark ( resourceRoot , true ) ; Map < String , MountedDeploymentOverlay > overlays = deploymentUnit . getAttachment ( DEPLOYMENT_OVERLAY_LOCATIONS ) ; try { final List < VirtualFile > childArchives = deploymentRoot . getChildren ( SarStructureProcessor . CHILD_ARCHIVE_FILTER ) ; for ( final VirtualFile child : childArchives ) { String relativeName = child . getPathNameRelativeTo ( deploymentRoot ) ; MountedDeploymentOverlay overlay = overlays . get ( relativeName ) ; Closeable closable = SarStructureProcessor . NO_OP_CLOSEABLE ; if ( overlay != null ) { overlay . remountAsZip ( false ) ; } else if ( child . isFile ( ) ) { closable = VFS . mountZip ( child , child , TempFileProviderService . provider ( ) ) ; } final MountHandle mountHandle = new MountHandle ( closable ) ; final ResourceRoot childResource = new ResourceRoot ( child , mountHandle ) ; ModuleRootMarker . mark ( childResource ) ; deploymentUnit . addToAttachmentList ( RESOURCE_ROOTS , childResource ) ; resourceRoot . addToAttachmentList ( INDEX_IGNORE_PATHS , child . getPathNameRelativeTo ( deploymentRoot ) ) ; } } catch ( IOException e ) { <START_BUG> MESSAGES . failedToProcessSarChild ( e , deploymentRoot ) ; <END_BUG> } } @ Override public void undeploy ( DeploymentUnit context ) { } }
public class AlgoPerimeterPoly extends AlgoElement { private GeoPolygon polygon ; private GeoNumeric circum ; public AlgoPerimeterPoly ( Construction cons , String label , GeoPolygon polygon ) { } AlgoPerimeterPoly ( Construction cons , GeoPolygon polygon ) { } @ Override public Algos getClassName ( ) { } @ Override protected void setInputOutput ( ) { } @ Override public final void compute ( ) { if ( ! ( polygon . isDefined ( ) ) ) { circum . setUndefined ( ) ; return ; } GeoSegmentND [ ] segment = polygon . getSegments ( ) ; double length = 0 ; <START_BUG> for ( int i = 0 ; i < ( segment . length ) ; i ++ ) { <END_BUG> length = length + ( segment [ i ] . getLength ( ) ) ; } circum . setValue ( length ) ; } public GeoNumeric getCircumference ( ) { } }
