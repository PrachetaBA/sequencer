public class InvalidMatrixExceptionTest extends TestCase { public void testConstructorMessage ( ) { String msg = "message" ; <START_BUG> InvalidMatrixException ex = new InvalidMatrixException ( msg , new Object [ 0 ] ) ; <END_BUG> assertEquals ( msg , ex . getMessage ( ) ) ; } }
public class AboutPluginsDialog extends ProductInfoDialog { private static final int TABLE_HEIGHT = 200 ; private static final IPath baseNLPath = new Path ( "$nl$" ) ; private static final String PLUGININFO = "about.html" ; private static final int MORE_ID = ( IDialogConstants . CLIENT_ID ) + 1 ; private Table vendorInfo ; private Button moreInfo ; private String title ; private String message ; private String helpContextId ; private String [ ] columnTitles = new String [ ] { WorkbenchMessages . AboutPluginsDialog_provider , WorkbenchMessages . AboutPluginsDialog_pluginName , WorkbenchMessages . AboutPluginsDialog_version , WorkbenchMessages . AboutPluginsDialog_pluginId } ; private String productName ; private AboutBundleData [ ] bundleInfos ; private int lastColumnChosen = 0 ; private boolean reverseSort = false ; private AboutBundleData lastSelection = null ; public AboutPluginsDialog ( Shell parentShell , String productName ) { } public AboutPluginsDialog ( Shell parentShell , String productName , Bundle [ ] bundles , String title , String message , String helpContextId ) { } protected void buttonPressed ( int buttonId ) { } protected void configureShell ( Shell newShell ) { } protected void createButtonsForButtonBar ( Composite parent ) { } protected Control createDialogArea ( Composite parent ) { } protected void createTable ( Composite parent ) { } private boolean selectionHasInfo ( ) { } private boolean tableHasSelection ( ) { } protected void handleMoreInfoPressed ( ) { } private void sort ( int column ) { } private void refreshTable ( int col ) { } private static String [ ] createRow ( AboutBundleData info ) { } private URL getMoreInfoURL ( AboutBundleData bundleInfo , boolean makeLocal ) { Bundle bundle = Platform . getBundle ( bundleInfo . getId ( ) ) ; if ( bundle == null ) return null ; URL aboutUrl = Platform . find ( bundle , AboutPluginsDialog . baseNLPath . append ( AboutPluginsDialog . PLUGININFO ) , null ) ; if ( ! makeLocal ) { return aboutUrl ; } if ( aboutUrl != null ) { try { URL result = Platform . asLocalURL ( aboutUrl ) ; try { <START_BUG> URL about = new URL ( aboutUrl , "about" ) ; <END_BUG> if ( about != null ) Platform . asLocalURL ( about ) ; } catch ( IOException e ) { } return result ; } catch ( IOException e ) { } } return null ; } }
public class NumberUtils { public static final Long LONG_ZERO = Long . valueOf ( 0L ) ; public static final Long LONG_ONE = Long . valueOf ( 1L ) ; public static final Long LONG_MINUS_ONE = Long . valueOf ( ( - 1L ) ) ; public static final Integer INTEGER_ZERO = Integer . valueOf ( 0 ) ; public static final Integer INTEGER_ONE = Integer . valueOf ( 1 ) ; public static final Integer INTEGER_MINUS_ONE = Integer . valueOf ( ( - 1 ) ) ; public static final Short SHORT_ZERO = Short . valueOf ( ( ( short ) ( 0 ) ) ) ; public static final Short SHORT_ONE = Short . valueOf ( ( ( short ) ( 1 ) ) ) ; public static final Short SHORT_MINUS_ONE = Short . valueOf ( ( ( short ) ( - 1 ) ) ) ; public static final Byte BYTE_ZERO = Byte . valueOf ( ( ( byte ) ( 0 ) ) ) ; public static final Byte BYTE_ONE = Byte . valueOf ( ( ( byte ) ( 1 ) ) ) ; public static final Byte BYTE_MINUS_ONE = Byte . valueOf ( ( ( byte ) ( - 1 ) ) ) ; public static final Double DOUBLE_ZERO = Double . valueOf ( 0.0 ) ; public static final Double DOUBLE_ONE = Double . valueOf ( 1.0 ) ; public static final Double DOUBLE_MINUS_ONE = Double . valueOf ( ( - 1.0 ) ) ; public static final Float FLOAT_ZERO = Float . valueOf ( 0.0F ) ; public static final Float FLOAT_ONE = Float . valueOf ( 1.0F ) ; public static final Float FLOAT_MINUS_ONE = Float . valueOf ( ( - 1.0F ) ) ; public NumberUtils ( ) { } public static int toInt ( final String str ) { } public static int toInt ( final String str , final int defaultValue ) { } public static long toLong ( final String str ) { } public static long toLong ( final String str , final long defaultValue ) { } public static float toFloat ( final String str ) { } public static float toFloat ( final String str , final float defaultValue ) { } public static double toDouble ( final String str ) { } public static double toDouble ( final String str , final double defaultValue ) { } public static byte toByte ( final String str ) { } public static byte toByte ( final String str , final byte defaultValue ) { } public static short toShort ( final String str ) { } public static short toShort ( final String str , final short defaultValue ) { } public static Number createNumber ( final String str ) throws NumberFormatException { } private static boolean isAllZeros ( final String str ) { } public static Float createFloat ( final String str ) { } public static Double createDouble ( final String str ) { } public static Integer createInteger ( final String str ) { } public static Long createLong ( final String str ) { } public static BigInteger createBigInteger ( final String str ) { if ( str == null ) { return null ; } int pos = 0 ; int radix = 10 ; boolean negate = false ; if ( str . startsWith ( "-" ) ) { negate = true ; pos = 1 ; } <START_BUG> if ( ( str . startsWith ( "0x" , pos ) ) || ( str . startsWith ( "0x" , pos ) ) ) { <END_BUG> radix = 16 ; pos += 2 ; } else if ( str . startsWith ( "#" , pos ) ) { radix = 16 ; pos ++ ; } else if ( ( str . startsWith ( "0" , pos ) ) && ( ( str . length ( ) ) > ( pos + 1 ) ) ) { radix = 8 ; pos ++ ; } final BigInteger value = new BigInteger ( str . substring ( pos ) , radix ) ; return negate ? value . negate ( ) : value ; } public static BigDecimal createBigDecimal ( final String str ) { } public static long min ( final long ... array ) { } public static int min ( final int ... array ) { } public static short min ( final short ... array ) { } public static byte min ( final byte ... array ) { } public static double min ( final double ... array ) { } public static float min ( final float ... array ) { } public static long max ( final long ... array ) { } public static int max ( final int ... array ) { } public static short max ( final short ... array ) { } public static byte max ( final byte ... array ) { } public static double max ( final double ... array ) { } public static float max ( final float ... array ) { } private static void validateArray ( final Object array ) { } public static long min ( long a , final long b , final long c ) { } public static int min ( int a , final int b , final int c ) { } public static short min ( short a , final short b , final short c ) { } public static byte min ( byte a , final byte b , final byte c ) { } public static double min ( final double a , final double b , final double c ) { } public static float min ( final float a , final float b , final float c ) { } public static long max ( long a , final long b , final long c ) { }
public class Main { private static final int nTrialsPerPaper = 12 ; private Indexer < String > wordIndexer ; private Indexer < PaperAbstract > paperIndexer ; private Terms terms ; private KNNSimilarityCache knnSimilarityCache ; private KNNGraphDistanceCache knnGraphDistanceCache ; private static MetadataLogger metadataLogger ; private static Random randGen ; public List < TrainingPaper > trainingSet ; public List < PredictionPaper > testingSet ; private Baseline baseline ; private CommonNeighbors cn ; private DTRandomWalkPredictor dtRWPredictor ; private KNN knn ; private KNNWithCitation knnc ; private LSI lsi ; public Main ( long randomSeed ) { } public void load_data ( String filename , double trainPercent ) { } private void splitByTrainPercent ( double trainPercent , List < PaperAbstract > documents ) { } public void splitHeldoutWords ( double testWordPercent ) { } public static Random getRandomGenerator ( ) { } public static MetadataLogger getMetadataLogger ( ) { } public double [ ] evaluate ( PredictionPaper testingPaper , Integer [ ] prediction , int size , int k ) { } public static void printResults ( double [ ] results ) { } public static void printResults ( File output , double [ ] results ) { } public void runClusteringMethods ( File outputDir , int [ ] ks ) { int size = ( trainingSet . size ( ) ) + ( testingSet . size ( ) ) ; if ( Main . testIsEnabled ( "baseline" ) ) { baseline = new Baseline ( trainingSet , terms ) ; runClusteringMethod ( testingSet , baseline , outputDir , ks , size ) ; } if ( Main . testIsEnabled ( "dtrw" ) ) { int rwLength = Integer . getInteger ( "plusone.dtrw.walkLength" , 4 ) ; boolean stoch = Boolean . getBoolean ( "plusone.dtrw.stochastic" ) ; int nSampleWalks = Integer . getInteger ( "plusone.dtrw.nSampleWalks" ) ; System . out . println ( ( "Random<seq2seq4repair_space>walk<seq2seq4repair_space>length:<seq2seq4repair_space>" + rwLength ) ) ; if ( stoch ) System . out . println ( ( ( "Stochastic<seq2seq4repair_space>random<seq2seq4repair_space>walk:<seq2seq4repair_space>" + nSampleWalks ) + "<seq2seq4repair_space>samples." ) ) ; boolean finalIdf = Boolean . getBoolean ( "plusone.dtrw.finalIdf" ) ; boolean ndiw = Boolean . getBoolean ( "plusone.dtrw.normalizeDocsInWord" ) ; Boolean nwid = Boolean . getBoolean ( "plusone.dtrw.normalizeWordsInDoc" ) ; dtRWPredictor = new DTRandomWalkPredictor ( trainingSet , terms , rwLength , stoch , nSampleWalks , finalIdf , nwid , ndiw ) ; runClusteringMethod ( testingSet , dtRWPredictor , outputDir , ks , size ) ; } int [ ] closest_k = Main . parseIntList ( System . getProperty ( "plusone.closestKValues" , "1,3,5,10,25,50,100,250,500,1000,10000,100000" ) ) ; KNNSimilarityCacheLocalSVDish KNNSVDcache = null ; LocalSVDish localSVD ; KNNLocalSVDish knnSVD ; if ( Main . testIsEnabled ( "svdishknn" ) ) { int [ ] TODOpar = new int [ ] { 50 , 50 , 50 } ; localSVD = new LocalSVDish ( 3 , TODOpar , TODOpar , TODOpar , TODOpar , TODOpar , trainingSet , terms . size ( ) ) ; KNNSVDcache = new KNNSimilarityCacheLocalSVDish ( trainingSet , testingSet , localSVD ) ; } for ( int ck = 0 ; ck < ( closest_k . length ) ; ck ++ ) { if ( Main . testIsEnabled ( "knn" ) ) { knn = new KNN ( closest_k [ ck ] , trainingSet , paperIndexer , terms , knnSimilarityCache ) ; runClusteringMethod ( testingSet , knn , outputDir , ks , size ) ; } <START_BUG> if ( Main . testIsEnabled ( "KNNLocalSVDish" ) ) { <END_BUG> knnSVD = new KNNLocalSVDish ( closest_k [ ck ] , trainingSet , paperIndexer , terms , KNNSVDcache ) ; runClusteringMethod ( testingSet , knnSVD , outputDir , ks , size ) ; } if ( Main . testIsEnabled ( "knnc" ) ) { knnc = new KNNWithCitation ( closest_k [ ck ] , trainingSet , paperIndexer , knnSimilarityCache , knnGraphDistanceCache , terms ) ; runClusteringMethod ( testingSet , knnc , outputDir , ks , size ) ; } } int [ ] dimensions = Main . parseIntList ( System . getProperty ( "plusone.svdDimensions" , "1,5,10,20" ) ) ; for ( int dk = 0 ; dk < ( dimensions . length ) ; dk ++ ) { if ( Main . testIsEnabled ( "lsi" ) ) { lsi = new LSI ( dimensions [ dk ] , trainingSet , terms ) ; runClusteringMethod ( testingSet , lsi , outputDir , ks , size ) ; } } } public void runClusteringMethod ( List < PredictionPaper > testingSet , ClusteringTest test , File outputDir , int [ ] ks , int size ) { } static double [ ] parseDoubleList ( String s ) { } static int [ ] parseIntList ( String s ) { } static Boolean testIsEnabled ( String testName ) { } public static void main ( String [ ] args ) { } No newline ; at end ; of file ; }
public class DRFATest { static Category cat = Category . getInstance ( DRFATest . class ) ; static int limit ; public static void main ( String [ ] argv ) { } static void usage ( String msg ) { } static void init ( String limitStr ) { } static void test ( ) { } static void delay ( int amount ) { try { <START_BUG> Thread . currentThread ( ) . sleep ( amount ) ; <END_BUG> } catch ( Exception e ) { } } }
public class Main { public static void main ( String [ ] args ) { } private static boolean isNailgun ; public static boolean isNailgun ( ) { } public static void nailMain ( NGContext context ) { } private final Provider < KExceptionManager > kem ; private final Provider < FrontEnd > frontEnd ; private final SimpleScope requestScope ; @ Inject public Main ( Provider < KExceptionManager > kem , Provider < FrontEnd > frontEnd , @ Named ( "requestScope" ) SimpleScope requestScope ) { } public SimpleScope getRequestScope ( ) { } public int runApplication ( String tool , String [ ] args , File workingDir , Map < String , String > env ) { } public int runApplication ( ) { KExceptionManager kem = this . kem . get ( ) ; kem . installForUncaughtExceptions ( ) ; try { <START_BUG> int retval = frontend . get ( ) . main ( ) ; <END_BUG> return retval ; } catch ( ProvisionException e ) { for ( Message m : e . getErrorMessages ( ) ) { if ( ! ( ( m . getCause ( ) ) instanceof KEMException ) ) { throw e ; } else { KEMException ex = ( ( KEMException ) ( m . getCause ( ) ) ) ; ex . register ( kem ) ; } } kem . print ( ) ; return 1 ; } } public static void seedInjector ( SimpleScope scope , String tool , String [ ] args , File workingDir , Map < String , String > env ) { } public static Injector getInjector ( String tool ) { } private static void invalidJarArguments ( ) { } }
public class ResponseEntity < T > extends HttpEntity < T > { private final HttpStatus statusCode ; public ResponseEntity ( HttpStatus statusCode ) { } public ResponseEntity ( T body , HttpStatus statusCode ) { } public ResponseEntity ( MultiValueMap < String , String > headers , HttpStatus statusCode ) { } public ResponseEntity ( T body , MultiValueMap < String , String > headers , HttpStatus statusCode ) { } public HttpStatus getStatusCode ( ) { } @ Override public boolean equals ( Object other ) { } @ Override public int hashCode ( ) { } @ Override public String toString ( ) { } public static ResponseEntity . BodyBuilder status ( HttpStatus status ) { } public static ResponseEntity . BodyBuilder status ( int status ) { } public static ResponseEntity . BodyBuilder ok ( ) { } public static < T > ResponseEntity < T > ok ( T body ) { } public static ResponseEntity . BodyBuilder created ( URI location ) { } public static ResponseEntity . BodyBuilder accepted ( ) { } public static ResponseEntity . HeadersBuilder < ? > noContent ( ) { } public static ResponseEntity . BodyBuilder badRequest ( ) { } public static ResponseEntity . HeadersBuilder < ? > notFound ( ) { } <START_BUG> public static ResponseEntity . HeadersBuilder < ? > unprocessableEntity ( ) { <END_BUG> return ResponseEntity . status ( UNPROCESSABLE_ENTITY ) ; } public interface HeadersBuilder < B extends ResponseEntity . HeadersBuilder < B > > { B header ( String headerName , String ... headerValues ) { } B headers ( HttpHeaders headers ) { } B allow ( HttpMethod ... allowedMethods ) { } B eTag ( String eTag ) { } B lastModified ( long lastModified ) { } B location ( URI location ) { } ResponseEntity < Void > build ( ) { } } public interface BodyBuilder extends ResponseEntity . HeadersBuilder < ResponseEntity . BodyBuilder > { ResponseEntity . BodyBuilder contentLength ( long contentLength ) { } ResponseEntity . BodyBuilder contentType ( MediaType contentType ) { } < T > ResponseEntity < T > body ( T body ) { } } private static class DefaultBuilder implements ResponseEntity . BodyBuilder { private final HttpStatus status ; private final HttpHeaders headers = new HttpHeaders ( ) ; public DefaultBuilder ( HttpStatus status ) { } @ Override public ResponseEntity . BodyBuilder header ( String headerName , String ... headerValues ) { } @ Override public ResponseEntity . BodyBuilder headers ( HttpHeaders headers ) { } @ Override public ResponseEntity . BodyBuilder allow ( HttpMethod ... allowedMethods ) { } @ Override public ResponseEntity . BodyBuilder contentLength ( long contentLength ) { } @ Override public ResponseEntity . BodyBuilder contentType ( MediaType contentType ) { } @ Override public ResponseEntity . BodyBuilder eTag ( String eTag ) { } @ Override public ResponseEntity . BodyBuilder lastModified ( long date ) { } @ Override public ResponseEntity . BodyBuilder location ( URI location ) { } @ Override public ResponseEntity < Void > build ( ) { } @ Override public < T > ResponseEntity < T > body ( T body ) { } } }
public class DanceWithDragonsConstructor extends MatrixConstructor { public static final String CHARACTER_FILE_NAME = "src/main/resources/data/characters/dwd-list-no-dup.txt" ; public static final String TEXT_FILE_NAME = "src/main/resources/text/dancewithdragons.txt" ; public static final int BOOK_NUMBER = 5 ; public static void main ( String [ ] args ) { int fileNum = 1 ; String fileDesc = "no-dup" ; DanceWithDragonsConstructor dwdConstructor = new DanceWithDragonsConstructor ( 15 , 4 ) ; <START_BUG> dwdConstructor . constructMatrix ( LOG_FILE_MATRIX ) ; <END_BUG> dwdConstructor . writeFiles ( fileNum , fileDesc , LOG_FOLDER , false ) ; } public DanceWithDragonsConstructor ( int radius , int noise ) { } }
public class SarStructureProcessor implements DeploymentUnitProcessor { private static final String SAR_EXTENSION = ".sar" ; private static final String JAR_EXTENSION = ".jar" ; private static final SuffixMatchFilter CHILD_ARCHIVE_FILTER = new SuffixMatchFilter ( SarStructureProcessor . JAR_EXTENSION , VisitorAttributes . RECURSE_LEAVES_ONLY ) ; private static Closeable NO_OP_CLOSEABLE = new Closeable ( ) { public void close ( ) throws IOException { } } ; @ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; final ResourceRoot resourceRoot = deploymentUnit . getAttachment ( DEPLOYMENT_ROOT ) ; if ( resourceRoot == null ) { return ; } final VirtualFile deploymentRoot = resourceRoot . getRoot ( ) ; if ( ( deploymentRoot == null ) || ( ! ( deploymentRoot . exists ( ) ) ) ) { return ; } final String deploymentRootName = deploymentRoot . getName ( ) . toLowerCase ( Locale . ENGLISH ) ; if ( ! ( deploymentRootName . endsWith ( SarStructureProcessor . SAR_EXTENSION ) ) ) { return ; } ModuleRootMarker . mark ( resourceRoot , true ) ; Map < String , MountedDeploymentOverlay > overlays = deploymentUnit . getAttachment ( DEPLOYMENT_OVERLAY_LOCATIONS ) ; try { final List < VirtualFile > childArchives = deploymentRoot . getChildren ( SarStructureProcessor . CHILD_ARCHIVE_FILTER ) ; for ( final VirtualFile child : childArchives ) { String relativeName = child . getPathNameRelativeTo ( deploymentRoot ) ; MountedDeploymentOverlay overlay = overlays . get ( relativeName ) ; Closeable closable = SarStructureProcessor . NO_OP_CLOSEABLE ; if ( overlay != null ) { overlay . remountAsZip ( false ) ; } else if ( child . isFile ( ) ) { closable = VFS . mountZip ( child , child , TempFileProviderService . provider ( ) ) ; } final MountHandle mountHandle = new MountHandle ( closable ) ; final ResourceRoot childResource = new ResourceRoot ( child , mountHandle ) ; ModuleRootMarker . mark ( childResource ) ; deploymentUnit . addToAttachmentList ( RESOURCE_ROOTS , childResource ) ; resourceRoot . addToAttachmentList ( INDEX_IGNORE_PATHS , child . getPathNameRelativeTo ( deploymentRoot ) ) ; } } catch ( IOException e ) { <START_BUG> MESSAGES . failedToProcessSarChild ( e , deploymentRoot ) ; <END_BUG> } } @ Override public void undeploy ( DeploymentUnit context ) { } }
public class AlgoPerimeterPoly extends AlgoElement { private GeoPolygon polygon ; private GeoNumeric circum ; public AlgoPerimeterPoly ( Construction cons , String label , GeoPolygon polygon ) { } AlgoPerimeterPoly ( Construction cons , GeoPolygon polygon ) { } @ Override public Algos getClassName ( ) { } @ Override protected void setInputOutput ( ) { } @ Override public final void compute ( ) { if ( ! ( polygon . isDefined ( ) ) ) { circum . setUndefined ( ) ; return ; } GeoSegmentND [ ] segment = polygon . getSegments ( ) ; double length = 0 ; <START_BUG> for ( int i = 0 ; i < ( segment . length ) ; i ++ ) { <END_BUG> length = length + ( segment [ i ] . getLength ( ) ) ; } circum . setValue ( length ) ; } public GeoNumeric getCircumference ( ) { } }
public class CtsJavaScannerDoclet extends Doclet { private static final String JUNIT4_TEST_ANNOTATION = "org.junit.Test" ; static final String JUNIT_TEST_CASE_CLASS_NAME = "junit.framework.testcase" ; public static boolean start ( RootDoc root ) { ClassDoc [ ] classes = root . classes ( ) ; if ( classes == null ) { return false ; } PrintWriter writer = new PrintWriter ( System . out ) ; for ( ClassDoc clazz : classes ) { if ( clazz . isAbstract ( ) ) { continue ; } final boolean isJUnit3 = CtsJavaScannerDoclet . isJUnit3TestCase ( clazz ) ; if ( ( ! isJUnit3 ) && ( ! ( CtsJavaScannerDoclet . isJUnit4TestClass ( clazz ) ) ) ) { continue ; } writer . append ( "suite:" ) . println ( clazz . containingPackage ( ) . name ( ) ) ; writer . append ( "case:" ) . println ( clazz . name ( ) ) ; for ( ; clazz != null ; clazz = clazz . superclass ( ) ) { for ( MethodDoc method : clazz . methods ( ) ) { int timeout = - 1 ; if ( isJUnit3 ) { if ( ! ( method . name ( ) . startsWith ( "test" ) ) ) { continue ; } AnnotationDesc [ ] annotations = method . annotations ( ) ; for ( AnnotationDesc annot : annotations ) { String atype = annot . annotationType ( ) . toString ( ) ; <START_BUG> if ( atype . equals ( "android.cts.util.TimeoutReq" ) ) { <END_BUG> ElementValuePair [ ] cpairs = annot . elementValues ( ) ; for ( ElementValuePair pair : cpairs ) { AnnotationTypeElementDoc elem = pair . element ( ) ; AnnotationValue value = pair . value ( ) ; if ( elem . name ( ) . equals ( "minutes" ) ) { timeout = ( ( Integer ) ( value . value ( ) ) ) ; } } } } } else { boolean isTest = false ; for ( AnnotationDesc annot : method . annotations ( ) ) { if ( annot . annotationType ( ) . toString ( ) . equals ( CtsJavaScannerDoclet . JUNIT4_TEST_ANNOTATION ) ) { isTest = true ; for ( ElementValuePair pair : annot . elementValues ( ) ) { if ( pair . element ( ) . name ( ) . equals ( "timeout" ) ) { timeout = ( ( int ) ( ( ( Long ) ( pair . value ( ) . value ( ) ) ) / 60000L ) ) ; } } } } if ( ! isTest ) { continue ; } } writer . append ( "test:" ) ; if ( timeout >= 0 ) { writer . append ( method . name ( ) ) . println ( ( ":" + timeout ) ) ; } else { writer . println ( method . name ( ) ) ; } } } } writer . close ( ) ; return true ; } private static boolean isJUnit3TestCase ( ClassDoc clazz ) { } private static boolean isJUnit4TestClass ( ClassDoc clazz ) { } }
public class QRSolverTest extends TestCase { double [ ] [ ] testData3x3NonSingular = new double [ ] [ ] { new double [ ] { 12 , - 51 , 4 } , new double [ ] { 6 , 167 , - 68 } , new double [ ] { - 4 , 24 , - 41 } } ; double [ ] [ ] testData3x3Singular = new double [ ] [ ] { new double [ ] { 1 , 4 , 7 } , new double [ ] { 2 , 5 , 8 } , new double [ ] { 3 , 6 , 9 } } ; double [ ] [ ] testData3x4 = new double [ ] [ ] { new double [ ] { 12 , - 51 , 4 , 1 } , new double [ ] { 6 , 167 , - 68 , 2 } , new double [ ] { - 4 , 24 , - 41 , 3 } } ; double [ ] [ ] testData4x3 = new double [ ] [ ] { new double [ ] { 12 , - 51 , 4 } , new double [ ] { 6 , 167 , - 68 } , new double [ ] { - 4 , 24 , - 41 } , new double [ ] { - 5 , 34 , 7 } } ; public QRSolverTest ( String name ) { } public static Test suite ( ) { } public void testRank ( ) { QRSolver solver = new QRSolver ( new QRDecompositionImpl ( MatrixUtils . createRealMatrix ( testData3x3NonSingular ) ) ) ; assertTrue ( solver . isNonSingular ( ) ) ; solver = new QRSolver ( new QRDecompositionImpl ( MatrixUtils . createRealMatrix ( testData3x3Singular ) ) ) ; assertFalse ( solver . isNonSingular ( ) ) ; solver = new QRSolver ( new QRDecompositionImpl ( MatrixUtils . createRealMatrix ( testData3x4 ) ) ) ; <START_BUG> assertTrue ( solver . isNonSingular ( ) ) ; <END_BUG> solver = new QRSolver ( new QRDecompositionImpl ( MatrixUtils . createRealMatrix ( testData4x3 ) ) ) ; assertTrue ( solver . isNonSingular ( ) ) ; } public void testSolveDimensionErrors ( ) { } public void testSolveRankErrors ( ) { } public void testSolve ( ) { } }
public class SweetSpotSimilarityTest extends LuceneTestCase { public static float computeAndDecodeNorm ( SweetSpotSimilarity decode , Similarity encode , FieldInvertState state ) { } public static byte computeAndGetNorm ( Similarity s , FieldInvertState state ) { } public void testSweetSpotComputeNorm ( ) { } public void testSweetSpotTf ( ) { } public void testHyperbolicSweetSpot ( ) { SweetSpotSimilarity ss = new SweetSpotSimilarity ( ) { @ Override <START_BUG> public float tf ( int freq ) { <END_BUG> return hyperbolicTf ( freq ) ; } } ; ss . setHyperbolicTfFactors ( 3.3F , 7.7F , Math . E , 5.0F ) ; TFIDFSimilarity s = ss ; for ( int i = 1 ; i <= 1000 ; i ++ ) { assertTrue ( ( ( ( "MIN<seq2seq4repair_space>tf:<seq2seq4repair_space>i=" + i ) + "<seq2seq4repair_space>:<seq2seq4repair_space>s=" ) + ( s . tf ( i ) ) ) , ( 3.3F <= ( s . tf ( i ) ) ) ) ; assertTrue ( ( ( ( "MAX<seq2seq4repair_space>tf:<seq2seq4repair_space>i=" + i ) + "<seq2seq4repair_space>:<seq2seq4repair_space>s=" ) + ( s . tf ( i ) ) ) , ( ( s . tf ( i ) ) <= 7.7F ) ) ; } assertEquals ( "MID<seq2seq4repair_space>tf" , ( 3.3F + ( ( 7.7F - 3.3F ) / 2.0F ) ) , s . tf ( 5 ) , 1.0E-5F ) ; assertEquals ( "tf<seq2seq4repair_space>zero" , 0.0F , s . tf ( 0 ) , 0.0F ) ; } }
public final class IndexStructClassic extends IndexStructAbs { private HashTableIndex map ; private static Logger logger = Logger . getLogger ( IndexStructClassic . class ) ; public IndexStructClassic ( String idStorage , String idTestVector , ConfigServer configStore , int testVector , Object database ) throws ReadIndexException , StartIndexException { } public boolean isCompressIndexEnabled ( ) { } public void delete ( Map < Long , Integer > mapID ) { } public void put ( ConcurrentHashMap < String , Long > visualWords , Long I ) { for ( Map . Entry < String , Long > entry : visualWords . entrySet ( ) ) { ValueStructure valueStruct = map . get ( entry . getKey ( ) ) ; <START_BUG> if ( ( ! ( isCompressIndexEnabled ( ) ) ) || ( ! ( compressIndex . isBlackListed ( entry . getKey ( ) ) ) ) ) { <END_BUG> if ( valueStruct == null ) { valueStruct = new ValueStructure ( configStore ) ; } if ( addListIndex ( valueStruct , I , entry . getValue ( ) . intValue ( ) ) ) { if ( ( ! ( isCompressIndexEnabled ( ) ) ) || ( ! ( compressIndex . isNBTTooBig ( valueStruct . getNBT ( ) ) ) ) ) { map . put ( entry . getKey ( ) , valueStruct ) ; } else { compressIndex . blacklistVW ( entry . getKey ( ) ) ; map . delete ( entry . getKey ( ) ) ; } } } } } public ConcurrentHashMap < String , Long > getNBT ( ConcurrentHashMap < String , Long > visualWord ) { } @ Override public Map < String , ValueStructure > getAll ( List < String > B ) { } public void closeIndex ( ) throws CloseIndexException { } public void sync ( ) { } public void printStat ( ) { } public boolean isRessourcePresent ( Long id ) { } }
public class Main { public static void main ( String [ ] args ) throws Exception { Options options = new Options ( args ) ; System . out . println ( options ) ; if ( ( ( options . train ) && ( ( options . trainPath ) != "" ) ) && ( ( options . modelPath ) != "" ) ) <START_BUG> Trainer . train ( options , 21 ) ; <END_BUG> else if ( ( ( ( options . tag ) && ( ( options . inputPath ) != "" ) ) && ( ( options . modelPath ) != "" ) ) && ( ( options . outputPath ) != "" ) ) { Tagger tagger = new Tagger ( options . modelPath ) ; tagger . tag ( options . inputPath , options . outputPath , options . delim ) ; } else if ( ( ( ( options . tagPartial ) && ( ( options . inputPath ) != "" ) ) && ( ( options . modelPath ) != "" ) ) && ( ( options . outputPath ) != "" ) ) { Tagger tagger = new Tagger ( options . modelPath ) ; tagger . partialTag ( options . inputPath , options . outputPath , options . delim ) ; } else System . out . println ( options . showHelp ( ) ) ; } }
public class CriteriaQueryImpl < T > implements CriteriaQuery < T > , AliasContext { private final MetamodelImpl _model ; private Set < Root < ? > > _roots ; private PredicateImpl _where ; private List < Order > _orders ; private Set < ParameterExpression < ? > > _params ; private List < Selection < ? > > _selections ; private List < Expression < ? > > _groups ; private PredicateImpl _having ; private List < Subquery < ? > > _subqueries ; private Boolean _distinct ; private SubqueryImpl < ? > _delegator ; private final Class < T > _resultClass ; private Class < ? > _runtimeResultClass ; private int aliasCount = 0 ; private static String ALIAS_BASE = "autoAlias" ; private Map < Selection < ? > , Value > _variables = new HashMap < Selection < ? > , Value > ( ) ; private Map < Selection < ? > , Value > _values = new HashMap < Selection < ? > , Value > ( ) ; private Map < Selection < ? > , String > _aliases = null ; private Map < Selection < ? > , Value > _rootVariables = new HashMap < Selection < ? > , Value > ( ) ; private Stack < Context > _contexts = null ; public CriteriaQueryImpl ( MetamodelImpl model , Class < T > resultClass ) { } public CriteriaQueryImpl ( MetamodelImpl model , SubqueryImpl < T > delegator ) { } public void setDelegator ( SubqueryImpl < ? > delegator ) { } public SubqueryImpl < ? > getDelegator ( ) { } public MetamodelImpl getMetamodel ( ) { } public Stack < Context > getContexts ( ) { } public CriteriaQuery < T > distinct ( boolean distinct ) { } public List < Order > getOrderList ( ) { } public Selection < T > getSelection ( ) { } public CriteriaQuery < T > multiselect ( Selection < ? > ... selections ) { } public void registerParameter ( ParameterExpressionImpl < ? > p ) { if ( ( _params ) == null ) _params = new HashSet < ParameterExpression < ? > > ( ) ; if ( _params . add ( p ) ) { <START_BUG> p . setIndex ( _params . size ( ) ) ; <END_BUG> } } public Set < ParameterExpression < ? > > getParameters ( ) { } public List < Selection < ? > > getSelectionList ( ) { } public CriteriaQuery < T > groupBy ( Expression < ? > ... grouping ) { } public CriteriaQuery < T > having ( Expression < Boolean > restriction ) { } public CriteriaQuery < T > having ( Predicate ... restrictions ) { } public CriteriaQuery < T > orderBy ( Order ... o ) { } public CriteriaQuery < T > select ( Selection < ? extends T > selection ) { } public CriteriaQuery < T > select ( Selection < ? > ... selections ) { } public CriteriaQuery < T > where ( Expression < Boolean > restriction ) { } public CriteriaQuery < T > where ( Predicate ... restrictions ) { } public < X > Root < X > from ( EntityType < X > entity ) { } public < X > Root < X > from ( Class < X > cls ) { } public List < Expression < ? > > getGroupList ( ) { } public PredicateImpl getGroupRestriction ( ) { } public PredicateImpl getRestriction ( ) { } public Set < Root < ? > > getRoots ( ) { } public void setRoots ( Set < Root < ? > > roots ) { } public Root < ? > getRoot ( ) { } public boolean isDistinct ( ) { } public Boolean getDistinct ( ) { } public < U > Subquery < U > subquery ( Class < U > type ) { } public LinkedMap getParameterTypes ( ) { } QueryExpressions getQueryExpressions ( ExpressionFactory factory ) { } public void assertRoot ( ) { } public void setContexts ( Stack < Context > contexts ) { } public CriteriaQueryImpl < ? > getAncestor ( ) { } public Map < Selection < ? > , String > getAliases ( ) { } public Context ctx ( ) { } public String getAlias ( Selection < ? > selection ) { } public Value getVariable ( Selection < ? > selection ) { } public Value getValue ( Selection < ? > selection ) { } public void registerVariable ( Selection < ? > node , Value var , Value path ) { } public boolean isRegistered ( Selection < ? > selection ) { } public Value getRegisteredVariable ( Selection < ? > selection ) { } public Value getRegisteredValue ( Selection < ? > selection ) { } public void registerRoot ( Root < ? > root , Value var ) { } public Value getRootVariable ( Root < ? > root ) { } public Value getRegisteredRootVariable ( Root < ? > root ) { } public Class < T > getResultType ( ) { } public Class < ? > getRuntimeResultClass ( ) { } public CriteriaQuery < T > multiselect ( List < Selection < ? > > list ) { } }
public class PublishedGraphTracker implements ISharedObject { private static final ID [ ] NO_GRAPHS = new ID [ ] { } ; private static final int ADD = 0 ; private static final int REMOVE = 1 ; private static final int LEAVE = 2 ; private static final String ARG_TABLE = "table" ; private class Table { private final Hashtable graphs = new Hashtable ( ) ; private final Hashtable containers = new Hashtable ( ) ; public synchronized void add ( ID containerID , ID graphID ) { } public synchronized void remove ( ID containerID , ID graphID ) { } public synchronized void remove ( ID containerID ) { } public synchronized boolean contains ( ID graphID ) { } public synchronized ID [ ] getGraphs ( ID containerID ) { } public synchronized Object createMemento ( ) { } public synchronized void load ( Object memento ) { } } private final PublishedGraphTracker . Table table = new PublishedGraphTracker . Table ( ) ; private ISharedObjectConfig config ; private ISharedObjectContext context ; private final Object activationMutex = new Object ( ) ; private boolean activated ; public synchronized void add ( ID graphID ) throws ECFException { } public synchronized boolean isPublished ( ID graphID ) { } public synchronized void init ( ISharedObjectConfig initData ) throws SharedObjectInitException { } public void handleEvent ( Event event ) { if ( event instanceof ISharedObjectMessageEvent ) { ISharedObjectMessageEvent e = ( ( ISharedObjectMessageEvent ) ( event ) ) ; Object [ ] data = ( ( Object [ ] ) ( e . getData ( ) ) ) ; Integer type = ( ( Integer ) ( data [ 0 ] ) ) ; switch ( type . intValue ( ) ) { case PublishedGraphTracker . ADD : handleAdd ( e . getRemoteContainerID ( ) , ( ( ID ) ( data [ 1 ] ) ) ) ; break ; case PublishedGraphTracker . REMOVE : handleRemove ( e . getRemoteContainerID ( ) , ( ( ID ) ( data [ 1 ] ) ) ) ; break ; case PublishedGraphTracker . LEAVE : handleLeave ( e . getRemoteContainerID ( ) ) ; break ; } } else if ( event instanceof ISharedObjectContainerJoinedEvent ) { ISharedObjectContainerJoinedEvent e = ( ( ISharedObjectContainerJoinedEvent ) ( event ) ) ; if ( e . getJoinedContainerID ( ) . equals ( getContext ( ) . getLocalContainerID ( ) ) ) handleJoined ( ) ; else <START_BUG> if ( getContext ( ) . isGroupServer ( ) ) <END_BUG> handleJoined ( e . getJoinedContainerID ( ) ) ; } else if ( event instanceof ISharedObjectContainerDepartedEvent ) { ISharedObjectContainerDepartedEvent e = ( ( ISharedObjectContainerDepartedEvent ) ( event ) ) ; if ( ! ( e . getDepartedContainerID ( ) . equals ( getContext ( ) . getLocalContainerID ( ) ) ) ) handleLeave ( e . getDepartedContainerID ( ) ) ; } else if ( event instanceof ISharedObjectActivatedEvent ) { ISharedObjectActivatedEvent e = ( ( ISharedObjectActivatedEvent ) ( event ) ) ; if ( e . getActivatedID ( ) . equals ( config . getSharedObjectID ( ) ) ) handleActivated ( ) ; } else if ( event instanceof ISharedObjectDeactivatedEvent ) { ISharedObjectDeactivatedEvent e = ( ( ISharedObjectDeactivatedEvent ) ( event ) ) ; if ( e . getDeactivatedID ( ) . equals ( config . getSharedObjectID ( ) ) ) handleDeactivated ( ) ; else if ( table . contains ( e . getDeactivatedID ( ) ) ) handleRemoved ( e . getDeactivatedID ( ) ) ; } } private void handleAdd ( ID containerID , ID graphID ) { } private void handleRemove ( ID containerID , ID graphID ) { } private void handleLeave ( ID containerID ) { } private void handleJoined ( ) { } private void handleJoined ( ID containerID ) { } private void handleActivated ( ) { } private void handleDeactivated ( ) { } private void handleRemoved ( ID graphID ) { } public void handleEvents ( Event [ ] events ) { } public synchronized void dispose ( ID containerID ) { } public Object getAdapter ( Class adapter ) { } private ISharedObjectContext getContext ( ) { } }
public class DynamicCompositeType extends AbstractCompositeType { private static final Logger logger = LoggerFactory . getLogger ( DynamicCompositeType . class ) ; private final Map < Byte , AbstractType > aliases ; private static final Map < Map < Byte , AbstractType > , DynamicCompositeType > instances = new HashMap < Map < Byte , AbstractType > , DynamicCompositeType > ( ) ; public static synchronized DynamicCompositeType getInstance ( TypeParser parser ) throws ConfigurationException { } public static synchronized DynamicCompositeType getInstance ( Map < Byte , AbstractType > aliases ) { } private DynamicCompositeType ( Map < Byte , AbstractType > aliases ) { } private AbstractType getComparator ( ByteBuffer bb ) { } protected AbstractType getNextComparator ( int i , ByteBuffer bb ) { } protected AbstractType getNextComparator ( int i , ByteBuffer bb1 , ByteBuffer bb2 ) { } protected AbstractType getAndAppendNextComparator ( int i , ByteBuffer bb , StringBuilder sb ) { } protected ParsedComparator parseNextComparator ( int i , String part ) { } protected AbstractType validateNextComparator ( int i , ByteBuffer bb ) throws MarshalException { } private class DynamicParsedComparator implements ParsedComparator { final AbstractType type ; final boolean isAlias ; final String comparatorName ; final String remainingPart ; DynamicParsedComparator ( String part ) { } public AbstractType getAbstractType ( ) { } public String getRemainingPart ( ) { } public int getComparatorSerializedSize ( ) { } public void serializeComparator ( ByteBuffer bb ) { int header = 0 ; if ( isAlias ) <START_BUG> header = 32768 | ( ( byte ) ( comparatorName . charAt ( 0 ) ) ) ; <END_BUG> else header = comparatorName . length ( ) ; putShortLength ( bb , header ) ; if ( ! ( isAlias ) ) bb . put ( ByteBufferUtil . bytes ( comparatorName ) ) ; } } @ Override public String toString ( ) { } }
public class CollectionPlugin extends XWikiDefaultPlugin implements XWikiPluginInterface { protected CollectionActivityStream collectionActivityStream ; private EntityReferenceSerializer < String > defaultEntityReferenceSerializer ; private DocumentReferenceResolver < String > currentDocumentReferenceResolver ; private AttachmentReferenceResolver < String > currentAttachmentReferenceResolver ; public CollectionPlugin ( String name , String className , XWikiContext context ) { } public String getName ( ) { } public void init ( XWikiContext context ) { } public void virtualInit ( XWikiContext context ) { } private void addDebug ( String string ) { } public Api getPluginApi ( XWikiPluginInterface plugin , XWikiContext context ) { } public boolean exportToXAR ( String packageName , List selectList , boolean withVersions , XWikiContext context ) throws XWikiException , IOException { } public void exportWithLinks ( String documentName , String type , XWikiContext context ) throws Exception { } public void exportWithLinks ( String documentName , List < String > selectlist , String type , XWikiContext context ) throws Exception { } public void exportWithLinks ( String packageName , String documentName , List < String > selectlist , String type , XWikiContext context ) throws Exception { } public void exportWithLinks ( String packageName , String documentName , List < String > selectlist , boolean ignoreInitialPage , String type , XWikiContext context ) throws Exception { } public void exportWithLinks ( String packageName , XWikiDocument doc , List < String > selectlist , boolean ignoreInitialPage , String type , XWikiContext context ) throws Exception { } public void exportWithLinks ( String packageName , XWikiDocument doc , List < String > selectlist , boolean ignoreInitialPage , String type , String pdftemplatepage , XWikiContext context ) throws Exception { } public String getRenderedContentWithLinks ( String documentName , XWikiContext context ) throws Exception { } public String getRenderedContentWithLinks ( String documentName , List < String > selectlist , boolean ignoreInitialPage , XWikiContext context ) throws Exception { } public String getRenderedContentWithLinks ( XWikiDocument doc , List < String > selectlist , boolean ignoreInitialPage , XWikiContext context ) throws Exception { } public void getRenderedContentWithLinks ( XWikiDocument doc , XDOM xdom , List < String > selectlist , List < String > includedList , List < String > headerIds , XWikiContext context ) throws Exception { } protected void appendChild ( String mainDocName , String childDocumentName , XDOM xdom , List < String > selectlist , List < String > includedList , List < String > headerIds , XWikiContext context ) throws Exception { } protected List < String > updateXDOM ( XWikiDocument doc , XDOM xdom , List < String > selectlist , List < String > headerIds ) throws Exception { } public List < String > getLinks ( String documentName , String space , XWikiContext context ) throws Exception { } public List < String > getLinks ( XWikiDocument doc , XDOM xdom , String space ) throws Exception { } public List < ListItem > getLinksTreeList ( String documentName , XWikiContext context ) throws Exception { } public List < ListItem > getLinksTreeList ( String documentName , String space , XWikiContext context ) throws Exception { } public void getLinksTreeList ( String documentName , String space , List < ListItem > treeList , List < String > safeList , XWikiContext context ) throws Exception { } public List < String > getLinkedPages ( XWikiDocument document , XWikiContext context ) { } public String getCollectionsClassName ( XWikiContext context ) { } public boolean isCollection ( String docName , XWikiContext context ) { } public boolean isCollection ( XWikiDocument doc , XWikiContext context ) { } public boolean isCollection ( String docName , String className , XWikiContext context ) { } public boolean isCollection ( XWikiDocument doc , String className , XWikiContext context ) { } public List < String > getCollections ( String docName , XWikiContext context ) { } public List < String > getCollections ( String docName , ArrayList < String > pageList , XWikiContext context ) { } public Map < String , String > getCollectionsWithPath ( String docName , XWikiContext context ) { } public Map < String , String > getCollectionsWithPath ( String docName , String path , ArrayList < String > pageList , XWikiContext context ) { } public List < String > getCollections ( String docName , String className , XWikiContext context ) { } public List < String > getCollections ( String docName , String className , ArrayList < String > pageList , XWikiContext context ) { } public Map < String , String > getCollectionsWithPath ( String docName , String className , XWikiContext context ) { } public Map < String , String > getCollectionsWithPath ( String docName , String className , String path , ArrayList < String > pageList , XWikiContext context ) { } public List < String > getBreadcrumbFromParents ( String docName , ArrayList < String > pageList , XWikiContext context ) { try { XWikiDocument doc = context . getWiki ( ) . getDocument ( docName , context ) ; String page = doc . getParent ( ) ; <START_BUG> if ( ( ( ( ( page != null ) & ( ! ( page . equals ( "" ) ) ) ) && ( ! ( pageList . contains ( page ) ) ) ) && ( ! ( page . equals ( "XWiki.XWikiGuest" ) ) ) ) && ( ! ( page . equals ( "XWiki.XWikiUsers" ) ) ) ) { <END_BUG> pageList . add ( page ) ; return getBreadcrumbFromParents ( page , pageList , context ) ; } else { return pageList ; } } catch ( XWikiException e1 ) { return pageList ; } } public List < String > getBreadcrumb ( String docName , XWikiContext context ) { } }
private String getBranch ( EnvVars env ) { } public String getSubdir ( ) { } private FilePath workspace2Repo ( FilePath workspace ) { } @ Override @ SuppressWarnings ( "DLS_DEAD_LOCAL_STORE" ) public HgBrowser getBrowser ( ) { } public boolean isClean ( ) { } public boolean isForest ( ) { } private ArgumentListBuilder findHgExe ( AbstractBuild < ? , ? > build , TaskListener listener , boolean allowDebug ) throws IOException , InterruptedException { } ArgumentListBuilder findHgExe ( Node node , TaskListener listener , boolean allowDebug ) throws IOException , InterruptedException { } static ProcStarter launch ( Launcher launcher ) { } @ Override public SCMRevisionState calcRevisionsFromBuild ( AbstractBuild < ? , ? > build , Launcher launcher , TaskListener listener ) throws IOException , InterruptedException { } private static final String FILES_STYLE = "changeset<seq2seq4repair_space>=<seq2seq4repair_space>\'id:{node}\\nfiles:{files}\\n\'\n" + "file<seq2seq4repair_space>=<seq2seq4repair_space>'{file}:'" ; @ Override protected PollingResult compareRemoteRevisionWith ( AbstractProject < ? , ? > project , Launcher launcher , FilePath workspace , TaskListener listener , SCMRevisionState _baseline ) throws IOException , InterruptedException { } private void pull ( Launcher launcher , FilePath repository , TaskListener listener , PrintStream output , Node node , String branch ) throws IOException , InterruptedException { } static int joinWithPossibleTimeout ( ProcStarter proc , boolean useTimeout , final TaskListener listener ) throws IOException , InterruptedException { } private Change computeDegreeOfChanges ( Set < String > changedFileNames , PrintStream output ) { } private Set < String > dependentChanges ( Set < String > changedFileNames ) { } private static Pattern FILES_LINE = Pattern . compile ( "files:(.*)" ) ; private MercurialTagAction parseIncomingOutput ( ByteArrayOutputStream output , MercurialTagAction baseline , Set < String > result ) throws IOException { } public static MercurialInstallation findInstallation ( String name ) { } @ Override public boolean checkout ( AbstractBuild < ? , ? > build , Launcher launcher , FilePath workspace , final BuildListener listener , File changelogFile ) throws IOException , InterruptedException { } private boolean update ( AbstractBuild < ? , ? > build , Launcher launcher , FilePath repository , BuildListener listener , File changelogFile ) throws IOException , InterruptedException { } private boolean clone ( AbstractBuild < ? , ? > build , Launcher launcher , FilePath repository , BuildListener listener , File changelogFile ) throws IOException , InterruptedException { try { repository . deleteRecursive ( ) ; } catch ( IOException e ) { e . printStackTrace ( listener . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>clean<seq2seq4repair_space>the<seq2seq4repair_space>repository<seq2seq4repair_space>checkout" ) ) ; return false ; } EnvVars env = build . getEnvironment ( listener ) ; HgExe hg = new HgExe ( this , launcher , build . getBuiltOn ( ) , listener , env ) ; ArgumentListBuilder args = new ArgumentListBuilder ( ) ; MercurialSCM . PossiblyCachedRepo cachedSource = cachedSource ( build . getBuiltOn ( ) , launcher , listener , false ) ; if ( cachedSource != null ) { if ( cachedSource . isUseSharing ( ) ) { args . add ( "share" ) ; args . add ( "--noupdate" ) ; args . add ( cachedSource . getRepoLocation ( ) ) ; } else { args . add ( "clone" ) ; args . add ( "--rev" , getBranch ( env ) ) ; args . add ( "--noupdate" ) ; args . add ( cachedSource . getRepoLocation ( ) ) ; } } else { args . add ( ( forest ? "fclone" : "clone" ) ) ; args . add ( "--rev" , getBranch ( env ) ) ; args . add ( "--noupdate" ) ; args . add ( source ) ; } args . add ( repository . getRemote ( ) ) ; try { if ( ( hg . run ( args ) . join ( ) ) != 0 ) { listener . error ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>clone<seq2seq4repair_space>" + ( source ) ) ) ; return false ; } } catch ( IOException e ) { e . printStackTrace ( listener . error ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>clone<seq2seq4repair_space>" + ( source ) ) ) ) ; return false ; } <START_BUG> if ( ( cachedSource != null ) && ( cachedSource . isUseCaches ( ) ) ) { <END_BUG> FilePath hgrc = repository . child ( ".hg/hgrc" ) ; if ( hgrc . exists ( ) ) { String hgrcText = hgrc . readToString ( ) ; if ( ! ( hgrcText . contains ( cachedSource . getRepoLocation ( ) ) ) ) { listener . error ( ( ( ( ".hg/hgrc<seq2seq4repair_space>did<seq2seq4repair_space>not<seq2seq4repair_space>contain<seq2seq4repair_space>" + ( cachedSource . getRepoLocation ( ) ) ) + "<seq2seq4repair_space>as<seq2seq4repair_space>expected:\n" ) + hgrcText ) ) ; return false ; } hgrc . write ( hgrcText . replace ( cachedSource . getRepoLocation ( ) , source ) , null ) ; } hg . run ( "--config" , "extensions.relink=" , "relink" , cachedSource . getRepoLocation ( ) ) . pwd ( repository ) . join ( ) ; } ArgumentListBuilder upArgs = new ArgumentListBuilder ( ) ; upArgs . add ( ( forest ? "fupdate" : "update" ) ) ; upArgs . add ( "--rev" , getBranch ( env ) ) ; hg . run ( upArgs ) . pwd ( repository ) . join ( ) ; String tip = hg . tip ( repository ) ; if ( tip != null ) { build . addAction ( new MercurialTagAction ( tip ) ) ; } return createEmptyChangeLog ( changelogFile , listener , "changelog" ) ; } @ Override public void buildEnvVars ( AbstractBuild < ? , ? > build , Map < String , String > env ) { } @ Override public ChangeLogParser createChangeLogParser ( ) { } @ Override public MercurialSCM . DescriptorImpl getDescriptor ( ) { } public String getModules ( ) { } static boolean CACHE_LOCAL_REPOS = false ; @ CheckForNull private MercurialSCM . PossiblyCachedRepo cachedSource ( Node node , Launcher launcher , TaskListener listener , boolean fromPolling ) { } private static class PossiblyCachedRepo { private final String repoLocation ; private final boolean useCaches ;
public class RAttributeAttributeGroup extends org . tigris . scarab . om . BaseRAttributeAttributeGroup implements Persistent { <START_BUG> public void delete ( ScarabUser user ) throws Exception { <END_BUG> Criteria c = new Criteria ( ) . add ( GROUP_ID , getGroupId ( ) ) . add ( ATTRIBUTE_ID , getAttributeId ( ) ) ; RAttributeAttributeGroupPeer . doDelete ( c ) ; } }
public class IfStmt extends Stmt { private Expr condition ; private List < Stmt > body ; public IfStmt ( Expr cond , List < Stmt > b , int lineNum , int colNum ) { } public Expr getCond ( ) { } public List < Stmt > getBody ( ) { } public Type typecheck ( SymTab s ) { SymTab newScope = new SymTab ( s ) ; <START_BUG> if ( ( condition . typecheck ( newScope ) . getType ( ) ) != "bool" ) <END_BUG> throw new Error ( ( ( ( ( ( line ) + ":" ) + ( column ) ) + "<seq2seq4repair_space>error:<seq2seq4repair_space>" ) + "not<seq2seq4repair_space>boolean<seq2seq4repair_space>in<seq2seq4repair_space>if<seq2seq4repair_space>condition" ) ) ; if ( ( body . size ( ) ) == 0 ) return new Type ( "unit" ) ; for ( int a = 0 ; a < ( body . size ( ) ) ; a ++ ) { if ( a == ( ( body . size ( ) ) - 1 ) ) { Type t = body . get ( a ) . typecheck ( newScope ) ; if ( ( ( t . getType ( ) ) != "unit" ) && ( ( t . getType ( ) ) != "void" ) ) { throw new Error ( ( ( ( ( ( line ) + ":" ) + ( column ) ) + "<seq2seq4repair_space>error:<seq2seq4repair_space>" ) + "last<seq2seq4repair_space>stmt<seq2seq4repair_space>in<seq2seq4repair_space>if<seq2seq4repair_space>block<seq2seq4repair_space>does<seq2seq4repair_space>not<seq2seq4repair_space>typecheck" ) ) ; } else return new Type ( "unit" ) ; } else if ( ( body . get ( a ) . typecheck ( newScope ) . getType ( ) ) != "unit" ) throw new Error ( ( ( ( ( ( line ) + ":" ) + ( column ) ) + "<seq2seq4repair_space>error:<seq2seq4repair_space>" ) + "stmt<seq2seq4repair_space>should<seq2seq4repair_space>be<seq2seq4repair_space>unit<seq2seq4repair_space>type" ) ) ; } throw new Error ( ( ( ( ( ( line ) + ":" ) + ( column ) ) + "<seq2seq4repair_space>error:<seq2seq4repair_space>" ) + "shouldn't<seq2seq4repair_space>get<seq2seq4repair_space>here<seq2seq4repair_space>in<seq2seq4repair_space>ifblock<seq2seq4repair_space>typecheck" ) ) ; } public String toString ( ) { } @ Override public IRStmt buildIRStmt ( ) { } }
public class CIQIdentity { public CIQIdentity ( ) { } @ SuppressWarnings ( "serial" ) public static void main ( String [ ] args ) { try { XMLGregorianCalendar now = DatatypeFactory . newInstance ( ) . newXMLGregorianCalendar ( new GregorianCalendar ( TimeZone . getTimeZone ( "UTC" ) ) ) ; ContactNumbers contactNumbers = new ContactNumbers ( ) . withContactNumbers ( new ContactNumbers . ContactNumber ( ) . withContactNumberElements ( new ContactNumbers . ContactNumber . ContactNumberElement ( ) . withValue ( "555-555-5555" ) , new ContactNumbers . ContactNumber . ContactNumberElement ( ) . withValue ( "555-555-5556" ) ) ) ; ElectronicAddressIdentifiers electronicAddressIdentifiers = new ElectronicAddressIdentifiers ( ) . withElectronicAddressIdentifiers ( new ElectronicAddressIdentifiers . ElectronicAddressIdentifier ( ) . withValue ( "jsmith@example.com" ) ) ; FreeTextLines freeTextLines = new FreeTextLines ( ) . withFreeTextLines ( new FreeTextLines . FreeTextLine ( ) . withValue ( "Demonstrating<seq2seq4repair_space>Free<seq2seq4repair_space>Text!" ) ) ; PartyNameType partyName = new PartyNameType ( ) . withNameLines ( new NameLine ( ) . withValue ( "Foo" ) , new NameLine ( ) . withValue ( "Bar" ) ) . withPersonNames ( new PersonName ( ) . withNameElements ( new NameElement ( ) . withValue ( "John<seq2seq4repair_space>Smith" ) ) , new PersonName ( ) . withNameElements ( new NameElement ( ) . withValue ( "Jill<seq2seq4repair_space>Smith" ) ) ) . withOrganisationNames ( new OrganisationName ( ) . withNameElements ( new oasis . names . tc . ciq . xnl . _3 . OrganisationNameType . NameElement ( ) . withValue ( "Foo<seq2seq4repair_space>Inc." ) ) , new OrganisationName ( ) . withNameElements ( new oasis . names . tc . ciq . xnl . _3 . OrganisationNameType . NameElement ( ) . withValue ( "Bar<seq2seq4repair_space>Corp." ) ) ) ; STIXCIQIdentity30Type specification = new STIXCIQIdentity30Type ( ) . withContactNumbers ( contactNumbers ) . withElectronicAddressIdentifiers ( electronicAddressIdentifiers ) . withFreeTextLines ( freeTextLines ) . withPartyName ( partyName ) ; CIQIdentity30InstanceType identity = new CIQIdentity30InstanceType ( ) . withSpecification ( specification ) ; InformationSourceType producer = new InformationSourceType ( ) . withDescriptions ( new StructuredTextType ( ) . withValue ( "An<seq2seq4repair_space>indicator<seq2seq4repair_space>containing<seq2seq4repair_space>a<seq2seq4repair_space>File<seq2seq4repair_space>observable<seq2seq4repair_space>with<seq2seq4repair_space>an<seq2seq4repair_space>associated<seq2seq4repair_space>hash" ) ) . withTime ( new TimeType ( ) . withProducedTime ( new DateTimeWithPrecisionType ( now , null ) ) ) . withIdentity ( identity ) ; FileObjectType fileObject = new FileObjectType ( ) . withHashes ( new HashListType ( new ArrayList < HashType > ( ) { } ) ) ; ObjectType obj = new ObjectType ( ) . withProperties ( fileObject ) . withId ( new QName ( "http://example.com/" , ( "file-" + ( UUID . randomUUID ( ) . toString ( ) ) ) , "example" ) ) ; Observable observable = new Observable ( ) . withId ( new QName ( "http://example.com/" , ( "observable-" + ( UUID . randomUUID ( ) . toString ( ) ) ) , "example" ) ) ; observable . setObject ( obj ) ; final Indicator indicator = new Indicator ( ) . withId ( new QName ( "http://example.com/" , ( "indicator-" + ( UUID . randomUUID ( ) . toString ( ) ) ) , "example" ) ) . withTimestamp ( now ) . withTitle ( "File<seq2seq4repair_space>Hash<seq2seq4repair_space>Example" ) . withDescriptions ( new StructuredTextType ( ) . withValue ( "An<seq2seq4repair_space>indicator<seq2seq4repair_space>containing<seq2seq4repair_space>a<seq2seq4repair_space>File<seq2seq4repair_space>observable<seq2seq4repair_space>with<seq2seq4repair_space>an<seq2seq4repair_space>associated<seq2seq4repair_space>hash" ) ) . withProducer ( producer ) . withObservable ( observable ) ; IndicatorsType indicators = new IndicatorsType ( new ArrayList < IndicatorBaseType > ( ) { } ) ; STIXHeaderType header = new STIXHeaderType ( ) . withDescriptions ( new StructuredTextType ( ) . withValue ( "Example" ) ) ; <START_BUG> STIXPackage stixPackage = new STIXPackage ( ) . withSTIXHeader ( header ) . withIndicators ( indicators ) . withVersion ( "1.2.0" ) . withTimestamp ( now ) . withId ( new QName ( "http://example.com/" , ( "package-" + ( UUID . randomUUID ( ) . toString ( ) ) ) , "example" ) ) ; <END_BUG> System . out . println ( stixPackage . toXMLString ( true ) ) ; System . out . println ( StringUtils . repeat ( "-" , 120 ) ) ; System . out . println ( ( "Validates:<seq2seq4repair_space>" + ( stixPackage . validate ( ) ) ) ) ; System . out . println ( StringUtils . repeat ( "-" , 120 ) ) ; System . out . println ( STIXPackage . fromXMLString ( stixPackage . toXMLString ( ) ) . toXMLString ( true ) ) ; } catch ( DatatypeConfigurationException e ) { throw new RuntimeException ( e ) ; } } }
public class MainInteractorImpl implements MainInteractor { CancelableCallback < MovieListWrapper > callback ; @ Override public void fetchData ( final FinishListner listner ) { <START_BUG> ApiClient . getYifyApiClient ( ) . getMovieList ( new HashMap < String , String > ( ) , ( callback = new CancelableCallback ( new retrofit . Callback < MovieListWrapper > ( ) { <END_BUG> @ Override public void success ( MovieListWrapper movieListWrapper , Response response ) { listner . onSuccess ( movieListWrapper ) ; } @ Override public void failure ( RetrofitError error ) { listner . onFailure ( error ) ; } } ) ) ) ; } @ Override public void destroy ( ) { } }
public final class InfinispanSubsystemXMLReader_1_1 implements XMLElementReader < List < ModelNode > > { @ SuppressWarnings ( "deprecation" ) @ Override public void readElement ( XMLExtendedStreamReader reader , List < ModelNode > operations ) throws XMLStreamException { } private void parseContainer ( XMLExtendedStreamReader reader , ModelNode subsystemAddress , List < ModelNode > operations ) throws XMLStreamException { } private void parseTransport ( XMLExtendedStreamReader reader , ModelNode containerAddress , List < ModelNode > operations ) throws XMLStreamException { } private void parseCacheAttribute ( XMLExtendedStreamReader reader , int index , Attribute attribute , String value , ModelNode cache ) throws XMLStreamException { } private void parseClusteredCacheAttribute ( XMLExtendedStreamReader reader , int index , Attribute attribute , String value , ModelNode cache ) throws XMLStreamException { } private void parseLocalCache ( XMLExtendedStreamReader reader , ModelNode containerAddress , List < ModelNode > operations ) throws XMLStreamException { } private void parseDistributedCache ( XMLExtendedStreamReader reader , ModelNode containerAddress , List < ModelNode > operations ) throws XMLStreamException { ModelNode cache = Util . getEmptyOperation ( ADD , null ) ; List < ModelNode > additionalConfigurationOperations = new ArrayList < ModelNode > ( ) ; for ( int i = 0 ; i < ( reader . getAttributeCount ( ) ) ; i ++ ) { String value = reader . getAttributeValue ( i ) ; Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; switch ( attribute ) { case OWNERS : { OWNERS . parseAndSetParameter ( value , cache , reader ) ; break ; } case VIRTUAL_NODES : { <START_BUG> SEGMENTS . parseAndSetParameter ( InfinispanResourceAndOperationTransformer_1_3 . virtualNodesToSegments ( value ) , cache , reader ) ; <END_BUG> break ; } case L1_LIFESPAN : { L1_LIFESPAN . parseAndSetParameter ( value , cache , reader ) ; break ; } default : { this . parseClusteredCacheAttribute ( reader , i , attribute , value , cache ) ; } } } if ( ! ( cache . hasDefined ( NAME ) ) ) { throw ParseUtils . missingRequired ( reader , EnumSet . of ( Attribute . NAME ) ) ; } if ( ! ( cache . hasDefined ( MODE ) ) ) { throw ParseUtils . missingRequired ( reader , EnumSet . of ( Attribute . MODE ) ) ; } addCacheNameToAddress ( cache , containerAddress , DISTRIBUTED_CACHE ) ; while ( ( reader . hasNext ( ) ) && ( ( reader . nextTag ( ) ) != ( XMLStreamConstants . END_ELEMENT ) ) ) { Element element = Element . forName ( reader . getLocalName ( ) ) ; switch ( element ) { case STATE_TRANSFER : { this . parseStateTransfer ( reader , cache , additionalConfigurationOperations ) ; break ; } default : { this . parseCacheElement ( reader , element , cache , additionalConfigurationOperations ) ; } } } operations . add ( cache ) ; for ( ModelNode additionalOperation : additionalConfigurationOperations ) { operations . add ( additionalOperation ) ; } } private void parseReplicatedCache ( XMLExtendedStreamReader reader , ModelNode containerAddress , List < ModelNode > operations ) throws XMLStreamException { } private void parseInvalidationCache ( XMLExtendedStreamReader reader , ModelNode containerAddress , List < ModelNode > operations ) throws XMLStreamException { } private void addCacheNameToAddress ( ModelNode cache , ModelNode containerAddress , String cacheType ) { } @ SuppressWarnings ( "deprecation" ) private void parseCacheElement ( XMLExtendedStreamReader reader , Element element , ModelNode cache , List < ModelNode > operations ) throws XMLStreamException { } private void parseStateTransfer ( XMLExtendedStreamReader reader , ModelNode cache , List < ModelNode > operations ) throws XMLStreamException { } private void parseLocking ( XMLExtendedStreamReader reader , ModelNode cache , List < ModelNode > operations ) throws XMLStreamException { } private void parseTransaction ( XMLExtendedStreamReader reader , ModelNode cache , List < ModelNode > operations ) throws XMLStreamException { } private void parseEviction ( XMLExtendedStreamReader reader , ModelNode cache , List < ModelNode > operations ) throws XMLStreamException { } private void parseExpiration ( XMLExtendedStreamReader reader , ModelNode cache , List < ModelNode > operations ) throws XMLStreamException { } private void parseCustomStore ( XMLExtendedStreamReader reader , ModelNode cache , List < ModelNode > operations ) throws XMLStreamException { } private void parseFileStore ( XMLExtendedStreamReader reader , ModelNode cache , List < ModelNode > operations ) throws XMLStreamException { } private void parseRemoteStore ( XMLExtendedStreamReader reader , ModelNode cache , List < ModelNode > operations ) throws XMLStreamException { } private void parseRemoteServer ( XMLExtendedStreamReader reader , ModelNode server ) throws XMLStreamException { } @ SuppressWarnings ( "deprecation" ) private void parseJDBCStore ( XMLExtendedStreamReader reader , ModelNode cache , List < ModelNode > operations ) throws XMLStreamException { } private void parseJDBCStoreTable ( XMLExtendedStreamReader reader , ModelNode table ) throws XMLStreamException { } private void parseJDBCStoreColumn ( XMLExtendedStreamReader reader , ModelNode column ) throws XMLStreamException { } private void parseStoreAttribute ( XMLExtendedStreamReader reader , int index , Attribute attribute , String value , ModelNode store ) throws XMLStreamException { } private void parseStoreProperties ( XMLExtendedStreamReader reader , ModelNode node , List < ModelNode > operations ) throws XMLStreamException { } private void parseStoreProperty ( XMLExtendedStreamReader reader , ModelNode node , List < ModelNode > operations ) throws XMLStreamException { } }
public class MultiDocValues extends DocValues { private static MultiDocValues . DocValuesPuller DEFAULT_PULLER = new MultiDocValues . DocValuesPuller ( ) ; private static final MultiDocValues . DocValuesPuller NORMS_PULLER = new MultiDocValues . DocValuesPuller ( ) { public DocValues pull ( AtomicReader reader , String field ) throws IOException { } public boolean stopLoadingOnNull ( AtomicReader reader , String field ) { } } ; public static class DocValuesSlice { public static final MultiDocValues . DocValuesSlice [ ] EMPTY_ARRAY = new MultiDocValues . DocValuesSlice [ 0 ] ; final int start ; final int length ; DocValues docValues ; public DocValuesSlice ( DocValues docValues , int start , int length ) { } } private static class DocValuesPuller { public DocValuesPuller ( ) { } public DocValues pull ( AtomicReader reader , String field ) throws IOException { } public boolean stopLoadingOnNull ( AtomicReader reader , String field ) { } } private MultiDocValues . DocValuesSlice [ ] slices ; private int [ ] starts ; private Type type ; private int valueSize ; private MultiDocValues ( MultiDocValues . DocValuesSlice [ ] slices , int [ ] starts , TypePromoter promotedType ) { } public static DocValues getDocValues ( IndexReader r , final String field ) throws IOException { } public static DocValues getNormDocValues ( IndexReader r , final String field ) throws IOException { } private static DocValues getDocValues ( IndexReader reader , final String field , final MultiDocValues . DocValuesPuller puller ) throws IOException { if ( reader instanceof AtomicReader ) { return puller . pull ( ( ( AtomicReader ) ( reader ) ) , field ) ; } assert reader instanceof CompositeReader ; <START_BUG> final List < AtomicReaderContext > leaves = reader . getTopReaderContext ( ) . leaves ( ) ; <END_BUG> switch ( leaves . size ( ) ) { case 0 : return null ; case 1 : return MultiDocValues . getDocValues ( leaves . get ( 0 ) . reader ( ) , field , puller ) ; default : final List < MultiDocValues . DocValuesSlice > slices = new ArrayList < MultiDocValues . DocValuesSlice > ( ) ; TypePromoter promotedType = TypePromoter . getIdentityPromoter ( ) ; for ( final AtomicReaderContext ctx : leaves ) { final AtomicReader r = ctx . reader ( ) ; final DocValues d = puller . pull ( r , field ) ; if ( d != null ) { TypePromoter incoming = TypePromoter . create ( d . getType ( ) , d . getValueSize ( ) ) ; promotedType = promotedType . promote ( incoming ) ; } else if ( puller . stopLoadingOnNull ( r , field ) ) { return null ; } slices . add ( new MultiDocValues . DocValuesSlice ( d , ctx . docBase , r . maxDoc ( ) ) ) ; } if ( promotedType == ( TypePromoter . getIdentityPromoter ( ) ) ) { return null ; } int [ ] starts = new int [ slices . size ( ) ] ; for ( int i = 0 ; i < ( slices . size ( ) ) ; i ++ ) { MultiDocValues . DocValuesSlice slice = slices . get ( i ) ; starts [ i ] = slice . start ; if ( ( slice . docValues ) == null ) { Type promoted = promotedType . type ( ) ; switch ( promoted ) { case BYTES_FIXED_DEREF : case BYTES_FIXED_STRAIGHT : case BYTES_FIXED_SORTED : assert ( promotedType . getValueSize ( ) ) >= 0 ; slice . docValues = new MultiDocValues . EmptyFixedDocValues ( slice . length , promoted , promotedType . getValueSize ( ) ) ; break ; default : slice . docValues = new MultiDocValues . EmptyDocValues ( slice . length , promoted ) ; } } } return new MultiDocValues ( slices . toArray ( new MultiDocValues . DocValuesSlice [ slices . size ( ) ] ) , starts , promotedType ) ; } } @ Override public Source load ( ) throws IOException { } public static class EmptyDocValues extends DocValues { final int maxDoc ; final Source emptySource ; public EmptyDocValues ( int maxDoc , Type type ) { } @ Override public Source load ( ) throws IOException { } @ Override public Type getType ( ) { } @ Override public Source getDirectSource ( ) throws IOException { } } public static class EmptyFixedDocValues extends DocValues { final int maxDoc ; final Source emptyFixedSource ; final int valueSize ; public EmptyFixedDocValues ( int maxDoc , Type type , int valueSize ) { } @ Override public Source load ( ) throws IOException { } @ Override public Type getType ( ) { } @ Override public int getValueSize ( ) { } @ Override public Source getDirectSource ( ) throws IOException { } } private static class MultiSource extends Source { private int numDocs = 0 ; private int start = 0 ; private Source current ; private final int [ ] starts ; private final MultiDocValues . DocValuesSlice [ ] slices ; private boolean direct ; private Object cachedArray ; public MultiSource ( MultiDocValues . DocValuesSlice [ ] slices , int [ ] starts , boolean direct , Type type ) { } public long getInt ( int docID ) { } private final int ensureSource ( int docID ) { } public double getFloat ( int docID ) { } public BytesRef getBytes ( int docID , BytesRef bytesRef ) { } @ Override public SortedSource asSortedSource ( ) { } private int globalNumDocs ( ) { } private int [ ] docBases ( ) { } public boolean hasArray ( ) { } @ Override public Object getArray ( ) { } } private static final class RecordingBytesRefConsumer implements SortedBytesMergeUtils . BytesRefConsumer { private static final int PAGED_BYTES_BITS = 15 ; final PagedBytes pagedBytes = new PagedBytes ( MultiDocValues . RecordingBytesRefConsumer . PAGED_BYTES_BITS ) ; long [ ] ordToOffset ;
class AnnotationDrivenBeanDefinitionParser implements BeanDefinitionParser { private static final boolean javaxValidationPresent = ClassUtils . isPresent ( "javax.validation.Validator" , AnnotationDrivenBeanDefinitionParser . class . getClassLoader ( ) ) ; private static final boolean jaxb2Present = ClassUtils . isPresent ( "javax.xml.bind.Binder" , AnnotationDrivenBeanDefinitionParser . class . getClassLoader ( ) ) ; private static final boolean jackson2Present = ( ClassUtils . isPresent ( "com.fasterxml.jackson.databind.ObjectMapper" , AnnotationDrivenBeanDefinitionParser . class . getClassLoader ( ) ) ) && ( ClassUtils . isPresent ( "com.fasterxml.jackson.core.JsonGenerator" , AnnotationDrivenBeanDefinitionParser . class . getClassLoader ( ) ) ) ; private static final boolean jacksonPresent = ( ClassUtils . isPresent ( "org.codehaus.jackson.map.ObjectMapper" , AnnotationDrivenBeanDefinitionParser . class . getClassLoader ( ) ) ) && ( ClassUtils . isPresent ( "org.codehaus.jackson.JsonGenerator" , AnnotationDrivenBeanDefinitionParser . class . getClassLoader ( ) ) ) ; private static boolean romePresent = ClassUtils . isPresent ( "com.sun.syndication.feed.WireFeed" , AnnotationDrivenBeanDefinitionParser . class . getClassLoader ( ) ) ; @ Override public BeanDefinition parse ( Element element , ParserContext parserContext ) { } private RuntimeBeanReference getConversionService ( Element element , Object source , ParserContext parserContext ) { } private RuntimeBeanReference getValidator ( Element element , Object source , ParserContext parserContext ) { if ( element . hasAttribute ( "validator" ) ) { return new RuntimeBeanReference ( element . getAttribute ( "validator" ) ) ; } else if ( AnnotationDrivenBeanDefinitionParser . javaxValidationPresent ) { <START_BUG> RootBeanDefinition validatorDef = new RootBeanDefinition ( "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean" ) ; <END_BUG> validatorDef . setSource ( source ) ; validatorDef . setRole ( ROLE_INFRASTRUCTURE ) ; String validatorName = parserContext . getReaderContext ( ) . registerWithGeneratedName ( validatorDef ) ; parserContext . registerComponent ( new org . springframework . beans . factory . parsing . BeanComponentDefinition ( validatorDef , validatorName ) ) ; return new RuntimeBeanReference ( validatorName ) ; } else { return null ; } } private RuntimeBeanReference getContentNegotiationManager ( Element element , Object source , ParserContext parserContext ) { } private Properties getDefaultMediaTypes ( ) { } private RuntimeBeanReference getMessageCodesResolver ( Element element , Object source , ParserContext parserContext ) { } private String getAsyncTimeout ( Element element , Object source , ParserContext parserContext ) { } private RuntimeBeanReference getAsyncExecutor ( Element element , Object source , ParserContext parserContext ) { } private ManagedList < ? > getCallableInterceptors ( Element element , Object source , ParserContext parserContext ) { } private ManagedList < ? > getDeferredResultInterceptors ( Element element , Object source , ParserContext parserContext ) { } private ManagedList < ? > getArgumentResolvers ( Element element , ParserContext parserContext ) { } private ManagedList < ? > getReturnValueHandlers ( Element element , Object source , ParserContext parserContext ) { } @ SuppressWarnings ( "deprecation" ) private ManagedList < ? > getMessageConverters ( Element element , Object source , ParserContext parserContext ) { } @ SuppressWarnings ( "rawtypes" ) private RootBeanDefinition createConverterDefinition ( Class < ? extends HttpMessageConverter > converterClass , Object source ) { } private ManagedList < BeanDefinitionHolder > extractBeanSubElements ( Element parentElement , ParserContext parserContext ) { } private ManagedList < BeanDefinitionHolder > wrapWebArgumentResolverBeanDefs ( List < BeanDefinitionHolder > beanDefs , ParserContext parserContext ) { } static class CompositeUriComponentsContributorFactoryBean implements FactoryBean < CompositeUriComponentsContributor > , InitializingBean { private RequestMappingHandlerAdapter handlerAdapter ; private ConversionService conversionService ; private CompositeUriComponentsContributor uriComponentsContributor ; public void setHandlerAdapter ( RequestMappingHandlerAdapter handlerAdapter ) { } public void setConversionService ( ConversionService conversionService ) { } @ Override public void afterPropertiesSet ( ) { } @ Override public CompositeUriComponentsContributor getObject ( ) throws Exception { } @ Override public Class < ? > getObjectType ( ) { } @ Override public boolean isSingleton ( ) { } } }
public static final int DisableUnnecessaryCastCheck = ASTNode . Bit6 ; public static final int GenerateCheckcast = ASTNode . Bit7 ; public static final int UnsafeCast = ASTNode . Bit8 ; public static final int RestrictiveFlagMASK = ( ( ASTNode . Bit1 ) | ( ASTNode . Bit2 ) ) | ( ASTNode . Bit3 ) ; public static final int FirstAssignmentToLocal = ASTNode . Bit4 ; public static final int IsImplicitThis = ASTNode . Bit3 ; public static final int DepthSHIFT = 5 ; public static final int DepthMASK = ( ( ( ( ( ( ( ASTNode . Bit6 ) | ( ASTNode . Bit7 ) ) | ( ASTNode . Bit8 ) ) | ( ASTNode . Bit9 ) ) | ( ASTNode . Bit10 ) ) | ( ASTNode . Bit11 ) ) | ( ASTNode . Bit12 ) ) | ( ASTNode . Bit13 ) ; public static final int IsReachable = ASTNode . Bit32 ; public static final int LabelUsed = ASTNode . Bit7 ; public static final int DocumentedFallthrough = ASTNode . Bit30 ; public static final int IsLocalDeclarationReachable = ASTNode . Bit31 ; public static final int IsSubRoutineEscaping = ASTNode . Bit15 ; public static final int IsTryBlockExiting = ASTNode . Bit30 ; public static final int ContainsAssertion = ASTNode . Bit1 ; public static final int IsLocalType = ASTNode . Bit9 ; public static final int IsAnonymousType = ASTNode . Bit10 ; public static final int IsMemberType = ASTNode . Bit11 ; public static final int HasAbstractMethods = ASTNode . Bit12 ; public static final int IsSecondaryType = ASTNode . Bit13 ; public static final int HasLocalType = ASTNode . Bit2 ; public static final int ParenthesizedSHIFT = 21 ; public static final int ParenthesizedMASK = ( ( ( ( ( ( ( ASTNode . Bit22 ) | ( ASTNode . Bit23 ) ) | ( ASTNode . Bit24 ) ) | ( ASTNode . Bit25 ) ) | ( ASTNode . Bit26 ) ) | ( ASTNode . Bit27 ) ) | ( ASTNode . Bit28 ) ) | ( ASTNode . Bit29 ) ; public static final int IgnoreNoEffectAssignCheck = ASTNode . Bit30 ; public static final int IsStrictlyAssigned = ASTNode . Bit14 ; public static final int IsCompoundAssigned = ASTNode . Bit17 ; public static final int IsUsefulEmptyStatement = ASTNode . Bit1 ; public static final int UndocumentedEmptyBlock = ASTNode . Bit4 ; public static final int OverridingMethodWithSupercall = ASTNode . Bit5 ; public static final int HasAllMethodBodies = ASTNode . Bit5 ; public static final int IsImplicitUnit = ASTNode . Bit1 ; public static final int InsideJavadoc = ASTNode . Bit16 ; public static final int IsElseIfStatement = ASTNode . Bit30 ; public static final int IsSuperType = ASTNode . Bit5 ; public static final int IsVarArgs = ASTNode . Bit15 ; public static final int IgnoreRawTypeCheck = ASTNode . Bit31 ; public static final int IsAnnotationDefaultValue = ASTNode . Bit1 ; public static final int IsNonNull = ASTNode . Bit18 ; public static final int INVOCATION_ARGUMENT_OK = 0 ; public static final int INVOCATION_ARGUMENT_UNCHECKED = 1 ; public static final int INVOCATION_ARGUMENT_WILDCARD = 2 ; public ASTNode ( ) { } private static int checkInvocationArgument ( BlockScope scope , Expression argument , TypeBinding parameterType , TypeBinding argumentType , TypeBinding originalParameterType ) { } public static void checkInvocationArguments ( BlockScope scope , Expression receiver , TypeBinding receiverType , MethodBinding method , Expression [ ] arguments , TypeBinding [ ] argumentTypes , boolean argsContainCast , InvocationSite invocationSite ) { } public ASTNode concreteStatement ( ) { } public final boolean isFieldUseDeprecated ( FieldBinding field , Scope scope , boolean isStrictlyAssigned ) { } public boolean isImplicitThis ( ) { } public final boolean isMethodUseDeprecated ( MethodBinding method , Scope scope , boolean isExplicitUse ) { } public boolean isSuper ( ) { } public boolean isThis ( ) { } public final boolean isTypeUseDeprecated ( TypeBinding type , Scope scope ) { if ( type . isArrayType ( ) ) type = ( ( ArrayBinding ) ( type ) ) . leafComponentType ; if ( type . isBaseType ( ) ) return false ; ReferenceBinding refType = ( ( ReferenceBinding ) ( type ) ) ; <START_BUG> if ( ( refType . isPrivate ( ) ) && ( ! ( scope . isDefinedInType ( refType ) ) ) ) { <END_BUG> ( ( ReferenceBinding ) ( refType . erasure ( ) ) ) . modifiers |= ExtraCompilerModifiers . AccLocallyUsed ; } if ( refType . hasRestrictedAccess ( ) ) { AccessRestriction restriction = scope . environment ( ) . getAccessRestriction ( type . erasure ( ) ) ; if ( restriction != null ) { scope . problemReporter ( ) . forbiddenReference ( type , this , restriction . getMessageTemplate ( ) , restriction . getProblemId ( ) ) ; } } refType . initializeDeprecatedAnnotationTagBits ( ) ; if ( ! ( refType . isViewedAsDeprecated ( ) ) ) return false ; if ( scope . isDefinedInSameUnit ( refType ) ) return false ; if ( ( ! ( scope . compilerOptions ( ) . reportDeprecationInsideDeprecatedCode ) ) && ( scope . isInsideDeprecatedCode ( ) ) ) return false ; return true ; } public abstract StringBuffer print ( int indent , StringBuffer output ) { } public static StringBuffer printAnnotations ( Annotation [ ] annotations , StringBuffer output ) { } public static StringBuffer printIndent ( int indent , StringBuffer output ) { } public static StringBuffer printModifiers ( int modifiers , StringBuffer output ) { } public static void resolveAnnotations ( BlockScope scope , Annotation [ ] annotations , Binding recipient ) { } public static void resolveDeprecatedAnnotations ( BlockScope scope , Annotation [ ] annotations , Binding recipient ) { } public int sourceStart ( ) { } public int sourceEnd ( ) { } public String toString ( ) { } public void traverse ( ASTVisitor visitor , BlockScope scope ) { } }
public class DfsProver extends Prover { private static final Logger log = Logger . getLogger ( DfsProver . class ) ; private Backtrace < State > backtrace = new Backtrace < State > ( DfsProver . log ) ; protected boolean trueLoop ; protected boolean restart ; public DfsProver ( ) { } public DfsProver ( APROptions apr ) { } public DfsProver ( FeatureDictWeighter w , APROptions apr ) { } public DfsProver ( FeatureDictWeighter w , APROptions apr , boolean trueLoop , boolean restart ) { } private void init ( ) { } private void init ( boolean trueLoop , boolean restart ) { } public Prover copy ( ) { } protected class Entry { public State state ; public double w ; public Entry ( State s , Double d ) { } } protected List < DfsProver . Entry > dfs ( ProofGraph pg , State s , int depth ) throws LogicProgramException { } protected void dfs ( ProofGraph pg , State s , int depth , double incomingEdgeWeight , List < DfsProver . Entry > tail ) throws LogicProgramException { beforeDfs ( s , pg , depth ) ; tail . add ( new DfsProver . Entry ( s , incomingEdgeWeight ) ) ; if ( ( ! ( s . isCompleted ( ) ) ) && ( depth < ( this . apr . maxDepth ) ) ) { backtrace . push ( s ) ; List < Outlink > outlinks = pg . pgOutlinks ( s , trueLoop , restart ) ; if ( ( outlinks . size ( ) ) == 0 ) if ( DfsProver . log . isDebugEnabled ( ) ) DfsProver . log . debug ( ( "exit<seq2seq4repair_space>dfs:<seq2seq4repair_space>no<seq2seq4repair_space>outlinks<seq2seq4repair_space>for<seq2seq4repair_space>" + s ) ) ; double z = 0 ; Outlink reset = null ; for ( Outlink o : outlinks ) { o . wt = this . weighter . w ( o . fd ) ; z += o . wt ; if ( o . child . equals ( pg . getStartState ( ) ) ) reset = o ; } <START_BUG> if ( reset . fd . containsKey ( ALPHABOOSTER ) ) { <END_BUG> rescaleResetLink ( reset , z ) ; } for ( Outlink o : outlinks ) { dfs ( pg , o . child , ( depth + 1 ) , o . wt , tail ) ; } backtrace . pop ( s ) ; } else if ( DfsProver . log . isDebugEnabled ( ) ) DfsProver . log . debug ( ( "exit<seq2seq4repair_space>dfs:<seq2seq4repair_space>" + ( s . isCompleted ( ) ? "state<seq2seq4repair_space>completed" : ( ( "depth<seq2seq4repair_space>" + depth ) + ">" ) + ( this . apr . maxDepth ) ) ) ) ; } protected void beforeDfs ( State s , ProofGraph pg , int depth ) throws LogicProgramException { } @ Override public Map < State , Double > prove ( ProofGraph pg ) { } }
public class AssertStatement extends Statement { public Expression assertExpression ; public Expression exceptionArgument ; int preAssertInitStateIndex = - 1 ; private FieldBinding assertionSyntheticFieldBinding ; public AssertStatement ( Expression exceptionArgument , Expression assertExpression , int startPosition ) { } public AssertStatement ( Expression assertExpression , int startPosition ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { preAssertInitStateIndex = currentScope . methodScope ( ) . recordInitializationStates ( flowInfo ) ; Constant cst = this . assertExpression . optimizedBooleanConstant ( ) ; boolean isOptimizedTrueAssertion = ( cst != ( Constant . NotAConstant ) ) && ( ( cst . booleanValue ( ) ) == true ) ; boolean isOptimizedFalseAssertion = ( cst != ( Constant . NotAConstant ) ) && ( ( cst . booleanValue ( ) ) == false ) ; FlowInfo assertRawInfo = assertExpression . analyseCode ( currentScope , flowContext , flowInfo . copy ( ) ) ; UnconditionalFlowInfo assertWhenTrueInfo = assertRawInfo . initsWhenTrue ( ) . unconditionalInits ( ) ; UnconditionalFlowInfo assertInfo = assertRawInfo . unconditionalCopy ( ) ; if ( isOptimizedTrueAssertion ) { assertInfo . setReachMode ( FlowInfo . UNREACHABLE ) ; } if ( ( exceptionArgument ) != null ) { FlowInfo exceptionInfo = exceptionArgument . analyseCode ( currentScope , flowContext , assertInfo . copy ( ) ) ; if ( ! isOptimizedTrueAssertion ) { flowContext . checkExceptionHandlers ( currentScope . getJavaLangAssertionError ( ) , this , exceptionInfo , currentScope ) ; } } if ( ! isOptimizedTrueAssertion ) { manageSyntheticAccessIfNecessary ( currentScope , flowInfo ) ; } if ( isOptimizedFalseAssertion ) { return flowInfo ; } else { <START_BUG> return flowInfo . mergedWith ( assertInfo . nullInfoLessUnconditionalCopy ( ) ) . addInitializationsFrom ( assertWhenTrueInfo . nullInfo ( ) ) ; <END_BUG> } } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { } public void resolve ( BlockScope scope ) { } public void traverse ( ASTVisitor visitor , BlockScope scope ) { } public void manageSyntheticAccessIfNecessary ( BlockScope currentScope , FlowInfo flowInfo ) { } public StringBuffer printStatement ( int tab , StringBuffer output ) { } }
protected abstract boolean isMoveable ( IPresentablePart part ) { } protected abstract void addSystemActions ( IMenuManager menuManager ) { } protected abstract boolean supportsState ( int newState ) { } protected abstract boolean canMoveFolder ( ) { } protected abstract void derefPart ( LayoutPart toDeref ) { } protected abstract boolean allowsDrop ( PartPane part ) { } protected static void appendToGroupIfPossible ( IMenuManager m , String groupId , ContributionItem item ) { } public PartStack ( int appearance ) { } public PartStack ( int appearance , AbstractPresentationFactory factory ) { } public void addListener ( IPropertyListener listener ) { } public void removeListener ( IPropertyListener listener ) { } protected final boolean isStandalone ( ) { } protected IPresentablePart getSelectedPart ( ) { } protected IStackPresentationSite getPresentationSite ( ) { } public void testInvariants ( ) { } public void describeLayout ( StringBuffer buf ) { } public void add ( LayoutPart child ) { } protected void add ( LayoutPart newChild , Object cookie ) { } public boolean allowsAdd ( LayoutPart toAdd ) { } public boolean allowsAutoFocus ( ) { } protected void close ( IPresentablePart [ ] parts ) { } protected void close ( IPresentablePart part ) { } public boolean isDisposed ( ) { } protected AbstractPresentationFactory getFactory ( ) { } public void createControl ( Composite parent ) { } public IDropTarget getDropTarget ( Object draggedObject , Point position ) { } public void setActive ( boolean isActive ) { } public void createControl ( Composite parent , StackPresentation presentation ) { } public IDropTarget createDropTarget ( PartPane pane , StackDropResult result ) { } protected void savePresentationState ( ) { } public void dispose ( ) { } public void findSashes ( LayoutPart part , PartPane . Sashes sashes ) { } public Rectangle getBounds ( ) { } public LayoutPart [ ] getChildren ( ) { } public Control getControl ( ) { } public int getItemCount ( ) { } protected LayoutPart getPaneFor ( IPresentablePart part ) { } public Composite getParent ( ) { } public List getPresentableParts ( ) { } private PresentablePart getPresentablePart ( LayoutPart pane ) { } protected StackPresentation getPresentation ( ) { } public PartPane getSelection ( ) { } private void presentationSelectionChanged ( IPresentablePart newSelection ) { } public void remove ( LayoutPart child ) { } public void reparent ( Composite newParent ) { } public void replace ( LayoutPart oldChild , LayoutPart newChild ) { } public int computePreferredSize ( boolean width , int availableParallel , int availablePerpendicular , int preferredParallel ) { } public int getSizeFlags ( boolean horizontal ) { } public IStatus restoreState ( IMemento memento ) { } public void setVisible ( boolean makeVisible ) { } public IStatus saveState ( IMemento memento ) { } protected WorkbenchPage getPage ( ) { } public void setActive ( int activeState ) { } public int getActive ( ) { } public void setBounds ( Rectangle r ) { } public void setSelection ( LayoutPart part ) { } protected abstract void updateActions ( PresentablePart current ) { } protected void handleDeferredEvents ( ) { } private void refreshPresentationSelection ( ) { } public int getState ( ) { } public void setMinimized ( boolean minimized ) { } public boolean childObscuredByZoom ( LayoutPart toTest ) { } public void childRequestZoomIn ( LayoutPart toZoom ) { } public void childRequestZoomOut ( ) { } public boolean childIsZoomed ( LayoutPart toTest ) { } private boolean isIntroInStack ( ) { } private void smartZoom ( ) { } protected void smartUnzoom ( ) { } protected void setState ( final int newState ) { final int oldState = presentationSite . getState ( ) ; if ( ( ! ( supportsState ( newState ) ) ) || ( newState == oldState ) ) { return ; } final WorkbenchWindow wbw = ( ( WorkbenchWindow ) ( getPage ( ) . getWorkbenchWindow ( ) ) ) ; <START_BUG> if ( ( wbw == null ) || ( ( wbw . getShell ( ) ) == null ) ) <END_BUG> return ; boolean useNewMinMax = Perspective . useNewMinMax ( wbw . getActiveWorkbenchPage ( ) . getActivePerspective ( ) ) ; if ( newState == ( IStackPresentationSite . STATE_MAXIMIZED ) ) useNewMinMax = useNewMinMax && ( ! ( isIntroInStack ( ) ) ) ; else if ( newState == ( IStackPresentationSite . STATE_RESTORED ) ) useNewMinMax = useNewMinMax && ( smartZoomed ) ; if ( useNewMinMax ) { StartupThreading . runWithoutExceptions ( new StartupRunnable ( ) { public void runWithException ( ) throws Throwable { wbw . getPageComposite ( ) . setRedraw ( false ) ; try { if ( newState == ( IStackPresentationSite . STATE_MAXIMIZED ) ) { smartZoom ( ) ; } else if ( oldState == ( IStackPresentationSite . STATE_MAXIMIZED ) ) { smartUnzoom ( ) ; } if ( newState == ( IStackPresentationSite . STATE_MINIMIZED ) ) { setMinimized ( true ) ; } } finally { wbw . getPageComposite ( ) . setRedraw ( true ) ; wbw . getShell ( ) . redraw ( ) ; } setPresentationState ( newState ) ; } } ) ; } else { boolean minimized = newState == ( IStackPresentationSite . STATE_MINIMIZED ) ; setMinimized ( minimized ) ; if ( newState == ( IStackPresentationSite . STATE_MAXIMIZED ) ) { requestZoomIn ( ) ; } else if ( oldState == ( IStackPresentationSite . STATE_MAXIMIZED ) ) { requestZoomOut ( ) ; if ( newState == ( IStackPresentationSite . STATE_MINIMIZED ) ) setMinimized ( true ) ; } } } public void setZoomed ( boolean isZoomed ) { } public boolean isZoomed ( ) { } protected void refreshPresentationState ( ) { } private void showPart ( LayoutPart part , Object cookie ) { } private void updateContainerVisibleTab ( ) { } public void showSystemMenu ( ) { } public void showPaneMenu ( ) { }
public class PolymorphicResolverTest { @ Test public void testWithoutGuards ( ) { } private Collection < Function > getCandidates ( Object ... params ) { final FunctionDefContextImpl fdc = ( ( FunctionDefContextImpl ) ( createEmptyFdc ( new CompositeTypesystem ( ) ) ) ) ; <START_BUG> return new PolymorphicResolver ( "operatorPlus" ) . getBestFitCandidates ( fdc . findFunctionCandidates ( createEmptyExecutionContext ( ) , "operatorPlus" , Arrays . asList ( params ) ) ) ; <END_BUG> } }
public class BindAndValidateLifecycleTests { private BindAndValidateLifecycle lifecycle ; private BindAndValidateLifecycleTests . TestBean model ; private DefaultAlertContext alertContext ; @ Before public void setUp ( ) { model = new BindAndValidateLifecycleTests . TestBean ( ) ; alertContext = new DefaultAlertContext ( ) ; Binder binder = new WebBinderFactory ( ) . getBinder ( model ) ; <START_BUG> lifecycle = new BindAndValidateLifecycle ( binder , alertContext ) ; <END_BUG> } @ Test public void testExecuteLifecycleNoErrors ( ) { } @ Test public void testExecuteLifecycleBindingErrors ( ) { } public static enum FooEnum { BAR , BAZ , BOOP ; } public static class TestBean { private String string ; private int integer ; private Date date ; private BindAndValidateLifecycleTests . FooEnum foo ; private BigDecimal currency ; private List < BindAndValidateLifecycleTests . FooEnum > foos ; private List < BindAndValidateLifecycleTests . Address > addresses ; public String getString ( ) { } public void setString ( String string ) { } public int getInteger ( ) { } public void setInteger ( int integer ) { } public Date getDate ( ) { } public void setDate ( Date date ) { } public BindAndValidateLifecycleTests . FooEnum getFoo ( ) { } public void setFoo ( BindAndValidateLifecycleTests . FooEnum foo ) { } @ CurrencyFormat public BigDecimal getCurrency ( ) { } public void setCurrency ( BigDecimal currency ) { } public List < BindAndValidateLifecycleTests . FooEnum > getFoos ( ) { } public void setFoos ( List < BindAndValidateLifecycleTests . FooEnum > foos ) { } public List < BindAndValidateLifecycleTests . Address > getAddresses ( ) { } public void setAddresses ( List < BindAndValidateLifecycleTests . Address > addresses ) { } } public static class Address { private String street ; private String city ; private String state ; private String zip ; private String country ; public String getStreet ( ) { } public void setStreet ( String street ) { } public String getCity ( ) { } public void setCity ( String city ) { } public String getState ( ) { } public void setState ( String state ) { } public String getZip ( ) { } public void setZip ( String zip ) { } public String getCountry ( ) { } public void setCountry ( String country ) { } } @ Model ( value = "testBean" , strictBinding = true ) public class TestAnnotatedBean { private String editable ; private String notEditable ; @ Bound public String getEditable ( ) { } public void setEditable ( String editable ) { } public String getNotEditable ( ) { } public void setNotEditable ( String notEditable ) { } } }
public void setComparatorsByPosition ( List < String > comparatorsByPosition ) { } public void setComparatorsByPosition ( String ... comparators ) { } public void setComparatorByPosition ( int index , String c ) { } @ Override public int compareTo ( AbstractComposite o ) { } private String comparatorForSerializer ( Serializer < ? > s ) { } private Serializer < ? > serializerForComparator ( String c ) { } private Serializer < ? > serializerForPosition ( int i ) { } private Serializer < ? > getSerializer ( int i , String c ) { } private String comparatorForPosition ( int i ) { } private String getComparator ( int i , ByteBuffer bb ) { } @ Override public void clear ( ) { } @ Override public int size ( ) { } public < T > AbstractComposite addComponent ( T value , Serializer < T > s ) { } public < T > AbstractComposite addComponent ( T value , Serializer < T > s , String comparator ) { } public < T > AbstractComposite addComponent ( T value , Serializer < T > s , String comparator , AbstractComposite . ComponentEquality equality ) { } @ SuppressWarnings ( "unchecked" ) public < T > AbstractComposite addComponent ( int index , T value , Serializer < T > s , String comparator , AbstractComposite . ComponentEquality equality ) { } private static Object mapIfNumber ( Object o ) { } @ SuppressWarnings ( { "unchecked" } ) private static Collection < ? > flatten ( Collection < ? > c ) { } @ Override public boolean addAll ( Collection < ? extends Object > c ) { } @ Override public boolean containsAll ( Collection < ? > c ) { } @ Override public boolean removeAll ( Collection < ? > c ) { } @ Override public boolean retainAll ( Collection < ? > c ) { } @ Override public boolean addAll ( int i , Collection < ? extends Object > c ) { } @ SuppressWarnings ( "unchecked" ) @ Override public void add ( int index , Object element ) { } @ Override public Object remove ( int index ) { } public < T > AbstractComposite setComponent ( int index , T value , Serializer < T > s ) { } public < T > AbstractComposite setComponent ( int index , T value , Serializer < T > s , String comparator ) { } @ SuppressWarnings ( "unchecked" ) public < T > AbstractComposite setComponent ( int index , T value , Serializer < T > s , String comparator , AbstractComposite . ComponentEquality equality ) { } @ SuppressWarnings ( "unchecked" ) @ Override public Object set ( int index , Object element ) { } @ Override public Object get ( int i ) { } public < T > T get ( int i , Serializer < T > s ) throws ClassCastException { } public AbstractComposite . Component getComponent ( int i ) { } public Iterator < AbstractComposite . Component < ? > > componentsIterator ( ) { } @ SuppressWarnings ( "unchecked" ) public ByteBuffer serialize ( ) { if ( ( serialized ) != null ) { return serialized . duplicate ( ) ; } ByteBufferOutputStream out = new ByteBufferOutputStream ( ) ; int i = 0 ; for ( AbstractComposite . Component c : components ) { Serializer < ? > s = serializerForPosition ( i ) ; ByteBuffer cb = c . getBytes ( s ) ; if ( cb == null ) { cb = ByteBuffer . allocate ( 0 ) ; } if ( dynamic ) { String comparator = comparatorForPosition ( i ) ; if ( comparator == null ) { comparator = c . getComparator ( ) ; } if ( comparator == null ) { comparator = BYTESTYPE . getTypeName ( ) ; } int p = comparator . indexOf ( "(reversed=true)" ) ; boolean desc = false ; if ( p >= 0 ) { comparator = comparator . substring ( 0 , p ) ; desc = true ; } if ( aliasToComparatorMapping . inverse ( ) . containsKey ( comparator ) ) { byte a = aliasToComparatorMapping . inverse ( ) . get ( comparator ) ; if ( desc ) { a = ( ( byte ) ( Character . toUpperCase ( ( ( char ) ( a ) ) ) ) ) ; } out . writeShort ( ( ( short ) ( 32768 | a ) ) ) ; } else { out . writeShort ( ( ( short ) ( comparator . length ( ) ) ) ) ; <START_BUG> out . write ( ByteBuffer . wrap ( comparator . getBytes ( Charsets . UTF_8 ) ) ) ; <END_BUG> } } out . writeShort ( ( ( short ) ( cb . remaining ( ) ) ) ) ; out . write ( cb . slice ( ) ) ; if ( ( i == ( ( components . size ( ) ) - 1 ) ) && ( ( equality ) != ( AbstractComposite . ComponentEquality . EQUAL ) ) ) { out . write ( equality . toByte ( ) ) ; } else { out . write ( c . getEquality ( ) . toByte ( ) ) ; } i ++ ; } serialized = out . getByteBuffer ( ) ; return serialized . duplicate ( ) ; } @ SuppressWarnings ( "unchecked" ) public void deserialize ( ByteBuffer b ) { } protected static int getShortLength ( ByteBuffer bb ) { } protected static ByteBuffer getBytes ( ByteBuffer bb , int length ) { } protected static ByteBuffer getWithShortLength ( ByteBuffer bb ) { } public AbstractComposite . ComponentEquality getEquality ( ) { } public void setEquality ( AbstractComposite . ComponentEquality equality ) { } }
public class IncrementalImageBuilder extends AbstractImageBuilder { protected IProject fNewProject ; protected IImageContext fImageContext ; protected Hashtable fSourceDeltas ; protected IDelta fImageDelta = null ; protected IImageContext fContextOfLastDelta = null ; protected Vector fAddedPkgOrZips ; protected Vector fRemovedPkgOrZips ; protected Vector fChangedPkgOrZips ; protected Vector fAddedPackageHandles ; protected Vector fRemovedPackageHandles ; protected Vector fChangedPackageHandles ; protected Hashtable fAffectedPackages ; protected Vector fAddedClasses ; protected Vector fRemovedClasses ; protected Vector fChangedClasses ; protected Vector fChangedZips ; protected Hashtable fBuilderTypeTable ; protected IncrementalImageBuilder ( StateImpl oldState , IProject newProject , IImageContext context ) { } protected void addChangedFileNamesFromChangedPackage ( IResourceDelta pkgDelta , Hashtable table ) { } protected void addNewClasses ( ) { } protected void addSourceElement ( SourceEntry newEntry ) { } public void applySourceDelta ( Hashtable deltas ) { fNotifier = new BuildNotifier ( fDC , false ) ; fNotifier . begin ( ) ; fNotifier . subTask ( org . eclipse . jdt . internal . compiler . util . Util . bind ( "build.preparingBuild" ) ) ; fSourceDeltas = deltas ; fNewState = fOldState . copy ( fNewProject , fImageContext ) ; <START_BUG> fCompilerOptions = JavaModelManager . getOptions ( ) ; <END_BUG> try { fNotifier . subTask ( org . eclipse . jdt . internal . compiler . util . Util . bind ( "build.analyzingPackages" ) ) ; computeAllPackages ( ) ; checkCancel ( ) ; updatePackageMap ( ) ; fNewState . canonicalizeBuildContext ( ) ; fNotifier . updateProgressDelta ( 0.05F ) ; checkCancel ( ) ; for ( Enumeration e = fRemovedPackageHandles . elements ( ) ; e . hasMoreElements ( ) ; ) { IPackage pkgHandle = ( ( IPackage ) ( e . nextElement ( ) ) ) ; fNewState . getSourceElementTable ( ) . removePackage ( pkgHandle ) ; } recomputeSourceEntriesForChangedPackages ( ) ; checkCancel ( ) ; fWorkQueue = new WorkQueue ( ) ; computeNamespaceChanges ( ) ; for ( Enumeration e = fWorkQueue . getElementsToCompile ( ) . elements ( ) ; e . hasMoreElements ( ) ; ) { markDependentsAsNeedingCompile ( e . nextElement ( ) ) ; } fNotifier . subTask ( org . eclipse . jdt . internal . compiler . util . Util . bind ( "build.analyzingSources" ) ) ; computeAllClasses ( ) ; checkCancel ( ) ; markDependentsOfChangedZips ( ) ; removeOldClasses ( ) ; checkCancel ( ) ; updateChangedClasses ( ) ; checkCancel ( ) ; addNewClasses ( ) ; checkCancel ( ) ; float amountPerIteration = 0.6F ; Vector vToCompile = fWorkQueue . getElementsToCompile ( ) ; while ( ( vToCompile . size ( ) ) != 0 ) { fNotifier . setProgressPerCompilationUnit ( ( amountPerIteration / ( vToCompile . size ( ) ) ) ) ; compile ( vToCompile ) ; vToCompile = fWorkQueue . getElementsToCompile ( ) ; amountPerIteration *= 0.25F ; } IResourceDelta projectDelta = ( ( IResourceDelta ) ( deltas . get ( fNewProject ) ) ) ; if ( projectDelta != null ) { ProjectResourceCopier copier = new ProjectResourceCopier ( fNewState . getJavaProject ( ) , fDC , fNotifier , 0.1F ) ; copier . updateAffectedResources ( projectDelta ) ; } cleanupUnusedNamespaceNodes ( ) ; checkCancel ( ) ; fNotifier . done ( ) ; } finally { cleanUp ( ) ; } } public void applySourceDelta ( IResourceDelta projectDelta ) { } protected void changedSourceElement ( SourceEntry newEntry ) { } protected void cleanUp ( ) { } protected void cleanupUnusedNamespaceNodes ( ) { } protected boolean compareVisibilityAndGender ( TypeStructureEntry tsEntry , IType type ) throws JavaModelException { } protected void compiling ( CompilerCompilationUnit unit ) { } protected void computeAllClasses ( ) { } protected void computeAllPackages ( ) { } protected void computeAllPackages ( IResourceDelta delta , IPackageFragmentRoot [ ] oldRoots , IPackageFragmentRoot [ ] newRoots ) { } protected void computeNamespaceChanges ( ) { } protected void computeNamespaceChanges ( Hashtable oldTSEntries , String parentTypeName , IType type , Vector vTypeNames ) throws JavaModelException { } protected void computeNamespaceChanges ( PackageElement element , Vector vTypeNames ) { } protected void computeNamespaceChanges ( IPackage pkg ) { } protected void computePackagePrefixChanges ( ) { } protected Hashtable computePackagePrefixes ( PackageMap packageMap ) { } static void dump ( IResourceDelta delta ) { } protected Enumeration getAffectedPackages ( ) { } protected BuilderType getBuilderType ( TypeStructureEntry oldEntry , TypeStructureEntry newEntry ) { } protected BuilderType getBuilderType ( org . eclipse . jdt . internal . core . builder . IType type ) { } public IDelta getImageDelta ( IImageContext imageContext ) { } protected Dictionary getSourceChanges ( IPackage pkgHandle ) { } protected boolean hasPackageMapChanges ( ) { } protected boolean hasSourceEntryChanges ( IPackage pkgHandle ) { } protected void issueIndictments ( Object element , IndictmentSet indicts , boolean transitive ) { } protected void issueIndictments ( DependencyGraph graph , Object element , IndictmentSet indicts , boolean transitive , Hashtable seen ) { } protected void markDependentsAsNeedingCompile ( Object element ) { } protected void markDependentsOfChangedZips ( ) { } protected void markOverlappingTypesAsNeedingCompile ( IPackage pkg ) { } protected void maybeForce ( IPackage pkg ) { } protected void propagatePrincipalStructureByPackageTable ( ) { } protected void recomputeSourceEntriesForChangedPackages ( ) { } protected void removeOldClasses ( ) { } protected void removeSourceElement ( SourceEntry entry ) { } protected void saveBinaryTypes ( PackageElement element ) { } protected void sort ( PackageElement [ ] compileArray ) { } public String toString ( ) { } protected boolean tryAbstractMethodIndictments ( PackageElement unit , IndictmentSet indictments ) { } protected boolean tryMethodDeclarations ( BuilderType builderType , IndictmentSet indictments ) { } protected boolean tryMethodDeclarations ( PackageElement unit , IndictmentSet indictments ) { } protected boolean tryUnit ( PackageElement unit , IndictmentSet indictments ) { } protected boolean tryZeroArgConstructorInSuperclass ( PackageElement unit , IndictmentSet indictments ) { } protected void updateChangedClasses ( ) { } protected void updatePackageMap ( ) { } protected void updateState ( ConvertedCompilationResult [ ] results ) { } }
public class HarnessSelectionTest extends TestCase { private static final String SELECT = "testdata/incremental/harness/selectionTest.xml" ; private static final String INCREMENTAL = "testdata/incremental/harness/suite.xml" ; private static Hashtable SPECS = new Hashtable ( ) ; private static Spec getSpec ( String suiteFile ) { } private boolean verbose ; public HarnessSelectionTest ( String name ) { } public void testIncrementalSuite ( ) { if ( ! ( eclipseAvailable ( ) ) ) { System . err . println ( "skipping<seq2seq4repair_space>test<seq2seq4repair_space>-<seq2seq4repair_space>eclipse<seq2seq4repair_space>classes<seq2seq4repair_space>not<seq2seq4repair_space>available" ) ; return ; } String [ ] options = new String [ ] { "!verbose" , "!eclipse" } ; <START_BUG> HarnessSelectionTest . Exp exp = new HarnessSelectionTest . Exp ( 8 , 8 , 0 , 8 , 0 , 0 , 0 ) ; <END_BUG> checkSelection ( HarnessSelectionTest . INCREMENTAL , options , "INFIX<seq2seq4repair_space>IGNORED" , exp ) ; } public void testKeywordSelectionBoth ( ) { } public void testKeywordSelectionRequire ( ) { } public void testKeywordSelectionSkip ( ) { } public void testNoOptions ( ) { } public void testEclipseOptionsSkip ( ) { } public void testAjcEclipseConflict ( ) { } public void testEclipseConflict ( ) { } public void testSinglePR ( ) { } public void testTwoPR ( ) { } private RunResult runSuite ( String suiteFile , String [ ] options , MessageHandler setupHolder ) { } class Exp { public final int tests ; public final int testsRun ; public final int skipped ; public final int passed ; public final int failed ; public final int incomplete ; public final int infix ; Exp ( int tests , int testsRun , int skipped , int passed , int failed , int incomplete , int infix ) { } } public void checkSelection ( String suiteFile , String [ ] options , String infoInfix , HarnessSelectionTest . Exp exp ) { } private boolean ajcAvailable ( ) { } private boolean eclipseAvailable ( ) { } }
public abstract class AbstractExpressionBuilder { protected static final int EX_USER = 0 ; protected static final int EX_FATAL = 1 ; protected static final int EX_UNSUPPORTED = 2 ; protected static final Class TYPE_OBJECT = Object . class ; protected static final Class TYPE_STRING = String . class ; protected static final Class TYPE_CHAR_OBJ = Character . class ; protected static final Class TYPE_NUMBER = Number . class ; protected static final Class TYPE_COLLECTION = Collection . class ; protected static final Class TYPE_MAP = Map . class ; protected static final int CONTAINS_TYPE_ELEMENT = 1 ; protected static final int CONTAINS_TYPE_KEY = 2 ; protected static final int CONTAINS_TYPE_VALUE = 3 ; private static final Localizer _loc = Localizer . forPackage ( AbstractExpressionBuilder . class ) ; protected final Resolver resolver ; protected ExpressionFactory factory ; private final Set _accessPath = new HashSet ( ) ; private Map _seenVars = null ; private Set _boundVars = null ; public AbstractExpressionBuilder ( ExpressionFactory factory , Resolver resolver ) { } protected abstract ClassLoader getClassLoader ( ) { } protected OpenJPAException parseException ( int e , String token , Object [ ] args , Exception nest ) { } protected ClassMetaData addAccessPath ( ClassMetaData meta ) { } protected ClassMetaData [ ] getAccessPath ( ) { } protected boolean isBound ( Value var ) { } protected void bind ( Value var ) { } protected Value getVariable ( String id , boolean bind ) { } protected void assertUnboundVariablesValid ( ) { } protected abstract boolean isDeclaredVariable ( String id ) { } protected boolean isSeenVariable ( String id ) { } protected ClassMetaData getMetaData ( Class c , boolean required ) { } protected ClassMetaData getMetaData ( Class c , boolean required , ClassLoader loader ) { <START_BUG> return resolver . getConfiguration ( ) . getMetaDataRepository ( ) . getMetaData ( c , loader , required ) ; <END_BUG> } protected Value traversePath ( Path path , String field ) { } protected Value traversePath ( Path path , String field , boolean pcOnly , boolean allowNull ) { } protected Object traverseStaticField ( Class cls , String field ) { } protected abstract Class getDeclaredVariableType ( String name ) { } protected void setImplicitTypes ( Value val1 , Value val2 , Class expected ) { } private void convertTypes ( Value val1 , Value val2 ) { } private void convertTypesQuotedNumbers ( Value val1 , Value val2 ) { } private static boolean isNumeric ( Class type ) { } protected void setImplicitContainsTypes ( Value val1 , Value val2 , int op ) { } protected static void setImplicitType ( Value val , Class expected ) { } protected abstract Localizer getLocalizer ( ) { } protected abstract String currentQuery ( ) { } }
public class Composite extends Scrollable { Layout layout ; WINDOWPOS [ ] lpwp ; Control [ ] tabList ; int layoutCount ; int backgroundMode ; Composite ( ) { } public Composite ( Composite parent , int style ) { } Control [ ] _getChildren ( ) { } Control [ ] _getTabList ( ) { } public void changed ( Control [ ] changed ) { } void checkBuffered ( ) { } void checkComposited ( ) { } protected void checkSubclass ( ) { } Control [ ] computeTabList ( ) { } public Point computeSize ( int wHint , int hHint , boolean changed ) { } void copyArea ( GC gc , int x , int y , int width , int height ) { } void createHandle ( ) { } Composite findDeferredControl ( ) { } Menu [ ] findMenus ( Control control ) { } void fixChildren ( Shell newShell , Shell oldShell , Decorations newDecorations , Decorations oldDecorations , Menu [ ] menus ) { } void fixTabList ( Control control ) { } public int getBackgroundMode ( ) { } public Control [ ] getChildren ( ) { } int getChildrenCount ( ) { } public Layout getLayout ( ) { } public Control [ ] getTabList ( ) { } boolean hooksKeys ( ) { } public boolean getLayoutDeferred ( ) { } public boolean isLayoutDeferred ( ) { } public void layout ( ) { } public void layout ( boolean changed ) { } public void layout ( boolean changed , boolean all ) { } public void layout ( Control [ ] changed ) { } void markLayout ( boolean changed , boolean all ) { } Point minimumSize ( int wHint , int hHint , boolean changed ) { } boolean redrawChildren ( ) { } void releaseParent ( ) { } void releaseChildren ( boolean destroy ) { } void releaseWidget ( ) { } void removeControl ( Control control ) { } void resizeChildren ( ) { } boolean resizeChildren ( boolean defer , WINDOWPOS [ ] pwp ) { } void resizeEmbeddedHandle ( int embeddedHandle , int width , int height ) { } void sendResize ( ) { } public void setBackgroundMode ( int mode ) { } void setBounds ( int x , int y , int width , int height , int flags , boolean defer ) { if ( ( display . resizeCount ) > ( Display . RESIZE_LIMIT ) ) { defer = false ; } if ( ( ! defer ) && ( ( ( state ) & ( CANVAS ) ) != 0 ) ) { <START_BUG> state &= ( ~ ( RESIZE_OCCURRED ) ) | ( MOVE_OCCURRED ) ; <END_BUG> state |= ( RESIZE_DEFERRED ) | ( MOVE_DEFERRED ) ; } super . setBounds ( x , y , width , height , flags , defer ) ; if ( ( ! defer ) && ( ( ( state ) & ( CANVAS ) ) != 0 ) ) { boolean wasMoved = ( ( state ) & ( MOVE_OCCURRED ) ) != 0 ; boolean wasResized = ( ( state ) & ( RESIZE_OCCURRED ) ) != 0 ; state &= ~ ( ( RESIZE_DEFERRED ) | ( MOVE_DEFERRED ) ) ; if ( wasMoved && ( ! ( isDisposed ( ) ) ) ) sendMove ( ) ; if ( wasResized && ( ! ( isDisposed ( ) ) ) ) sendResize ( ) ; } } boolean setFixedFocus ( ) { } public boolean setFocus ( ) { } public void setLayout ( Layout layout ) { } public void setLayoutDeferred ( boolean defer ) { } public void setTabList ( Control [ ] tabList ) { } void setResizeChildren ( boolean resize ) { } boolean setTabGroupFocus ( ) { } String toolTipText ( NMTTDISPINFO hdr ) { } boolean translateMnemonic ( Event event , Control control ) { } boolean translateTraversal ( MSG msg ) { } void updateBackgroundColor ( ) { } void updateBackgroundImage ( ) { } void updateBackgroundMode ( ) { } void updateFont ( Font oldFont , Font newFont ) { } void updateLayout ( boolean resize , boolean all ) { } void updateUIState ( ) { } int widgetStyle ( ) { } LRESULT WM_ERASEBKGND ( int wParam , int lParam ) { } LRESULT WM_GETDLGCODE ( int wParam , int lParam ) { } LRESULT WM_GETFONT ( int wParam , int lParam ) { } LRESULT WM_LBUTTONDOWN ( int wParam , int lParam ) { } LRESULT WM_NCHITTEST ( int wParam , int lParam ) { } LRESULT WM_PARENTNOTIFY ( int wParam , int lParam ) { } LRESULT WM_PAINT ( int wParam , int lParam ) { } LRESULT WM_PRINTCLIENT ( int wParam , int lParam ) { } LRESULT WM_SETFONT ( int wParam , int lParam ) { } LRESULT WM_SIZE ( int wParam , int lParam ) { } LRESULT WM_SYSCOLORCHANGE ( int wParam , int lParam ) { } LRESULT WM_SYSCOMMAND ( int wParam , int lParam ) { } LRESULT WM_UPDATEUISTATE ( int wParam , int lParam ) { } LRESULT wmNCPaint ( int hwnd , int wParam , int lParam ) { } LRESULT wmNotify ( NMHDR hdr , int wParam , int lParam ) { } }
public class PlacementModelContainer extends NetworkImpl { private int nodes ; private int hotspots ; private Partitioner partitioner ; private PlacementModel hotspotPlacer ; private PlacementModel nodePlacer ; private NodeConnector connector ; private PlaneIdentifierSpaceSimple idSpace ; public PlacementModelContainer ( int nodes , int hotspots , PlacementModel hotspotPlacer , PlacementModel nodePlacer , Partitioner partitioner , NodeConnector nodeConnector , RoutingAlgorithm r , Transformation [ ] t ) { } private static String getKey ( PlacementModel hotspotPlacer , PlacementModel nodePlacer ) { } private static String [ ] getConfigValues ( PlacementModel hotspotPlacer , PlacementModel nodePlacer , NodeConnector connector , Partitioner partitioner ) { } private static String [ ] getConfigKeys ( PlacementModel hotspotPlacer , PlacementModel nodePlacer , NodeConnector connector , Partitioner partitioner ) { } @ Override public Graph generate ( ) { Point [ ] hotspotCoords = hotspotPlacer . place ( hotspots ) ; PlanePartitionSimple [ ] coords = new PlanePartitionSimple [ nodes ] ; int [ ] nodesPerSpot = partitioner . partition ( nodes , hotspots ) ; int temp = 0 ; int curNodes ; for ( int i = 0 ; i < ( hotspots ) ; i ++ ) { curNodes = nodesPerSpot [ i ] ; addNodeCoords ( coords , nodePlacer . place ( curNodes ) , hotspotCoords [ i ] , temp ) ; temp += curNodes ; } Graph g = new Graph ( description ( ) ) ; idSpace . setPartitions ( coords ) ; <START_BUG> g . addProperty ( "id_space_0" , idSpace ) ; <END_BUG> Node [ ] nodes = Node . init ( this . nodes ( ) , g ) ; connector . connect ( nodes , idSpace ) ; g . setNodes ( nodes ) ; return g ; } private void addNodeCoords ( PlanePartitionSimple [ ] pps , Point [ ] nodeCoords , Point coordOffset , int arrayOffset ) { } }
public String getText ( ) { } int gtk_button_press_event ( int widget , int event ) { } int gtk_button_release_event ( int widget , int event ) { } int gtk_event_after ( int widget , int gdkEvent ) { } int gtk_expose_event ( int widget , int eventPtr ) { } int gtk_key_press_event ( int widget , int eventPtr ) { } int gtk_motion_notify_event ( int widget , int event ) { } void releaseWidget ( ) { } public void removeSelectionListener ( SelectionListener listener ) { } String parse ( String string ) { int length = string . length ( ) ; offsets = new Point [ length / 4 ] ; ids = new String [ length / 4 ] ; mnemonics = new int [ ( length / 4 ) + 1 ] ; StringBuffer result = new StringBuffer ( ) ; char [ ] buffer = new char [ length ] ; string . getChars ( 0 , string . length ( ) , buffer , 0 ) ; int index = 0 ; int state = 0 ; int linkIndex = 0 ; int start = 0 ; int tagStart = 0 ; int linkStart = 0 ; int endtagStart = 0 ; int refStart = 0 ; while ( index < length ) { char c = Character . toLowerCase ( buffer [ index ] ) ; switch ( state ) { case 0 : if ( c == '<' ) { tagStart = index ; state ++ ; } break ; case 1 : if ( c == 'a' ) state ++ ; break ; case 2 : switch ( c ) { case 'h' : state = 7 ; break ; case '>' : linkStart = index + 1 ; state ++ ; break ; default : if ( Character . isWhitespace ( c ) ) break ; else state = 13 ; } break ; case 3 : if ( c == '<' ) { endtagStart = index ; state ++ ; } break ; case 4 : state = ( c == '/' ) ? state + 1 : 3 ; break ; case 5 : state = ( c == 'a' ) ? state + 1 : 3 ; break ; case 6 : if ( c == '>' ) { mnemonics [ linkIndex ] = parseMnemonics ( buffer , start , tagStart , result ) ; int offset = result . length ( ) ; parseMnemonics ( buffer , linkStart , endtagStart , result ) ; offsets [ linkIndex ] = new Point ( offset , ( ( result . length ( ) ) - 1 ) ) ; if ( ( ids [ linkIndex ] ) == null ) { ids [ linkIndex ] = new String ( buffer , linkStart , ( endtagStart - linkStart ) ) ; } linkIndex ++ ; start = tagStart = linkStart = endtagStart = refStart = index + 1 ; state = 0 ; } else { state = 3 ; } break ; case 7 : state = ( c == 'r' ) ? state + 1 : 0 ; break ; case 8 : state = ( c == 'e' ) ? state + 1 : 0 ; break ; case 9 : state = ( c == 'f' ) ? state + 1 : 0 ; break ; case 10 : state = ( c == '=' ) ? state + 1 : 0 ; break ; case 11 : if ( c == '"' ) { state ++ ; refStart = index + 1 ; } else { state = 0 ; } break ; case 12 : if ( c == '"' ) { ids [ linkIndex ] = new String ( buffer , refStart , ( index - refStart ) ) ; state = 2 ; } break ; case 13 : if ( Character . isWhitespace ( c ) ) { state = 0 ; } else if ( c == '=' ) { state ++ ; } break ; case 14 : state = ( c == '"' ) ? state + 1 : 0 ; break ; case 15 : if ( c == '"' ) state = 2 ; break ; default : state = 0 ; break ; } index ++ ; } if ( start < length ) { int tmp = parseMnemonics ( buffer , start , tagStart , result ) ; <START_BUG> int mnemonic = parseMnemonics ( buffer , linkStart , index , result ) ; <END_BUG> if ( mnemonic == ( - 1 ) ) mnemonic = tmp ; mnemonics [ linkIndex ] = mnemonic ; } else { mnemonics [ linkIndex ] = - 1 ; } if ( ( offsets . length ) != linkIndex ) { Point [ ] newOffsets = new Point [ linkIndex ] ; System . arraycopy ( offsets , 0 , newOffsets , 0 , linkIndex ) ; offsets = newOffsets ; String [ ] newIDs = new String [ linkIndex ] ; System . arraycopy ( ids , 0 , newIDs , 0 , linkIndex ) ; ids = newIDs ; int [ ] newMnemonics = new int [ linkIndex + 1 ] ; System . arraycopy ( mnemonics , 0 , newMnemonics , 0 , ( linkIndex + 1 ) ) ; mnemonics = newMnemonics ; } return result . toString ( ) ; } int parseMnemonics ( char [ ] buffer , int start , int end , StringBuffer result ) { } int setBounds ( int x , int y , int width , int height , boolean move , boolean resize ) { } void setFontDescription ( int font ) { } public void setText ( String string ) { } void showWidget ( ) { } int traversalCode ( int key , GdkEventKey event ) { } }
@ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest public final void testRightOuterJoinWithThetaJoinConditionInWhere ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest public final void testLeftOuterJoin1 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest public final void testLeftOuterJoinWithConstantExpr1 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest public final void testLeftOuterJoinWithConstantExpr4 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest public final void testLeftOuterJoinWithConstantExpr5 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest public final void testRightOuterJoin1 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest public final void testFullOuterJoin1 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest public void testOuterJoinAndCaseWhen1 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest public final void testLeftOuterJoinWithEmptyTable1 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest public final void testLeftOuterJoinWithEmptyTable2 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest public final void testLeftOuterJoinWithEmptyTable3 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest public final void testLeftOuterJoinWithEmptyTable4 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest public final void testLeftOuterJoinWithEmptyTable5 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest public final void testRightOuterJoinWithEmptyTable1 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest public final void testFullOuterJoinWithEmptyTable1 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest public final void testLeftOuterJoinWithNull1 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest public final void testLeftOuterJoinWithNull2 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest public final void testLeftOuterJoinWithNull3 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true , sort = true ) @ SimpleTest ( queries = { @ QuerySpec ( "select<seq2seq4repair_space>t1.id,<seq2seq4repair_space>t1.name,<seq2seq4repair_space>t2.id,<seq2seq4repair_space>t3.id\n" + ( ( ( ( "from<seq2seq4repair_space>jointable11<seq2seq4repair_space>t1\n" + "left<seq2seq4repair_space>outer<seq2seq4repair_space>join<seq2seq4repair_space>jointable12<seq2seq4repair_space>t2\n" ) + "on<seq2seq4repair_space>t1.id<seq2seq4repair_space>=<seq2seq4repair_space>t2.id\n" ) + "left<seq2seq4repair_space>outer<seq2seq4repair_space>join<seq2seq4repair_space>jointable13<seq2seq4repair_space>t3\n" ) + "on<seq2seq4repair_space>t1.id<seq2seq4repair_space>=<seq2seq4repair_space>t3.id<seq2seq4repair_space>and<seq2seq4repair_space>t2.id<seq2seq4repair_space>=<seq2seq4repair_space>t3.id" ) ) } ) public final void testLeftOuterJoinPredicationCaseByCase1 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest ( queries = { @ QuerySpec ( "select<seq2seq4repair_space>t1.id,<seq2seq4repair_space>t1.name,<seq2seq4repair_space>t2.id,<seq2seq4repair_space>t3.id,<seq2seq4repair_space>t4.id\n" + ( ( ( ( ( ( "from<seq2seq4repair_space>jointable11<seq2seq4repair_space>t1\n" + "left<seq2seq4repair_space>outer<seq2seq4repair_space>join<seq2seq4repair_space>jointable12<seq2seq4repair_space>t2\n" ) + "on<seq2seq4repair_space>t1.id<seq2seq4repair_space>=<seq2seq4repair_space>t2.id\n" ) + "left<seq2seq4repair_space>outer<seq2seq4repair_space>join<seq2seq4repair_space>jointable13<seq2seq4repair_space>t3\n" ) + "on<seq2seq4repair_space>t2.id<seq2seq4repair_space>=<seq2seq4repair_space>t3.id\n" ) + "inner<seq2seq4repair_space>join<seq2seq4repair_space>jointable14<seq2seq4repair_space>t4\n" ) + "on<seq2seq4repair_space>t2.id<seq2seq4repair_space>=<seq2seq4repair_space>t4.id" ) ) } ) public final void testLeftOuterJoinPredicationCaseByCase2 ( ) throws Exception { } @ Test <START_BUG> @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) <END_BUG> @ SimpleTest ( queries = { @ QuerySpec ( "select<seq2seq4repair_space>t1.id,<seq2seq4repair_space>t1.name,<seq2seq4repair_space>t2.id,<seq2seq4repair_space>t3.id,<seq2seq4repair_space>t4.id\n" + ( ( ( ( ( ( ( "from<seq2seq4repair_space>jointable11<seq2seq4repair_space>t1\n" + "inner<seq2seq4repair_space>join<seq2seq4repair_space>jointable14<seq2seq4repair_space>t4\n" ) + "on<seq2seq4repair_space>t1.id<seq2seq4repair_space>=<seq2seq4repair_space>t4.id<seq2seq4repair_space>and<seq2seq4repair_space>t4.id<seq2seq4repair_space>><seq2seq4repair_space>1\n" ) + "left<seq2seq4repair_space>outer<seq2seq4repair_space>join<seq2seq4repair_space>jointable13<seq2seq4repair_space>t3\n" ) + "on<seq2seq4repair_space>t4.id<seq2seq4repair_space>=<seq2seq4repair_space>t3.id<seq2seq4repair_space>and<seq2seq4repair_space>t3.id<seq2seq4repair_space>=<seq2seq4repair_space>2\n" ) + "left<seq2seq4repair_space>outer<seq2seq4repair_space>join<seq2seq4repair_space>jointable12<seq2seq4repair_space>t2\n" ) + "on<seq2seq4repair_space>t1.id<seq2seq4repair_space>=<seq2seq4repair_space>t2.id<seq2seq4repair_space>\n" ) + "where<seq2seq4repair_space>t1.id<seq2seq4repair_space>><seq2seq4repair_space>1" ) ) } ) public final void testLeftOuterJoinPredicationCaseByCase2_1 ( ) throws Exception { runSimpleTests ( ) ; } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true , sort = true ) @ SimpleTest ( queries = { @ QuerySpec ( "select<seq2seq4repair_space>t1.id,<seq2seq4repair_space>t1.name,<seq2seq4repair_space>t2.id,<seq2seq4repair_space>t3.id\n" + ( ( ( ( "from<seq2seq4repair_space>jointable11<seq2seq4repair_space>t1\n" + "left<seq2seq4repair_space>outer<seq2seq4repair_space>join<seq2seq4repair_space>jointable12<seq2seq4repair_space>t2<seq2seq4repair_space>\n" ) + "on<seq2seq4repair_space>t1.id<seq2seq4repair_space>=<seq2seq4repair_space>t2.id<seq2seq4repair_space>and<seq2seq4repair_space>(concat(t1.name,<seq2seq4repair_space>cast(t2.id<seq2seq4repair_space>as<seq2seq4repair_space>TEXT))<seq2seq4repair_space>=<seq2seq4repair_space>\'table11-11\'<seq2seq4repair_space>or<seq2seq4repair_space>concat(t1.name,<seq2seq4repair_space>cast(t2.id<seq2seq4repair_space>as<seq2seq4repair_space>TEXT))<seq2seq4repair_space>=<seq2seq4repair_space>\'table11-33\')\n" ) + "left<seq2seq4repair_space>outer<seq2seq4repair_space>join<seq2seq4repair_space>jointable13<seq2seq4repair_space>t3\n" ) + "on<seq2seq4repair_space>t1.id<seq2seq4repair_space>=<seq2seq4repair_space>t3.id<seq2seq4repair_space>" ) ) } ) public final void testLeftOuterJoinPredicationCaseByCase3 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true , sort = true ) @ SimpleTest ( queries = { @ QuerySpec ( "select<seq2seq4repair_space>t1.id,<seq2seq4repair_space>t1.name,<seq2seq4repair_space>t2.id,<seq2seq4repair_space>t3.id\n" + ( ( ( ( "from<seq2seq4repair_space>jointable11<seq2seq4repair_space>t1\n" + "left<seq2seq4repair_space>outer<seq2seq4repair_space>join<seq2seq4repair_space>jointable12<seq2seq4repair_space>t2\n" ) + "on<seq2seq4repair_space>t1.id<seq2seq4repair_space>=<seq2seq4repair_space>t2.id<seq2seq4repair_space>and<seq2seq4repair_space>t2.id<seq2seq4repair_space>><seq2seq4repair_space>1<seq2seq4repair_space>\n" ) + "left<seq2seq4repair_space>outer<seq2seq4repair_space>join<seq2seq4repair_space>jointable13<seq2seq4repair_space>t3\n" ) + "on<seq2seq4repair_space>t1.id<seq2seq4repair_space>=<seq2seq4repair_space>t3.id" ) ) } ) public final void testLeftOuterJoinPredicationCaseByCase4 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true , sort = true ) @ SimpleTest ( queries = { @ QuerySpec ( "select<seq2seq4repair_space>t1.id,<seq2seq4repair_space>t1.name,<seq2seq4repair_space>t2.id,<seq2seq4repair_space>t3.id\n" + ( ( ( ( ( "from<seq2seq4repair_space>jointable11<seq2seq4repair_space>t1\n" + "left<seq2seq4repair_space>outer<seq2seq4repair_space>join<seq2seq4repair_space>jointable12<seq2seq4repair_space>t2\n" ) + "on<seq2seq4repair_space>t1.id<seq2seq4repair_space>=<seq2seq4repair_space>t2.id\n" ) + "left<seq2seq4repair_space>outer<seq2seq4repair_space>join<seq2seq4repair_space>jointable13<seq2seq4repair_space>t3\n" ) + "on<seq2seq4repair_space>t1.id<seq2seq4repair_space>=<seq2seq4repair_space>t3.id\n" ) + "where<seq2seq4repair_space>t1.name<seq2seq4repair_space>><seq2seq4repair_space>'table11-1'" ) ) } ) public final void testLeftOuterJoinPredicationCaseByCase5 ( ) throws Exception { } @ Test @ Option ( withExplain = true , withExplainGlobal = true , parameterized = true ) @ SimpleTest ( queries = { @ QuerySpec ( "select<seq2seq4repair_space>t1.id,<seq2seq4repair_space>t1.name,<seq2seq4repair_space>t2.id,<seq2seq4repair_space>t3.id\n" + ( ( ( ( ( "from<seq2seq4repair_space>jointable11<seq2seq4repair_space>t1\n" + "left<seq2seq4repair_space>outer<seq2seq4repair_space>join<seq2seq4repair_space>jointable12<seq2seq4repair_space>t2\n" ) + "on<seq2seq4repair_space>t1.id<seq2seq4repair_space>=<seq2seq4repair_space>t2.id\n" ) + "left<seq2seq4repair_space>outer<seq2seq4repair_space>join<seq2seq4repair_space>jointable13<seq2seq4repair_space>t3\n" ) + "on<seq2seq4repair_space>t1.id<seq2seq4repair_space>=<seq2seq4repair_space>t3.id\n" ) + "where<seq2seq4repair_space>t3.id<seq2seq4repair_space>><seq2seq4repair_space>2" ) ) } ) public final void testLeftOuterJoinPredicationCaseByCase6 ( ) throws Exception { }
public class RemoveMember extends PlayerCommand { public RemoveMember ( String name ) { } @ Override public boolean execute ( CommandSender sender , String [ ] args ) { if ( ! ( sender instanceof Player ) ) { sender . sendMessage ( ( ( ChatColor . RED ) + "I'm<seq2seq4repair_space>sorry<seq2seq4repair_space>baby,<seq2seq4repair_space>please<seq2seq4repair_space>run<seq2seq4repair_space>this<seq2seq4repair_space>as<seq2seq4repair_space>a<seq2seq4repair_space>player<seq2seq4repair_space>:)" ) ) ; return true ; } Player p = ( ( Player ) ( sender ) ) ; Group group = gm . getGroup ( args [ 0 ] ) ; if ( group == null ) { p . sendMessage ( ( ( ChatColor . RED ) + "That<seq2seq4repair_space>group<seq2seq4repair_space>does<seq2seq4repair_space>not<seq2seq4repair_space>exist." ) ) ; return true ; } if ( group . isDisciplined ( ) ) { p . sendMessage ( ( ( ChatColor . RED ) + "This<seq2seq4repair_space>group<seq2seq4repair_space>is<seq2seq4repair_space>disiplined." ) ) ; return true ; } UUID executor = NameAPI . getUUID ( p . getName ( ) ) ; <START_BUG> UUID uuid = NameAPI . getUUID ( args [ 0 ] ) ; <END_BUG> GroupPermission perm = gm . getPermissionforGroup ( group ) ; PlayerType t = group . getPlayerType ( executor ) ; PlayerType toBeRemoved = group . getPlayerType ( uuid ) ; if ( toBeRemoved == null ) { p . sendMessage ( ( ( ChatColor . RED ) + "That<seq2seq4repair_space>player<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>on<seq2seq4repair_space>the<seq2seq4repair_space>group." ) ) ; return true ; } boolean allowed = false ; switch ( toBeRemoved ) { case MEMBERS : allowed = perm . isAccessible ( t , MEMBERS ) ; break ; case MODS : allowed = perm . isAccessible ( t , MODS ) ; break ; case ADMINS : allowed = perm . isAccessible ( t , ADMINS ) ; break ; case OWNER : allowed = perm . isAccessible ( t , OWNER ) ; break ; default : allowed = false ; break ; } if ( ( ! allowed ) && ( ! ( ( p . isOp ( ) ) || ( p . hasPermission ( "namelayer.admin" ) ) ) ) ) { p . sendMessage ( ( ( ChatColor . RED ) + "You<seq2seq4repair_space>do<seq2seq4repair_space>not<seq2seq4repair_space>have<seq2seq4repair_space>permissions<seq2seq4repair_space>to<seq2seq4repair_space>modify<seq2seq4repair_space>this<seq2seq4repair_space>group." ) ) ; return true ; } if ( uuid == null ) { p . sendMessage ( ( ( ChatColor . RED ) + "The<seq2seq4repair_space>player<seq2seq4repair_space>has<seq2seq4repair_space>never<seq2seq4repair_space>played<seq2seq4repair_space>before." ) ) ; return true ; } if ( ! ( group . isMember ( uuid ) ) ) { p . sendMessage ( ( ( ChatColor . RED ) + "That<seq2seq4repair_space>player<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>on<seq2seq4repair_space>the<seq2seq4repair_space>group." ) ) ; return true ; } if ( group . isOwner ( uuid ) ) { p . sendMessage ( ( ( ( ChatColor . RED ) + "That<seq2seq4repair_space>player<seq2seq4repair_space>owns<seq2seq4repair_space>the<seq2seq4repair_space>group,<seq2seq4repair_space>you<seq2seq4repair_space>cannot<seq2seq4repair_space>" ) + "remove<seq2seq4repair_space>the<seq2seq4repair_space>player." ) ) ; return true ; } p . sendMessage ( ( ( ChatColor . GREEN ) + "Player<seq2seq4repair_space>has<seq2seq4repair_space>been<seq2seq4repair_space>removed<seq2seq4repair_space>from<seq2seq4repair_space>the<seq2seq4repair_space>group." ) ) ; group . removeMember ( uuid ) ; return true ; } }
public class NamingExtension implements Extension { public static final String NAMESPACE = "urn:jboss:domain:naming:1.0" ; static final NamingExtension . NamingSubSystemElementParser PARSER = new NamingExtension . NamingSubSystemElementParser ( ) ; static final SubsystemFactory < NamingSubsystemElement > FACTORY = new SubsystemFactory < NamingSubsystemElement > ( ) { public NamingSubsystemElement createSubsystemElement ( ) { } } ; public void initialize ( ExtensionContext context ) { <START_BUG> context . registerSubsystem ( NamingExtension . NAMESPACE , NamingExtension . FACTORY , NamingExtension . PARSER ) ; <END_BUG> } public void activate ( final ServiceActivatorContext context ) { } static class NamingSubSystemElementParser implements XMLElementReader < List < ? super AbstractSubsystemUpdate < NamingSubsystemElement , ? > > > { public void readElement ( XMLExtendedStreamReader reader , List < ? super AbstractSubsystemUpdate < NamingSubsystemElement , ? > > updates ) throws XMLStreamException { } } }
public abstract class Openable extends JavaElement implements IBufferChangedListener , IOpenable { protected Openable ( int type , IJavaElement parent , String name ) { } public void bufferChanged ( BufferChangedEvent event ) { } protected void buildStructure ( OpenableElementInfo info , IProgressMonitor pm ) throws JavaModelException { } protected void closeBuffer ( OpenableElementInfo info ) { } protected void closing ( Object info ) throws JavaModelException { } protected void codeComplete ( ICompilationUnit cu , ICompilationUnit unitToSkip , int position , ICodeCompletionRequestor requestor ) throws JavaModelException { if ( requestor == null ) { throw new IllegalArgumentException ( Util . bind ( "codeAssist.nullRequestor" ) ) ; } IBuffer buffer = getBuffer ( ) ; if ( buffer == null ) { return ; } if ( ( position < ( - 1 ) ) || ( position > ( buffer . getLength ( ) ) ) ) { throw new JavaModelException ( new JavaModelStatus ( IJavaModelStatusConstants . INDEX_OUT_OF_BOUNDS ) ) ; } SearchableEnvironment environment = ( ( SearchableEnvironment ) ( ( ( JavaProject ) ( getJavaProject ( ) ) ) . getSearchableNameEnvironment ( ) ) ) ; <START_BUG> INameLookup nameLookup = ( ( JavaProject ) ( getJavaProject ( ) ) ) . getNameLookup ( ) ; <END_BUG> environment . unitToSkip = unitToSkip ; CompletionEngine engine = new CompletionEngine ( environment , new CompletionRequestorWrapper ( requestor , nameLookup ) , JavaCore . getOptions ( ) ) ; engine . complete ( cu , position ) ; environment . unitToSkip = null ; } protected IJavaElement [ ] codeSelect ( ICompilationUnit cu , int offset , int length ) throws JavaModelException { } protected void codeSelect ( ICompilationUnit cu , int offset , int length , ISelectionRequestor requestor ) throws JavaModelException { } protected OpenableElementInfo createElementInfo ( ) { } protected abstract boolean generateInfos ( OpenableElementInfo info , IProgressMonitor pm , Hashtable newElements , IResource underlyingResource ) throws JavaModelException { } public IBuffer getBuffer ( ) throws JavaModelException { } protected IBufferManager getBufferManager ( ) { } public IResource getCorrespondingResource ( ) throws JavaModelException { } public IResource getUnderlyingResource ( ) throws JavaModelException { } protected boolean hasBuffer ( ) { } public boolean hasChildren ( ) throws JavaModelException { } public boolean hasUnsavedChanges ( ) throws JavaModelException { } public boolean isConsistent ( ) throws JavaModelException { } public boolean isOpen ( ) { } protected boolean isSourceElement ( ) { } public void makeConsistent ( IProgressMonitor pm ) throws JavaModelException { } public void open ( IProgressMonitor pm ) throws JavaModelException { } protected IBuffer openBuffer ( IProgressMonitor pm ) throws JavaModelException { } protected void openWhenClosed ( IProgressMonitor pm ) throws JavaModelException { } public void save ( IProgressMonitor pm , boolean force ) throws JavaModelException { } public PackageFragmentRoot getPackageFragmentRoot ( ) { } }
public class Logger { public static final int ATTR_TIME = 1 ; public static final int ATTR_THREAD = 2 ; public static final int ATTR_DEFAULT = ( Logger . ATTR_TIME ) | ( Logger . ATTR_THREAD ) ; public static final LogLevel INFO = new LogLevel ( "INFO" ) ; public static final LogLevel WARN = new LogLevel ( "WARN" ) . setPrintStream ( System . err ) ; public static final LogLevel ERROR = new LogLevel ( "ERROR" ) . setPrintStream ( System . err ) ; public static final LogLevel SEVERE = new LogLevel ( "SEVERE" ) . setPrintStream ( System . err ) ; public DateFormat dateFormat = new SimpleDateFormat ( "dd/MM/yy-hh:mm:ss" ) ; public static ArrayList < String > backlog = new ArrayList < String > ( ) ; public static ArrayList < LogHandler > handlers = new ArrayList < LogHandler > ( ) ; int attr ; String name ; public static void addHandler ( LogHandler handler ) { } public Logger ( String name , int attributes ) { } String getTime ( ) { } private void log ( String message , String level , PrintStream ps ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( getPrefix ( level ) ) ; builder . append ( message ) ; String ts = builder . toString ( ) ; ps . println ( ts ) ; Logger . backlog . add ( ts ) ; for ( LogHandler hand : Logger . handlers ) <START_BUG> hand . onLog ( message , level ) ; <END_BUG> } public String getPrefix ( String level ) { } public void exception ( Throwable e ) { } public void log ( String message , LogLevel level ) { } public void info ( String message ) { } public void warn ( String message ) { } public void error ( String message ) { } public void severe ( String message ) { } }
public class ReconcileWorkingCopyOperation extends JavaModelOperation { public static boolean PERF = false ; public int astLevel ; public boolean resolveBindings ; public HashMap problems ; boolean forceProblemDetection ; WorkingCopyOwner workingCopyOwner ; public CompilationUnit ast ; public JavaElementDeltaBuilder deltaBuilder ; public ReconcileWorkingCopyOperation ( IJavaElement workingCopy , int astLevel , boolean forceProblemDetection , WorkingCopyOwner workingCopyOwner ) { } protected void executeOperation ( ) throws JavaModelException { if ( ( this . progressMonitor ) != null ) { if ( this . progressMonitor . isCanceled ( ) ) throw new OperationCanceledException ( ) ; this . progressMonitor . beginTask ( Messages . element_reconciling , 2 ) ; } CompilationUnit workingCopy = getWorkingCopy ( ) ; IProblemRequestor problemRequestor = workingCopy . getPerWorkingCopyInfo ( ) ; this . resolveBindings |= ( problemRequestor != null ) && ( problemRequestor . isActive ( ) ) ; this . deltaBuilder = new JavaElementDeltaBuilder ( workingCopy ) ; makeConsistent ( workingCopy , problemRequestor ) ; notifyParticipants ( workingCopy ) ; if ( ( ( this . ast ) == null ) && ( ( ( this . astLevel ) > ( ICompilationUnit . NO_AST ) ) || ( this . resolveBindings ) ) ) makeConsistent ( workingCopy , problemRequestor ) ; if ( ( this . problems ) != null ) { try { problemRequestor . beginReporting ( ) ; <START_BUG> for ( Iterator iteraror = problems . values ( ) . iterator ( ) ; iteraror . hasNext ( ) ; ) { <END_BUG> CategorizedProblem [ ] categorizedProblems = ( ( CategorizedProblem [ ] ) ( iteraror . next ( ) ) ) ; if ( categorizedProblems == null ) continue ; for ( int i = 0 , length = categorizedProblems . length ; i < length ; i ++ ) { CategorizedProblem problem = categorizedProblems [ i ] ; if ( JavaModelManager . VERBOSE ) { System . out . println ( ( "PROBLEM<seq2seq4repair_space>FOUND<seq2seq4repair_space>while<seq2seq4repair_space>reconciling<seq2seq4repair_space>:<seq2seq4repair_space>" + ( problem . getMessage ( ) ) ) ) ; } if ( ( ( this . progressMonitor ) != null ) && ( this . progressMonitor . isCanceled ( ) ) ) break ; problemRequestor . acceptProblem ( problem ) ; } } } finally { problemRequestor . endReporting ( ) ; } } try { JavaElementDelta delta = this . deltaBuilder . delta ; if ( delta != null ) { addReconcileDelta ( workingCopy , delta ) ; } } finally { if ( ( this . progressMonitor ) != null ) this . progressMonitor . done ( ) ; } } protected CompilationUnit getWorkingCopy ( ) { } public boolean isReadOnly ( ) { } public CompilationUnit makeConsistent ( CompilationUnit workingCopy , IProblemRequestor problemRequestor ) throws JavaModelException { } private void notifyParticipants ( final CompilationUnit workingCopy ) { } protected IJavaModelStatus verify ( ) { } }
public class StopTomcat { static final String DEFAULT_CONFIG = "conf/server.xml" ; private static StringManager sm = StringManager . getManager ( "org.apache.tomcat.resources" ) ; String configFile ; String tomcatHome ; Log loghelper = new Log ( "tc_log" , "StopTomcat" ) ; public StopTomcat ( ) { } public void setConfig ( String s ) { } public void setF ( String s ) { } public void setH ( String s ) { } public void setHome ( String s ) { } public void execute ( ) throws Exception { } void stopTomcat ( ) throws TomcatException { } public void execute ( ContextManager cm ) throws TomcatException { int portInt = 8007 ; InetAddress address = null ; <START_BUG> BaseInterceptor [ ] ci = cm . getContextInterceptors ( ) ; <END_BUG> for ( int i = 0 ; i < ( ci . length ) ; i ++ ) { Object con = ci [ i ] ; if ( con instanceof Ajp12ConnectionHandler ) { PoolTcpConnector tcpCon = ( ( PoolTcpConnector ) ( con ) ) ; portInt = tcpCon . getPort ( ) ; address = tcpCon . getAddress ( ) ; } if ( con instanceof Ajp12Interceptor ) { Ajp12Interceptor tcpCon = ( ( Ajp12Interceptor ) ( con ) ) ; portInt = tcpCon . getPort ( ) ; address = tcpCon . getAddress ( ) ; } } try { if ( address == null ) address = InetAddress . getLocalHost ( ) ; Socket socket = new Socket ( address , portInt ) ; OutputStream os = socket . getOutputStream ( ) ; byte [ ] stopMessage = new byte [ 2 ] ; stopMessage [ 0 ] = ( ( byte ) ( 254 ) ) ; stopMessage [ 1 ] = ( ( byte ) ( 15 ) ) ; os . write ( stopMessage ) ; socket . close ( ) ; } catch ( Exception ex ) { throw new TomcatException ( ( ( ( "Error<seq2seq4repair_space>stopping<seq2seq4repair_space>Tomcat<seq2seq4repair_space>with<seq2seq4repair_space>Ajp12<seq2seq4repair_space>on<seq2seq4repair_space>" + address ) + ":" ) + portInt ) , ex ) ; } } }
final class RemoteServiceImpl implements IRemoteService { RemoteServiceReferenceImpl refImpl ; private Object service ; private long nextID ; public RemoteServiceImpl ( final RemoteServiceReferenceImpl refImpl , final Object service ) { } public void callAsynch ( final IRemoteCall call , final IRemoteCallListener listener ) { } public IFuture callAsynch ( final IRemoteCall call ) { <START_BUG> final FutureStatus result = new FutureStatus ( ) ; <END_BUG> final IRemoteCallListener listener = new IRemoteCallListener ( ) { public void handleEvent ( IRemoteCallEvent event ) { if ( event instanceof IRemoteCallCompleteEvent ) { IRemoteCallCompleteEvent cce = ( ( IRemoteCallCompleteEvent ) ( event ) ) ; if ( cce . hadException ( ) ) result . setException ( cce . getException ( ) ) ; else result . set ( cce . getResponse ( ) ) ; } } } ; callAsynch ( call , listener ) ; return result ; } public Object callSynch ( final IRemoteCall call ) throws ECFException { } public void fireAsynch ( final IRemoteCall call ) throws ECFException { } public Object getProxy ( ) throws ECFException { } synchronized long getNextID ( ) { } private class AsyncResult extends Thread implements IAsyncResult { Object result ; Throwable exception ; IRemoteCall call ; private IRemoteCallListener listener ; AsyncResult ( final IRemoteCall call , final IRemoteCallListener listener ) { } public synchronized void clear ( ) { } public Object get ( ) throws InterruptedException , InvocationTargetException { } public synchronized Object get ( final long msecs ) throws InterruptedException , InvocationTargetException { } public synchronized InvocationTargetException getException ( ) { } public synchronized boolean isReady ( ) { } public synchronized Object peek ( ) { } public void run ( ) { } } }
public class CodeSnippetScope extends BlockScope { protected CodeSnippetScope ( int kind , Scope parent ) { } public CodeSnippetScope ( BlockScope parent ) { } public CodeSnippetScope ( BlockScope parent , int variableCount ) { } public final boolean canBeSeenByForCodeSnippet ( FieldBinding fieldBinding , TypeBinding receiverType , InvocationSite invocationSite , Scope scope ) { } public final boolean canBeSeenByForCodeSnippet ( MethodBinding methodBinding , TypeBinding receiverType , InvocationSite invocationSite , Scope scope ) { } public final boolean canBeSeenByForCodeSnippet ( ReferenceBinding referenceBinding , ReferenceBinding receiverType ) { } public MethodBinding findExactMethod ( ReferenceBinding receiverType , char [ ] selector , TypeBinding [ ] argumentTypes , InvocationSite invocationSite ) { } public FieldBinding findFieldForCodeSnippet ( TypeBinding receiverType , char [ ] fieldName , InvocationSite invocationSite ) { if ( receiverType . isBaseType ( ) ) return null ; if ( receiverType . isArrayType ( ) ) { TypeBinding leafType = receiverType . leafComponentType ( ) ; if ( leafType instanceof ReferenceBinding ) if ( ! ( ( ( ReferenceBinding ) ( leafType ) ) . canBeSeenBy ( this ) ) ) { return new ProblemFieldBinding ( ( ( ReferenceBinding ) ( leafType ) ) , fieldName , ProblemReasons . ReceiverTypeNotVisible ) ; } if ( CharOperation . equals ( fieldName , LENGTH ) ) return ArrayBinding . ArrayLength ; return null ; } ReferenceBinding currentType = ( ( ReferenceBinding ) ( receiverType ) ) ; if ( ! ( currentType . canBeSeenBy ( this ) ) ) return new ProblemFieldBinding ( currentType , fieldName , ProblemReasons . ReceiverTypeNotVisible ) ; FieldBinding field = currentType . getField ( fieldName , true ) ; if ( field != null ) { if ( canBeSeenByForCodeSnippet ( field , currentType , invocationSite , this ) ) return field ; else return new ProblemFieldBinding ( field , field . declaringClass , fieldName , ProblemReasons . NotVisible ) ; } ReferenceBinding [ ] [ ] interfacesToVisit = null ; int lastPosition = - 1 ; FieldBinding visibleField = null ; boolean keepLooking = true ; boolean notVisible = false ; while ( keepLooking ) { ReferenceBinding [ ] itsInterfaces = currentType . superInterfaces ( ) ; if ( itsInterfaces != ( Binding . NO_SUPERINTERFACES ) ) { if ( interfacesToVisit == null ) interfacesToVisit = new ReferenceBinding [ 5 ] [ ] ; if ( ( ++ lastPosition ) == ( interfacesToVisit . length ) ) System . arraycopy ( interfacesToVisit , 0 , ( interfacesToVisit = new ReferenceBinding [ lastPosition * 2 ] [ ] ) , 0 , lastPosition ) ; interfacesToVisit [ lastPosition ] = itsInterfaces ; } if ( ( currentType = currentType . superclass ( ) ) == null ) break ; if ( ( field = currentType . getField ( fieldName , true ) ) != null ) { keepLooking = false ; if ( canBeSeenByForCodeSnippet ( field , receiverType , invocationSite , this ) ) { if ( visibleField == null ) visibleField = field ; else return new ProblemFieldBinding ( visibleField . declaringClass , fieldName , ProblemReasons . Ambiguous ) ; } else { notVisible = true ; } } } if ( interfacesToVisit != null ) { ProblemFieldBinding ambiguous = null ; <START_BUG> org . eclipse . jdt . internal . core . util . SimpleSet interfacesSeen = new org . eclipse . jdt . internal . core . util . SimpleSet ( ( lastPosition * 2 ) ) ; <END_BUG> done : for ( int i = 0 ; i <= lastPosition ; i ++ ) { ReferenceBinding [ ] interfaces = interfacesToVisit [ i ] ; for ( int j = 0 , length = interfaces . length ; j < length ; j ++ ) { ReferenceBinding anInterface = interfaces [ j ] ; if ( ! ( interfacesSeen . includes ( anInterface ) ) ) { interfacesSeen . add ( anInterface ) ; if ( ( field = anInterface . getField ( fieldName , true ) ) != null ) { if ( visibleField == null ) { visibleField = field ; } else { ambiguous = new ProblemFieldBinding ( visibleField . declaringClass , fieldName , ProblemReasons . Ambiguous ) ; break done ; } } else { ReferenceBinding [ ] itsInterfaces = anInterface . superInterfaces ( ) ; if ( itsInterfaces != ( Binding . NO_SUPERINTERFACES ) ) { if ( ( ++ lastPosition ) == ( interfacesToVisit . length ) ) System . arraycopy ( interfacesToVisit , 0 , ( interfacesToVisit = new ReferenceBinding [ lastPosition * 2 ] [ ] ) , 0 , lastPosition ) ; interfacesToVisit [ lastPosition ] = itsInterfaces ; } } } } } if ( ambiguous != null ) return ambiguous ; } if ( visibleField != null ) return visibleField ; if ( notVisible ) return new ProblemFieldBinding ( currentType , fieldName , ProblemReasons . NotVisible ) ; return null ; } public MethodBinding findMethod ( ReferenceBinding receiverType , char [ ] selector , TypeBinding [ ] argumentTypes , InvocationSite invocationSite ) { } public MethodBinding findMethodForArray ( ArrayBinding receiverType , char [ ] selector , TypeBinding [ ] argumentTypes , InvocationSite invocationSite ) { } public Binding getBinding ( char [ ] [ ] compoundName , int mask , InvocationSite invocationSite , ReferenceBinding receiverType ) { } public MethodBinding getConstructor ( ReferenceBinding receiverType , TypeBinding [ ] argumentTypes , InvocationSite invocationSite ) { } public FieldBinding getFieldForCodeSnippet ( TypeBinding receiverType , char [ ] fieldName , InvocationSite invocationSite ) { } public MethodBinding getImplicitMethod ( ReferenceBinding receiverType , char [ ] selector , TypeBinding [ ] argumentTypes , InvocationSite invocationSite ) { } }
public class HoldSampleSender extends AbstractSampleSender implements Serializable { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private static final long serialVersionUID = 240L ; private final List < SampleEvent > sampleStore = new ArrayList < SampleEvent > ( ) ; private final RemoteSampleListener listener ; @ Deprecated public HoldSampleSender ( ) { } HoldSampleSender ( RemoteSampleListener listener ) { } @ Override public void testEnded ( String host ) { } @ Override public void sampleOccurred ( SampleEvent e ) { } private Object readResolve ( ) throws ObjectStreamException { <START_BUG> HoldSampleSender . log . info ( "Using<seq2seq4repair_space>HoldSampleSender<seq2seq4repair_space>for<seq2seq4repair_space>this<seq2seq4repair_space>test<seq2seq4repair_space>run,<seq2seq4repair_space>ensure<seq2seq4repair_space>you<seq2seq4repair_space>have<seq2seq4repair_space>configured<seq2seq4repair_space>enough<seq2seq4repair_space>memory<seq2seq4repair_space>(-Xmx)<seq2seq4repair_space>for<seq2seq4repair_space>your<seq2seq4repair_space>test" ) ; <END_BUG> return this ; } }
public class ModuleEnvironment extends Environment { private final AModuleModules module ; public List < PDefinition > getDefinitions ( ) { } public ModuleEnvironment ( ITypeCheckerAssistantFactory af , AModuleModules module ) { } @ Override public String toString ( ) { } @ Override public PDefinition findName ( ILexNameToken name , NameScope scope ) { PDefinition def = af . createPDefinitionListAssistant ( ) . findName ( module . getDefs ( ) , name , scope ) ; <START_BUG> if ( def != null ) { <END_BUG> return def ; } def = af . createPDefinitionListAssistant ( ) . findName ( module . getImportdefs ( ) , name , scope ) ; if ( def != null ) { return def ; } return null ; } @ Override public PDefinition findType ( ILexNameToken name , String fromModule ) { } @ Override public Set < PDefinition > findMatches ( ILexNameToken name ) { } @ Override public void unusedCheck ( ) { } @ Override public AStateDefinition findStateDefinition ( ) { } @ Override public boolean isVDMPP ( ) { } @ Override public boolean isSystem ( ) { } @ Override public SClassDefinition findClassDefinition ( ) { } @ Override public boolean isStatic ( ) { } }
@ WebServlet ( "/DashBoard" ) public class DashBoard extends HttpServlet { private static final long serialVersionUID = 1L ; private ComputerService computerService ; private Page page ; public DashBoard ( ) { } protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { int offset = 10 ; <START_BUG> int index = 1 ; <END_BUG> String strIndex = request . getParameter ( "index" ) ; String strOffset = request . getParameter ( "offset" ) ; if ( Util . checkInt ( strIndex ) ) { index = Integer . parseInt ( strIndex ) ; } if ( Util . checkInt ( strOffset ) ) { offset = Integer . parseInt ( strOffset ) ; } String word = request . getParameter ( "search" ) ; if ( word == null ) { word = "" ; } page . setPage ( index , offset , word ) ; page . setComputersDTO ( MapperDTO . computersToDTO ( computerService . search ( word , ( index * offset ) , offset ) ) ) ; request . setAttribute ( "page" , page ) ; request . setAttribute ( "computersFound" , computerService . count ( word ) ) ; getServletContext ( ) . getRequestDispatcher ( "/views/dashboard.jsp" ) . forward ( request , response ) ; } protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { } }
public class CodeFormatterApplication implements IPlatformRunnable { private static final class Messages extends NLS { private static final String BUNDLE_NAME = "org.eclipse.jdt.core.formatter.messages" ; public static String CommandLineConfigFile ; public static String CommandLineDone ; public static String CommandLineErrorConfig ; public static String CommandLineErrorFile ; public static String CommandLineErrorFileDir ; public static String CommandLineErrorQuietVerbose ; public static String CommandLineErrorNoConfigFile ; public static String CommandLineFormatting ; public static String CommandLineStart ; public static String CommandLineUsage ; public static String ConfigFileReadingError ; public static String FormatProblem ; public static String CaughtException ; public static String ExceptionSkip ; public static String bind ( String message ) { } public static String bind ( String message , Object binding ) { } public static String bind ( String message , Object binding1 , Object binding2 ) { } public static String bind ( String message , Object [ ] bindings ) { } } private final String ARG_CONFIG = "-config" ; private final String ARG_HELP = "-help" ; private final String ARG_QUIET = "-quiet" ; private final String ARG_VERBOSE = "-verbose" ; private String configName ; private Properties options = null ; private final String PDE_LAUNCH = "-pdelaunch" ; private boolean quiet = false ; private boolean verbose = false ; private void displayHelp ( ) { } private void displayHelp ( String message ) { } private void formatDirTree ( File dir , CodeFormatter codeFormatter ) { } private void formatFile ( File file , CodeFormatter codeFormatter ) { } private File [ ] processCommandLine ( String [ ] argsArray ) { ArrayList args = new ArrayList ( ) ; for ( int i = 0 ; i < ( argsArray . length ) ; i ++ ) { args . add ( argsArray [ i ] ) ; } int index = 0 ; final int argCount = argsArray . length ; final int DEFAULT_MODE = 0 ; final int CONFIG_MODE = 1 ; int mode = DEFAULT_MODE ; final int INITIAL_SIZE = 1 ; int fileCounter = 0 ; File [ ] filesToFormat = new File [ INITIAL_SIZE ] ; loop : while ( index < argCount ) { String currentArg = argsArray [ ( index ++ ) ] ; switch ( mode ) { case DEFAULT_MODE : if ( PDE_LAUNCH . equals ( currentArg ) ) { continue loop ; } if ( ARG_HELP . equals ( currentArg ) ) { displayHelp ( ) ; return null ; } if ( ARG_VERBOSE . equals ( currentArg ) ) { this . verbose = true ; continue loop ; } if ( ARG_QUIET . equals ( currentArg ) ) { this . quiet = true ; continue loop ; } if ( ARG_CONFIG . equals ( currentArg ) ) { mode = CONFIG_MODE ; continue loop ; } File file = new File ( currentArg ) ; if ( file . exists ( ) ) { if ( ( filesToFormat . length ) == fileCounter ) { System . arraycopy ( filesToFormat , 0 , ( filesToFormat = new File [ fileCounter * 2 ] ) , 0 , fileCounter ) ; } filesToFormat [ ( fileCounter ++ ) ] = file ; } else { displayHelp ( CodeFormatterApplication . Messages . bind ( CodeFormatterApplication . Messages . CommandLineErrorFile , currentArg ) ) ; return null ; } break ; case CONFIG_MODE : this . configName = currentArg ; this . options = readConfig ( currentArg ) ; if ( ( this . options ) == null ) { displayHelp ( CodeFormatterApplication . Messages . bind ( CodeFormatterApplication . Messages . CommandLineErrorConfig , currentArg ) ) ; return null ; } mode = DEFAULT_MODE ; continue loop ; } } <START_BUG> if ( mode == CONFIG_MODE ) { <END_BUG> displayHelp ( CodeFormatterApplication . Messages . bind ( CodeFormatterApplication . Messages . CommandLineErrorNoConfigFile ) ) ; return null ; } if ( ( this . quiet ) && ( this . verbose ) ) { displayHelp ( CodeFormatterApplication . Messages . bind ( CodeFormatterApplication . Messages . CommandLineErrorQuietVerbose , new String [ ] { ARG_QUIET , ARG_VERBOSE } ) ) ; return null ; } if ( fileCounter == 0 ) { displayHelp ( CodeFormatterApplication . Messages . bind ( CodeFormatterApplication . Messages . CommandLineErrorFileDir ) ) ; return null ; } if ( ( filesToFormat . length ) != fileCounter ) { System . arraycopy ( filesToFormat , 0 , ( filesToFormat = new File [ fileCounter ] ) , 0 , fileCounter ) ; } return filesToFormat ; } private Properties readConfig ( String filename ) { } public Object run ( Object args ) throws Exception { } }
public class MainActivity extends Activity { private Button createWorkoutButton ; private Button addFoodItemButton ; private Button viewWorkoutHistoryButton ; private LinearLayout root ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( activity_main ) ; setRequestedOrientation ( SCREEN_ORIENTATION_PORTRAIT ) ; SharedPreferences settings = getSharedPreferences ( "user_settings" , 0 ) ; TextView greeting = ( ( TextView ) ( findViewById ( userGreeting ) ) ) ; <START_BUG> greeting . setText ( settings . getString ( "greeting" , "Hello,<seq2seq4repair_space>user" ) ) ; <END_BUG> } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } public void onViewWorkoutHistoryClick ( View v ) { } public void onViewFoodHistoryClick ( View v ) { } public void onCreateWorkoutClick ( View v ) { } public void onAddFoodClick ( View v ) { } public void onViewProfileClick ( View v ) { } private void goToWorkoutActivity ( Class < ? > activity ) { } }
@ SuppressWarnings ( "restriction" ) public class RootLayoutController { private static final String COMMAND_DELETE = "delete" ; private static final String COMMAND_DELETE_SHORTHAND = "del" ; private static final String COMMAND_SEARCH = "search" ; private static final String WHITESPACE = "<seq2seq4repair_space>" ; private static final String EMPTY_STRING = "" ; private static final String MESSAGE_LABEL_MODE_EDIT = "Edit<seq2seq4repair_space>mode" ; private static final String MESSAGE_LISTVIEW_EMPTY = "You<seq2seq4repair_space>have<seq2seq4repair_space>no<seq2seq4repair_space>task!" ; private static final String MESSAGE_FEEDBACK_ACTION_ADD = "Adding:" ; private static final String MESSAGE_FEEDBACK_ACTION_DELETE = "Deleting:" ; private static final String MESSAGE_FEEDBACK_TOTAL_TASK = "(%1$s<seq2seq4repair_space>tasks)" ; private static final String MESSAGE_FEEDBACK_ACTION_SEARCH = "Searching:" ; private static final String MESSAGE_ERROR_RESULT_DELETE = "Task<seq2seq4repair_space>-%1$s-<seq2seq4repair_space>not<seq2seq4repair_space>found." ; private static final KeyCombination HOTKEY_CTRL_TAB = new KeyCodeCombination ( KeyCode . TAB , KeyCombination . CONTROL_DOWN ) ; @ FXML private AnchorPane rootLayout ; @ FXML private TabPane tabPane ; @ FXML private Tab tabAll ; @ FXML private Tab tabToday ; @ FXML private Tab tabWeek ; @ FXML private JFXListView < String > listView ; @ FXML private TextField commandBar ; @ FXML private Label labelCurrentMode ; @ FXML private Label labelUserAction ; @ FXML private Label labelUserFeedback ; @ FXML private Label labelResult ; @ FXML private Button btnDel ; @ FXML private Button btnEdit ; @ FXML private Group groupUndoRedo ; @ FXML private Label labelUndoRedo ; @ FXML private Button btnUndoRedo ; private VirtualFlow < IndexedCell < String > > virtualFlow ; private IndexedCell < String > firstVisibleIndexedCell ; private IndexedCell < String > lastVisibleIndexedCell ; private Controller controller ; private ArrayList < Task > allTasks ; private ListProperty < String > listProperty ; private ObservableList < String > observableTaskList = FXCollections . observableArrayList ( ) ; private String inputFeedback ; private String userInput ; private String [ ] userInputArray ; private String userCommand ; private String userArguments ; private int previousSelectedTaskIndex ; private int previousCaretPosition ; private boolean isEditMode ; private boolean isExecuteCommand ; private boolean isUndo ; private boolean isRedo ; private boolean isUserRevertAction ; public void requestFocusForCommandBar ( ) { } public void selectFirstItemFromListView ( ) { } @ FXML private void initialize ( ) { } private void initTabSelectionListener ( ) { } private void initMouseListener ( ) { } private void initCommandBarListener ( ) { } private void initKeyboardListener ( ) { } private void populateListView ( ) { } private void refreshListView ( ) { } private void handleArrowKeys ( KeyEvent keyEvent ) { } @ SuppressWarnings ( "unchecked" ) private void initCustomViewportBehaviorForListView ( ) { } private void adjustViewportForListView ( ) { } private void handleFOneKey ( ) { } private void handleFTwoKey ( ) { } private void handleKeyStrokes ( ) { } private void handleEnterKey ( ) { } private void showUndoRedoButton ( ) { } private void handleDeleteKey ( ) { <START_BUG> controller . parseCommand ( ( ( ( RootLayoutController . COMMAND_DELETE ) + ( RootLayoutController . WHITESPACE ) ) + ( getSelectedTaskIndex ( ) ) ) , FLOATING_TAB ) ; <END_BUG> controller . executeCommand ( ) ; saveSelectedTaskIndex ( ) ; refreshListView ( ) ; restoreListViewPreviousSelection ( ) ; showUndoRedoButton ( ) ; } private void handleCtrlTab ( ) { } private void extractUserInput ( ) { } private void parseUserInput ( ) { } private void parseAdd ( ) { } private void parseDeleteImproved ( ) { } private void parseDelete ( ) { } private void parseSearch ( ) { } private void clearStoredUserInput ( ) { } private void clearFeedback ( ) { } private void showFeedback ( boolean isVisible ) { } private void showFeedback ( boolean isVisible , String userAction , String userFeedback ) { } private void showResult ( boolean isVisible , String resultString ) { } private void saveSelectedTaskIndex ( ) { } private void restoreListViewPreviousSelection ( ) { } private int getSelectedTaskIndex ( ) { } private String getSelectedTabName ( ) { } private void saveCaretPosition ( ) { } private void restoreCaretPosition ( ) { } private void moveCaretPositionToLast ( ) { } private int getCaretCurrentPosition ( ) { } public ArrayList < Task > getTaskList ( ) { } }
public class DRPCSpout implements IRichSpout { public static Logger LOG = Logger . getLogger ( DRPCSpout . class ) ; SpoutOutputCollector _collector ; List < DRPCClient > _clients = new ArrayList < DRPCClient > ( ) ; String _function ; String _local_drpc_id = null ; private static class DRPCMessageId { String id ; int index ; public DRPCMessageId ( String id , int index ) { } } public DRPCSpout ( String function ) { } public DRPCSpout ( String function , ILocalDRPC drpc ) { } @ Override public boolean isDistributed ( ) { } @ Override public void open ( Map conf , TopologyContext context , SpoutOutputCollector collector ) { _collector = collector ; if ( ( _local_drpc_id ) == null ) { int numTasks = context . getComponentTasks ( context . getThisComponentId ( ) ) . size ( ) ; int index = context . getThisTaskIndex ( ) ; <START_BUG> int port = ( ( Long ) ( conf . get ( DRPC_PORT ) ) ) . intValue ( ) ; <END_BUG> List < String > servers = ( ( List < String > ) ( conf . get ( DRPC_SERVERS ) ) ) ; if ( servers . isEmpty ( ) ) { throw new RuntimeException ( "No<seq2seq4repair_space>DRPC<seq2seq4repair_space>servers<seq2seq4repair_space>configured<seq2seq4repair_space>for<seq2seq4repair_space>topology" ) ; } if ( numTasks < ( servers . size ( ) ) ) { for ( String s : servers ) { _clients . add ( new DRPCClient ( s , port ) ) ; } } else { int i = index % ( servers . size ( ) ) ; _clients . add ( new DRPCClient ( servers . get ( i ) , port ) ) ; } } } @ Override public void close ( ) { } @ Override public void nextTuple ( ) { } @ Override public void ack ( Object msgId ) { } @ Override public void fail ( Object msgId ) { } @ Override public void declareOutputFields ( OutputFieldsDeclarer declarer ) { } }
public class HttpMirrorServer extends Thread implements Stoppable { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private static final int ACCEPT_TIMEOUT = 1000 ; private final int daemonPort ; private volatile boolean running ; private volatile Exception except ; public HttpMirrorServer ( int port ) { } @ Override public void run ( ) { } public void stopServer ( ) { } public Exception getException ( ) { } public static void main ( String [ ] args ) { <START_BUG> int port = 8080 ; <END_BUG> if ( ( args . length ) > 0 ) { port = Integer . parseInt ( args [ 0 ] ) ; } LoggingManager . setPriority ( "INFO" ) ; LoggingManager . setLoggingLevels ( System . getProperties ( ) ) ; HttpMirrorServer serv = new HttpMirrorServer ( port ) ; serv . start ( ) ; } }
public class ScreenManager { private int mRootContainerId ; private Bus mNavigationBus ; private FragmentManager mFragmentManager ; public ScreenManager ( Bus navigationBus , FragmentManager fragmentManager , int rootContainerId ) { } @ Subscribe public void handleScreenDisplayEvent ( ScreenDisplayEvent screenDisplayEvent ) { } private void displayScreen ( ScreenFactory screenFactory ) { <START_BUG> mFragmentManager . beginTransaction ( ) . replace ( mRootContainerId , ( ( Fragment ) ( screenFactory . getScreen ( ) ) ) ) . addToBackStack ( null ) . commit ( ) ; <END_BUG> } public void onStart ( ) { } public void onStop ( ) { } }
public class ChatMessageXMLAdapter { Document documentRepresentation ; Element messageRootElement ; Color messageColor ; String encryptedColor ; ChatSession session ; byte [ ] aesEncryptionKey ; int caesarKey ; public ChatMessageXMLAdapter ( ChatSession session ) { } public String chatMessageToXML ( ChatMessage chatMessage ) { } public String rgbToHex ( Color color ) { } public void getDocumentFromXML ( String XML ) { } public String getMessageType ( ) { } public String getMessageSender ( ) { } public String getRequestReply ( ) { } public String getKeyRequestType ( ) { } public String getFileRequestFileName ( ) { <START_BUG> return messageRootElement . getAttribute ( "filename" ) ; <END_BUG> } public String getFileRequestFileSize ( ) { } public int getFileResponsePort ( ) { } public String getMessageContents ( ) { } public String getRequestMessage ( ) { } public String decryptString ( String encryptedString , String encryptionType ) { } public String textScanner ( String textXML ) { } public ChatMessage xmlToChatMessage ( ) { } public ChatMessage xmlToChatMessage ( String XML , ChatConnection parentConnection ) { } }
public class Field implements IndexableField { protected final FieldType type ; protected final String name ; protected Object fieldsData ; protected TokenStream tokenStream ; private transient TokenStream internalTokenStream ; private transient Field . ReusableStringReader internalReader ; protected float boost = 1.0F ; protected Field ( String name , FieldType type ) { } public Field ( String name , Reader reader , FieldType type ) { } public Field ( String name , TokenStream tokenStream , FieldType type ) { } public Field ( String name , byte [ ] value , FieldType type ) { } public Field ( String name , byte [ ] value , int offset , int length , FieldType type ) { } public Field ( String name , BytesRef bytes , FieldType type ) { } public Field ( String name , String value , FieldType type ) { } @ Override public String stringValue ( ) { } @ Override public Reader readerValue ( ) { } public TokenStream tokenStreamValue ( ) { } public void setStringValue ( String value ) { } public void setReaderValue ( Reader value ) { } public void setBytesValue ( byte [ ] value ) { } public void setBytesValue ( BytesRef value ) { if ( ! ( ( fieldsData ) instanceof BytesRef ) ) { throw new IllegalArgumentException ( ( ( "cannot<seq2seq4repair_space>change<seq2seq4repair_space>value<seq2seq4repair_space>type<seq2seq4repair_space>from<seq2seq4repair_space>" + ( fieldsData . getClass ( ) . getSimpleName ( ) ) ) + "<seq2seq4repair_space>to<seq2seq4repair_space>BytesRef" ) ) ; } if ( type . indexed ( ) ) { <START_BUG> throw new IllegalArgumentException ( "cannot<seq2seq4repair_space>set<seq2seq4repair_space>a<seq2seq4repair_space>Reader<seq2seq4repair_space>value<seq2seq4repair_space>on<seq2seq4repair_space>an<seq2seq4repair_space>indexed<seq2seq4repair_space>field" ) ; <END_BUG> } fieldsData = value ; } public void setByteValue ( byte value ) { } public void setShortValue ( short value ) { } public void setIntValue ( int value ) { } public void setLongValue ( long value ) { } public void setFloatValue ( float value ) { } public void setDoubleValue ( double value ) { } public void setTokenStream ( TokenStream tokenStream ) { } @ Override public String name ( ) { } @ Override public float boost ( ) { } public void setBoost ( float boost ) { } @ Override public Number numericValue ( ) { } @ Override public BytesRef binaryValue ( ) { } @ Override public String toString ( ) { } @ Override public FieldType fieldType ( ) { } @ Override public TokenStream tokenStream ( Analyzer analyzer ) throws IOException { } static final class ReusableStringReader extends Reader { private int pos = 0 ; private int size = 0 ; private String s = null ; void setValue ( String s ) { } @ Override public int read ( ) { } @ Override public int read ( char [ ] c , int off , int len ) { } @ Override public void close ( ) { } } static final class StringTokenStream extends TokenStream { private final CharTermAttribute termAttribute = addAttribute ( CharTermAttribute . class ) ; private final OffsetAttribute offsetAttribute = addAttribute ( OffsetAttribute . class ) ; private boolean used = false ; private String value = null ; StringTokenStream ( ) { } void setValue ( String value ) { } @ Override public boolean incrementToken ( ) { } @ Override public void end ( ) { } @ Override public void reset ( ) { } @ Override public void close ( ) { } } public static enum Store { YES , NO ; } @ Deprecated public static enum Index { NO ( ) { @ Override public boolean isIndexed ( ) { } @ Override public boolean isAnalyzed ( ) { } @ Override public boolean omitNorms ( ) { } } , ANALYZED ( ) { @ Override public boolean isIndexed ( ) { } @ Override public boolean isAnalyzed ( ) { } @ Override public boolean omitNorms ( ) { } } , NOT_ANALYZED ( ) { @ Override public boolean isIndexed ( ) { } @ Override public boolean isAnalyzed ( ) { } @ Override public boolean omitNorms ( ) { } } , NOT_ANALYZED_NO_NORMS ( ) { @ Override public boolean isIndexed ( ) { } @ Override public boolean isAnalyzed ( ) { } @ Override public boolean omitNorms ( ) { } } , ANALYZED_NO_NORMS ( ) { @ Override public boolean isIndexed ( ) { } @ Override public boolean isAnalyzed ( ) { } @ Override public boolean omitNorms ( ) { } } ; public static Field . Index toIndex ( boolean indexed , boolean analyzed ) { } public static Field . Index toIndex ( boolean indexed , boolean analyzed , boolean omitNorms ) { } public abstract boolean isIndexed ( ) { } public abstract boolean isAnalyzed ( ) { } public abstract boolean omitNorms ( ) { } } @ Deprecated public static enum TermVector { NO ( ) { @ Override public boolean isStored ( ) { } @ Override public boolean withPositions ( ) { } @ Override public boolean withOffsets ( ) { } } , YES ( ) { @ Override public boolean isStored ( ) { } @ Override public boolean withPositions ( ) { } @ Override public boolean withOffsets ( ) { } } , WITH_POSITIONS ( ) { @ Override public boolean isStored ( ) { } @ Override public boolean withPositions ( ) { } @ Override public boolean withOffsets ( ) { } } , WITH_OFFSETS ( ) { @ Override public boolean isStored ( ) { } @ Override public boolean withPositions ( ) { } @ Override public boolean withOffsets ( ) { } } , WITH_POSITIONS_OFFSETS ( ) { @ Override public boolean isStored ( ) { } @ Override public boolean withPositions ( ) { } @ Override public boolean withOffsets ( ) { } } ;
public abstract class DirectSearchOptimizer { protected DirectSearchOptimizer ( ) { } public PointCostPair minimize ( CostFunction f , int maxEvaluations , ConvergenceChecker checker , double [ ] vertexA , double [ ] vertexB ) throws ConvergenceException , CostException { } public PointCostPair minimize ( CostFunction f , int maxEvaluations , ConvergenceChecker checker , double [ ] vertexA , double [ ] vertexB , int starts , long seed ) throws ConvergenceException , CostException { } public PointCostPair minimize ( CostFunction f , int maxEvaluations , ConvergenceChecker checker , double [ ] [ ] vertices ) throws ConvergenceException , CostException { } public PointCostPair minimize ( CostFunction f , int maxEvaluations , ConvergenceChecker checker , double [ ] [ ] vertices , int starts , long seed ) throws ConvergenceException , CostException , NotPositiveDefiniteMatrixException { try { buildSimplex ( vertices ) ; VectorialMean meanStat = new VectorialMean ( vertices [ 0 ] . length ) ; VectorialCovariance covStat = new VectorialCovariance ( vertices [ 0 ] . length , true ) ; for ( int i = 0 ; i < ( vertices . length ) ; ++ i ) { meanStat . increment ( vertices [ i ] ) ; covStat . increment ( vertices [ i ] ) ; } double [ ] mean = meanStat . getResult ( ) ; RealMatrix covariance = covStat . getResult ( ) ; RandomGenerator rg = new JDKRandomGenerator ( ) ; rg . setSeed ( seed ) ; RandomVectorGenerator rvg = new org . apache . commons . math . random . CorrelatedRandomVectorGenerator ( mean , covariance , ( 1.0E-12 * ( covariance . getNorm ( ) ) ) , new org . apache . commons . math . random . UniformRandomGenerator ( rg ) ) ; setMultiStart ( starts , rvg ) ; return minimize ( f , maxEvaluations , checker ) ; } catch ( DimensionMismatchException dme ) { <START_BUG> throw new org . apache . commons . math . MathRuntimeException ( "unexpected<seq2seq4repair_space>exception<seq2seq4repair_space>caught" , new Object [ 0 ] , dme ) ; <END_BUG> } } public PointCostPair minimize ( CostFunction f , int maxEvaluations , ConvergenceChecker checker , RandomVectorGenerator generator ) throws ConvergenceException , CostException { } public PointCostPair minimize ( CostFunction f , int maxEvaluations , ConvergenceChecker checker , RandomVectorGenerator generator , int starts ) throws ConvergenceException , CostException { } private void buildSimplex ( double [ ] vertexA , double [ ] vertexB ) { } private void buildSimplex ( double [ ] [ ] vertices ) { } private void buildSimplex ( RandomVectorGenerator generator ) { } private void setSingleStart ( ) { } private void setMultiStart ( int starts , RandomVectorGenerator generator ) { } public PointCostPair [ ] getMinima ( ) { } private PointCostPair minimize ( CostFunction f , int maxEvaluations , ConvergenceChecker checker ) throws ConvergenceException , CostException { } protected abstract void iterateSimplex ( ) throws CostException { } protected double evaluateCost ( double [ ] x ) throws CostException { } protected void evaluateSimplex ( ) throws CostException { } protected void replaceWorstPoint ( PointCostPair pointCostPair ) { } private static Comparator < PointCostPair > pointCostPairComparator = new Comparator < PointCostPair > ( ) { public int compare ( PointCostPair o1 , PointCostPair o2 ) { } } ; protected PointCostPair [ ] simplex ; private CostFunction f ; private int evaluations ; private int starts ; private RandomVectorGenerator generator ; private PointCostPair [ ] minima ; }
public final class GamePanel extends ChessPanel { private final Game mGame ; private final SquareConfig mSquareConfig ; private final BoardPanel [ ] mGameBoards ; private final List < TeamStatusPanel > mTeamStatusPanels ; private final JTabbedPane mTabbedPane ; private final JButton mUndoButton ; private final JButton mForwardButton ; private final JButton mBackButton ; public GamePanel ( @ NotNull GlassPane glassPane , @ NotNull Game game ) { } private void initComponents ( ) { setLayout ( new BoxLayout ( this , BoxLayout . LINE_AXIS ) ) ; Board [ ] boards = mGame . getBoards ( ) ; JPanel boardPanels = new JPanel ( ) ; boardPanels . setOpaque ( false ) ; boardPanels . setLayout ( new BoxLayout ( boardPanels , BoxLayout . LINE_AXIS ) ) ; boardPanels . addComponentListener ( new ComponentListener ( ) { @ Override public void componentResized ( ComponentEvent e ) { Stream . of ( mGameBoards ) . forEach ( ( board ) -> board . updateDimensions ( e . getComponent ( ) . getWidth ( ) , e . getComponent ( ) . getHeight ( ) ) ) ; } @ Override public void componentMoved ( ComponentEvent e ) { } @ Override public void componentShown ( ComponentEvent e ) { } @ Override public void componentHidden ( ComponentEvent e ) { } } ) ; IntStream . range ( 0 , boards . length ) . forEach ( ( boardIndex ) -> { mGameBoards [ boardIndex ] = new BoardPanel ( boards [ boardIndex ] . getBoardSize ( ) , mSquareConfig , ( coordinate ) -> { Piece piece = mGame . getPiece ( boardIndex , coordinate ) ; if ( ( piece != null ) && ( ( piece . getTeamId ( ) ) == ( mGame . getTurnKeeper ( ) . getActiveTeamId ( ) ) ) ) { return mGame . getMovesFrom ( boardIndex , coordinate ) ; } else { return Collections . emptySet ( ) ; } } ) ; boardPanels . add ( mGameBoards [ boardIndex ] ) ; } ) ; Stream . of ( mGame . getTeams ( ) ) . forEach ( ( team ) -> mTeamStatusPanels . add ( new TeamStatusPanel ( team ) ) ) ; mTeamStatusPanels . forEach ( ( panel ) -> mTabbedPane . addTab ( panel . getName ( ) , panel ) ) ; mUndoButton . addActionListener ( ( event ) -> { mGame . undoMove ( ) ; refresh ( ) ; } ) ; mForwardButton . addActionListener ( ( event ) -> { mGame . nextMove ( ) ; refresh ( ) ; } ) ; mBackButton . addActionListener ( ( event ) -> { mGame . previousMove ( ) ; refresh ( ) ; } ) ; GridBagConstraints gbc = new GridBagConstraints ( ) ; JPanel detailsPanel = new JPanel ( ) ; detailsPanel . setLayout ( new GridBagLayout ( ) ) ; detailsPanel . setOpaque ( false ) ; gbc . gridwidth = 2 ; gbc . weightx = 1.0 ; gbc . fill = GridBagConstraints . BOTH ; gbc . weighty = 1.0 ; gbc . insets = new Insets ( 0 , 10 , 10 , 10 ) ; detailsPanel . add ( mTabbedPane , gbc ) ; gbc . gridy = 1 ; gbc . gridx = 0 ; gbc . gridwidth = 2 ; gbc . weighty = 0.0 ; detailsPanel . add ( mUndoButton , gbc ) ; gbc . gridy = 2 ; gbc . gridx = 0 ; gbc . gridwidth = 1 ; detailsPanel . add ( mBackButton , gbc ) ; gbc . gridx = 1 ; detailsPanel . add ( mForwardButton , gbc ) ; JSplitPane splitPane = new JSplitPane ( JSplitPane . HORIZONTAL_SPLIT , boardPanels , detailsPanel ) ; splitPane . setPreferredSize ( new Dimension ( 755 , 475 ) ) ; <START_BUG> splitPane . setDividerLocation ( 350 ) ; <END_BUG> splitPane . setOpaque ( false ) ; splitPane . setDividerSize ( 1 ) ; splitPane . setResizeWeight ( 0.55 ) ; splitPane . setEnabled ( false ) ; add ( splitPane ) ; refresh ( ) ; } public void declareDraw ( ) { } public void endOfGame ( ) { } public void saveGame ( ) { } private void playMove ( MoveBuilder moveBuilder ) { } private void createPromotionPopup ( MoveBuilder moveBuilder ) { } private void refresh ( ) { } private void refreshStatus ( ) { } private void refreshBoard ( ) { } private void refreshNavigationButtonState ( ) { } }
public class ObjectGestureListener extends Listener { private IObject obj ; private boolean isResizing = false ; private boolean isRotating = false ; private boolean unbindRequest = false ; private double initialSpaceX = 0 ; private double initialSpaceY = 0 ; private double initialRotation = 0 ; private static final long TAP_TIMEOUT = 200 ; private static final long ALIGNMENT_THRESHOLD = 30 ; private final long lastTap = Long . MIN_VALUE ; public ObjectGestureListener ( ) { } @ Override public void onConnect ( Controller controller ) { } @ Override public void onFrame ( Controller controller ) { final Frame frame = controller . frame ( ) ; final HandList hands = frame . hands ( ) ; final GestureList gestures = frame . gestures ( ) ; resizeObject ( hands ) ; rotateObject ( hands ) ; Platform . runLater ( new Runnable ( ) { @ Override public void run ( ) { if ( ! ( gestures . isEmpty ( ) ) ) { for ( int i = 0 ; i < ( gestures . count ( ) ) ; i ++ ) { switch ( gestures . get ( i ) . type ( ) ) { case TYPE_CIRCLE : CircleGesture circle = new CircleGesture ( gestures . get ( i ) ) ; if ( ( circle . pointable ( ) . direction ( ) . angleTo ( circle . normal ( ) ) ) <= ( ( Math . PI ) / 2 ) ) { } else { <START_BUG> if ( ( ( obj ) != null ) && ( ( circle . durationSeconds ( ) ) >= 0.5 ) ) { <END_BUG> obj . onCounterCircle ( ) ; } } break ; case TYPE_SCREEN_TAP : ScreenTapGesture tap = new ScreenTapGesture ( gestures . get ( i ) ) ; if ( ( ( ( obj ) != null ) && ( tap . state ( ) . equals ( STATE_STOP ) ) ) && ( ( lastTap ) < ( ( System . currentTimeMillis ( ) ) - ( ObjectGestureListener . TAP_TIMEOUT ) ) ) ) { obj . onScreenTap ( ) ; } break ; case TYPE_SWIPE : break ; case TYPE_KEY_TAP : break ; case TYPE_INVALID : break ; default : break ; } } } } } ) ; } private void resizeObject ( HandList hands ) { } private void rotateObject ( HandList hands ) { } public void setIObject ( IObject obj ) { } }
private static RefType IBINDER_TYPE = RefType . v ( "android.os.IBinder" ) ; private Map < String , SootMethod > source2RedirectMethod = new HashMap < String , SootMethod > ( ) ; private Map < String , SootClass > destination2sootClass = new HashMap < String , SootClass > ( ) ; private static ICCRedirectionCreator s = null ; private ICCRedirectionCreator ( ) { } public static ICCRedirectionCreator v ( String pkg ) { } public static ICCRedirectionCreator v ( ) { } public void redirectToDestination ( ICCLink link ) { } public SootMethod getRedirectMethod ( ICCLink link ) { } public SootMethod generateRedirectMethodForStartActivityForResult ( SootClass originActivity , SootClass destComp ) { } public SootMethod generateRedirectMethod ( SootClass wrapper ) { } public SootMethod generateRedirectMethodForStartActivity ( SootClass wrapper ) { } public SootMethod generateRedirectMethodForBindService ( SootClass serviceConnection , SootClass destComp ) { String newSM_name = "redirector" + ( ( ICCRedirectionCreator . num ) ++ ) ; List < Type > newSM_parameters = new ArrayList < Type > ( ) ; newSM_parameters . add ( serviceConnection . getType ( ) ) ; newSM_parameters . add ( ICCRedirectionCreator . INTENT_TYPE ) ; Type newSM_return_type = VoidType . v ( ) ; int modifiers = ( Modifier . STATIC ) | ( Modifier . PUBLIC ) ; SootMethod newSM = new SootMethod ( newSM_name , newSM_parameters , newSM_return_type , modifiers ) ; ICCRedirectionCreator . ipcSC . addMethod ( newSM ) ; JimpleBody b = Jimple . v ( ) . newBody ( newSM ) ; newSM . setActiveBody ( b ) ; LocalGenerator lg = new LocalGenerator ( b ) ; Local originActivityParameterLocal = lg . generateLocal ( serviceConnection . getType ( ) ) ; Unit originActivityParameterU = Jimple . v ( ) . newIdentityStmt ( originActivityParameterLocal , Jimple . v ( ) . newParameterRef ( serviceConnection . getType ( ) , 0 ) ) ; Local intentParameterLocal = lg . generateLocal ( ICCRedirectionCreator . INTENT_TYPE ) ; Unit intentParameterU = Jimple . v ( ) . newIdentityStmt ( intentParameterLocal , Jimple . v ( ) . newParameterRef ( ICCRedirectionCreator . INTENT_TYPE , 1 ) ) ; Local destCompLocal = lg . generateLocal ( destComp . getType ( ) ) ; Unit newU = ( ( Unit ) ( Jimple . v ( ) . newAssignStmt ( destCompLocal , Jimple . v ( ) . newNewExpr ( destComp . getType ( ) ) ) ) ) ; List < Type > parameters = new ArrayList < Type > ( ) ; parameters . add ( ICCRedirectionCreator . INTENT_TYPE ) ; SootMethod method = destComp . getMethod ( "<init>" , parameters , VoidType . v ( ) ) ; List < Value > args = new ArrayList < Value > ( ) ; args . add ( intentParameterLocal ) ; Unit initU = ( ( Unit ) ( Jimple . v ( ) . newInvokeStmt ( Jimple . v ( ) . newSpecialInvokeExpr ( destCompLocal , method . makeRef ( ) , args ) ) ) ) ; List < SootMethod > sms = destComp . getMethods ( ) ; for ( SootMethod sm : sms ) { System . out . println ( sm ) ; } method = destComp . getMethodByName ( DUMMY_MAIN_METHOD ) ; InvokeExpr invoke = Jimple . v ( ) . newVirtualInvokeExpr ( destCompLocal , method . makeRef ( ) ) ; Unit callU = ( ( Unit ) ( Jimple . v ( ) . newInvokeStmt ( invoke ) ) ) ; method = destComp . getMethodByName ( "getIBinderForIpc" ) ; Type binderType = method . getReturnType ( ) ; Local ibinderLocal = lg . generateLocal ( binderType ) ; Unit nullarIntentLocalParamU = ( ( Unit ) ( Jimple . v ( ) . newAssignStmt ( ibinderLocal , NullConstant . v ( ) ) ) ) ; invoke = Jimple . v ( ) . newVirtualInvokeExpr ( destCompLocal , method . makeRef ( ) ) ; Unit destCompCallU = ( ( Unit ) ( Jimple . v ( ) . newAssignStmt ( ibinderLocal , invoke ) ) ) ; method = serviceConnection . getMethodByName ( "onServiceConnected" ) ; changeParameterType ( method , ICCRedirectionCreator . IBINDER_TYPE , binderType ) ; <START_BUG> Local iLocal1 = lg . generateLocal ( NullType . v ( ) ) ; <END_BUG> Unit defaultValueParamU1 = ( ( Unit ) ( Jimple . v ( ) . newAssignStmt ( iLocal1 , NullConstant . v ( ) ) ) ) ; args = new ArrayList < Value > ( ) ; args . add ( iLocal1 ) ; args . add ( ibinderLocal ) ; invoke = Jimple . v ( ) . newVirtualInvokeExpr ( originActivityParameterLocal , method . makeRef ( ) , args ) ; Unit onActivityResultCall = ( ( Unit ) ( Jimple . v ( ) . newInvokeStmt ( invoke ) ) ) ; b . getUnits ( ) . add ( originActivityParameterU ) ; b . getUnits ( ) . add ( intentParameterU ) ; b . getUnits ( ) . add ( newU ) ; b . getUnits ( ) . add ( initU ) ; b . getUnits ( ) . add ( callU ) ; b . getUnits ( ) . add ( nullarIntentLocalParamU ) ; b . getUnits ( ) . add ( destCompCallU ) ; b . getUnits ( ) . add ( defaultValueParamU1 ) ; b . getUnits ( ) . add ( onActivityResultCall ) ; b . getUnits ( ) . add ( Jimple . v ( ) . newReturnVoidStmt ( ) ) ; System . out . println ( ( ( ( "new<seq2seq4repair_space>lifecypcle<seq2seq4repair_space>method:<seq2seq4repair_space>" + newSM ) + "<seq2seq4repair_space>body:<seq2seq4repair_space>" ) + ( newSM . retrieveActiveBody ( ) ) ) ) ; return newSM ; } public void changeParameterType ( SootMethod sm , Type originalType , Type newType ) { } public SootMethod generateFakeOnActivityResult ( SootClass sootClass ) { } public SootMethod generateRedirectMethodForContentProvider ( Stmt iccStmt , SootClass destProvider ) { } }
public class HostControllerBootstrap { private static final Logger log = Logger . getLogger ( "org.jboss.as.host.controller" ) ; static final ServiceName SERVICE_NAME_BASE = JBOSS . append ( "host" , "controller" ) ; static final int DEFAULT_POOL_SIZE = 20 ; private final ServiceContainer serviceContainer = Factory . create ( ) ; private final HostControllerEnvironment environment ; private final byte [ ] authCode ; public HostControllerBootstrap ( final HostControllerEnvironment environment , final byte [ ] authCode ) { } public void start ( ) throws Exception { final File configDir = environment . getDomainConfigurationDir ( ) ; final ExtensibleConfigurationPersister configurationPersister = HostControllerBootstrap . createHostConfigurationPersister ( configDir ) ; final HostModel hostModel = new HostModel ( configurationPersister ) ; final List < ModelNode > operations = configurationPersister . load ( ) ; final AtomicInteger count = new AtomicInteger ( 1 ) ; final ResultHandler resultHandler = new ResultHandler ( ) { @ Override public void handleResultFragment ( final String [ ] location , final ModelNode result ) { } @ Override <START_BUG> public void handleResultComplete ( final ModelNode compensatingOperation ) { <END_BUG> if ( ( count . decrementAndGet ( ) ) == 0 ) { } } @ Override public void handleFailed ( final ModelNode failureDescription ) { if ( ( count . decrementAndGet ( ) ) == 0 ) { } } @ Override public void handleCancellation ( ) { if ( ( count . decrementAndGet ( ) ) == 0 ) { } } } ; for ( final ModelNode operation : operations ) { count . incrementAndGet ( ) ; hostModel . execute ( operation , resultHandler ) ; } if ( ( count . decrementAndGet ( ) ) == 0 ) { } final ServiceTarget serviceTarget = serviceContainer ; serviceTarget . addListener ( new org . jboss . msc . service . AbstractServiceListener < Object > ( ) { public void serviceFailed ( final ServiceController < ? > serviceController , final StartException reason ) { HostControllerBootstrap . log . errorf ( reason , "Service<seq2seq4repair_space>[%s]<seq2seq4repair_space>failed." , serviceController . getName ( ) ) ; } } ) ; final ModelNode rawModel = hostModel . getHostModel ( ) ; final String mgmtNetwork = rawModel . get ( MANAGEMENT , NATIVE_API , INTERFACE ) . asString ( ) ; final int mgmtPort = rawModel . get ( MANAGEMENT , NATIVE_API , PORT ) . asInt ( ) ; final ProcessControllerConnectionService processControllerClient = new ProcessControllerConnectionService ( environment , authCode ) ; serviceTarget . addService ( SERVICE_NAME , processControllerClient ) . install ( ) ; HostControllerBootstrap . activateNetworkInterfaces ( rawModel , serviceTarget ) ; HostControllerBootstrap . activateDomainControllerConnection ( environment , rawModel , serviceTarget ) ; final ServerInventoryService inventory = new ServerInventoryService ( environment , mgmtPort ) ; serviceTarget . addService ( ServerInventoryService . SERVICE_NAME , inventory ) . addDependency ( SERVICE_NAME , ProcessControllerClient . class , inventory . getClient ( ) ) . addDependency ( JBOSS_NETWORK_INTERFACE . append ( mgmtNetwork ) , NetworkInterfaceBinding . class , inventory . getInterface ( ) ) . addDependency ( DomainControllerConnection . SERVICE_NAME , DomainControllerConnection . class , inventory . getDomainControllerConnection ( ) ) . install ( ) ; final String name = rawModel . get ( NAME ) . asString ( ) ; final FileRepository repository = new LocalFileRepository ( environment ) ; final HostControllerService hc = new HostControllerService ( name , hostModel , repository ) ; serviceTarget . addService ( HostController . SERVICE_NAME , hc ) . addDependency ( DomainControllerConnection . SERVICE_NAME , DomainControllerConnection . class , hc . getConnection ( ) ) . addDependency ( ServerInventoryService . SERVICE_NAME , ServerInventory . class , hc . getServerInventory ( ) ) . addDependency ( ServerToHostOperationHandler . SERVICE_NAME ) . setInitialMode ( ACTIVE ) . install ( ) ; final ServiceName threadFactoryServiceName = HostControllerBootstrap . SERVICE_NAME_BASE . append ( "thread-factory" ) ; final ServiceName executorServiceName = HostControllerBootstrap . SERVICE_NAME_BASE . append ( "executor" ) ; serviceTarget . addService ( threadFactoryServiceName , new ThreadFactoryService ( ) ) . install ( ) ; final HostControllerBootstrap . HostControllerExecutorService executorService = new HostControllerBootstrap . HostControllerExecutorService ( ) ; serviceTarget . addService ( executorServiceName , executorService ) . addDependency ( threadFactoryServiceName , ThreadFactory . class , executorService . threadFactoryValue ) . install ( ) ; final ManagementCommunicationService managementCommunicationService = new ManagementCommunicationService ( ) ; serviceTarget . addService ( ManagementCommunicationService . SERVICE_NAME , managementCommunicationService ) . addDependency ( JBOSS_NETWORK_INTERFACE . append ( mgmtNetwork ) , NetworkInterfaceBinding . class , managementCommunicationService . getInterfaceInjector ( ) ) . addInjection ( managementCommunicationService . getPortInjector ( ) , mgmtPort ) . addDependency ( executorServiceName , ExecutorService . class , managementCommunicationService . getExecutorServiceInjector ( ) ) . addDependency ( threadFactoryServiceName , ThreadFactory . class , managementCommunicationService . getThreadFactoryInjector ( ) ) . setInitialMode ( ACTIVE ) . install ( ) ; final ServerToHostOperationHandler serverToHost = new ServerToHostOperationHandler ( ) ; serviceTarget . addService ( ServerToHostOperationHandler . SERVICE_NAME , serverToHost ) . addDependency ( ServerInventoryService . SERVICE_NAME , ManagedServerLifecycleCallback . class , serverToHost . getCallback ( ) ) . addDependency ( ManagementCommunicationService . SERVICE_NAME , ManagementCommunicationService . class , new org . jboss . as . host . controller . mgmt . ManagementCommunicationServiceInjector ( serverToHost ) ) . install ( ) ; } static void activateDomainControllerConnection ( final HostControllerEnvironment environment , final ModelNode host , final ServiceTarget serviceTarget ) { } static void installLocalDomainController ( final HostControllerEnvironment environment , final ModelNode host , final ServiceTarget serviceTarget ) { } static void installRemoteDomainControllerConnection ( final HostControllerEnvironment environment , final ModelNode host , final ServiceTarget serviceTarget ) { } static void activateNetworkInterfaces ( final ModelNode host , final ServiceTarget serviceTarget ) { } static ExtensibleConfigurationPersister createHostConfigurationPersister ( final File configDir ) { } static ExtensibleConfigurationPersister createDomainConfigurationPersister ( final File configDir ) { } static final class HostControllerExecutorService implements Service < Executor > { final InjectedValue < ThreadFactory > threadFactoryValue = new InjectedValue < ThreadFactory > ( ) ; private ScheduledExecutorService executorService ; @ Override public synchronized void start ( final StartContext context ) throws StartException { }
public class LogicComponent implements Pushable { public String ID ; public HashMap < String , WNode > input ; public HashMap < String , WNode > output ; public Point center ; public int gateDelay ; public int painted ; public String label ; public int pathDeph ; public LogicComponent ( ) { } public LogicComponent ( int in_capacity , int out_capacity ) { } public String toString ( ) { } public Collection < WNode > getInputs ( ) { } public Collection < WNode > getOutputs ( ) { } public void setCoordinates ( Point c ) { } public void updateCoords ( ) { } public void setLabel ( String l ) { } public void setGateDelay ( int value ) { } public void plugInput ( WNode n , String in_name ) { } public void plugOutput ( WNode n , String out_name ) { } public boolean pushSignal ( ) { } public void paint ( Graphics g ) { } public void clearAnimation ( Graphics g ) { } public void pass ( Graphics g ) { if ( ( painted ) < ( gateDelay ) ) { g . setColor ( Color . green ) ; <START_BUG> g . fillRect ( ( ( ( center . getX ( ) ) - 20 ) + ( 10 * ( painted ) ) ) , ( ( center . getY ( ) ) - 5 ) , 10 , 10 ) ; <END_BUG> ( painted ) ++ ; } } No newline ; at end ; of file ; }
public class ImpcImagesIndexer extends AbstractIndexer { private static final Logger logger = LoggerFactory . getLogger ( ImpcImagesIndexer . class ) ; @ Autowired @ Qualifier ( "observationIndexing" ) private SolrServer observationService ; @ Autowired @ Qualifier ( "impcImagesIndexing" ) SolrServer server ; @ Autowired @ Qualifier ( "alleleIndexing" ) SolrServer alleleIndexing ; @ Autowired @ Qualifier ( "komp2DataSource" ) DataSource komp2DataSource ; @ Autowired MaOntologyService maService ; @ Resource ( name = "globalConfiguration" ) private Map < String , String > config ; private Map < String , List < AlleleDTO > > alleles ; private Map < String , ImpcImagesIndexer . ImageBean > imageBeans ; String excludeProcedureStableId = "IMPC_PAT_002" ; private Map < String , String > parameterStableIdToMaTermIdMap ; private String impcMediaBaseUrl ; private String impcAnnotationBaseUrl ; public ImpcImagesIndexer ( ) { } @ Override public void validateBuild ( ) throws IndexerException { } public static void main ( String [ ] args ) throws IndexerException { } @ Override public void run ( ) throws IndexerException { int count = 0 ; ImpcImagesIndexer . logger . info ( "running<seq2seq4repair_space>impc_images<seq2seq4repair_space>indexer" ) ; try { parameterStableIdToMaTermIdMap = this . populateParameterStableIdToMaIdMap ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } ImpcImagesIndexer . logger . info ( "populating<seq2seq4repair_space>image<seq2seq4repair_space>urls<seq2seq4repair_space>from<seq2seq4repair_space>db" ) ; imageBeans = populateImageUrls ( ) ; ImpcImagesIndexer . logger . info ( ( "Image<seq2seq4repair_space>beans<seq2seq4repair_space>map<seq2seq4repair_space>size=" + ( imageBeans . size ( ) ) ) ) ; if ( ( imageBeans . size ( ) ) < 100 ) { ImpcImagesIndexer . logger . error ( "Didn't<seq2seq4repair_space>get<seq2seq4repair_space>any<seq2seq4repair_space>image<seq2seq4repair_space>entries<seq2seq4repair_space>from<seq2seq4repair_space>the<seq2seq4repair_space>db<seq2seq4repair_space>with<seq2seq4repair_space>omero_ids<seq2seq4repair_space>set<seq2seq4repair_space>so<seq2seq4repair_space>exiting<seq2seq4repair_space>the<seq2seq4repair_space>impc_image<seq2seq4repair_space>Indexer!!" ) ; } ImpcImagesIndexer . logger . info ( "populating<seq2seq4repair_space>alleles" ) ; this . alleles = populateAlleles ( ) ; ImpcImagesIndexer . logger . info ( "populated<seq2seq4repair_space>alleles" ) ; String impcMediaBaseUrl = config . get ( "impcMediaBaseUrl" ) ; ImpcImagesIndexer . logger . info ( ( "omeroRootUrl=" + impcMediaBaseUrl ) ) ; impcAnnotationBaseUrl = impcMediaBaseUrl . replace ( "webgateway" , "webclient" ) ; try { server . deleteByQuery ( "*:*" ) ; SolrQuery query = ImageService . allImageRecordSolrQuery ( ) . setRows ( Integer . MAX_VALUE ) ; List < ImageDTO > imageList = observationService . query ( query ) . getBeans ( ImageDTO . class ) ; for ( ImageDTO imageDTO : imageList ) { String downloadFilePath = imageDTO . getDownloadFilePath ( ) ; if ( imageBeans . containsKey ( downloadFilePath ) ) { ImpcImagesIndexer . ImageBean iBean = imageBeans . get ( downloadFilePath ) ; String fullResFilePath = iBean . fullResFilePath ; if ( ( iBean . image_link ) != null ) { imageDTO . setImageLink ( iBean . image_link ) ; } imageDTO . setFullResolutionFilePath ( fullResFilePath ) ; int omeroId = iBean . omeroId ; imageDTO . setOmeroId ( omeroId ) ; <START_BUG> if ( ( ( omeroId == 0 ) || ( imageDTO . getProcedureStableId ( ) . equals ( excludeProcedureStableId ) ) ) || ( downloadFilePath . endsWith ( ".pdf" ) ) ) { <END_BUG> System . out . println ( ( ( ( ( "skipping<seq2seq4repair_space>omeroId=" + omeroId ) + "param<seq2seq4repair_space>and<seq2seq4repair_space>center" ) + ( imageDTO . getParameterStableId ( ) ) ) + ( imageDTO . getPhenotypingCenter ( ) ) ) ) ; continue ; } if ( ( omeroId != 0 ) && ( downloadFilePath != null ) ) { if ( downloadFilePath . endsWith ( ".pdf" ) ) { imageDTO . setDownloadUrl ( ( ( ( impcAnnotationBaseUrl ) + "/webclient/annotation/" ) + omeroId ) ) ; imageDTO . setJpegUrl ( ( ( impcMediaBaseUrl + "/render_image/" ) + 119501 ) ) ; } else { imageDTO . setDownloadUrl ( ( ( impcMediaBaseUrl + "/archived_files/download/" ) + omeroId ) ) ; imageDTO . setJpegUrl ( ( ( impcMediaBaseUrl + "/render_image/" ) + omeroId ) ) ; } } else { ImpcImagesIndexer . logger . info ( ( "omero<seq2seq4repair_space>id<seq2seq4repair_space>is<seq2seq4repair_space>null<seq2seq4repair_space>for<seq2seq4repair_space>" + downloadFilePath ) ) ; } if ( ( ( imageDTO . getGeneAccession ( ) ) != null ) && ( ! ( imageDTO . getGeneAccession ( ) . equals ( "" ) ) ) ) { String geneAccession = imageDTO . getGeneAccession ( ) ; if ( alleles . containsKey ( geneAccession ) ) { populateImageDtoStatuses ( imageDTO , geneAccession ) ; if ( ( imageDTO . getSymbol ( ) ) != null ) { String symbolGene = ( ( imageDTO . getSymbol ( ) ) + "_" ) + ( imageDTO . getGeneAccession ( ) ) ; imageDTO . setSymbolGene ( symbolGene ) ; } } } if ( ( ( imageDTO . getParameterAssociationStableId ( ) ) != null ) && ( ! ( imageDTO . getParameterAssociationStableId ( ) . isEmpty ( ) ) ) ) { ArrayList < String > maIds = new ArrayList < > ( ) ; ArrayList < String > maTerms = new ArrayList < > ( ) ; ArrayList < String > maTermSynonyms = new ArrayList < > ( ) ; ArrayList < String > topLevelMaIds = new ArrayList < > ( ) ; ArrayList < String > topLevelMaTerm = new ArrayList < > ( ) ; ArrayList < String > topLevelMaTermSynonym = new ArrayList < > ( ) ; for ( String paramString : imageDTO . getParameterAssociationStableId ( ) ) { if ( parameterStableIdToMaTermIdMap . containsKey ( paramString ) ) { String maTermId = parameterStableIdToMaTermIdMap . get ( paramString ) ; maIds . add ( maTermId ) ; OntologyTermBean maTermBean = maService . getTerm ( maTermId ) ; if ( maTermBean != null ) { maTerms . add ( maTermBean . getName ( ) ) ; maTermSynonyms . addAll ( maTermBean . getSynonyms ( ) ) ; List < OntologyTermBean > topLevels = maService . getTopLevel ( maTermId ) ; for ( OntologyTermBean topLevel : topLevels ) { topLevelMaIds . add ( topLevel . getId ( ) ) ; topLevelMaTerm . add ( topLevel . getName ( ) ) ; topLevelMaTermSynonym . addAll ( topLevel . getSynonyms ( ) ) ; } } } }
public class mtTestCase { public String name = null ; public String file = null ; public String propFile = null ; public float weight = ( ( float ) ( 0.5 ) ) ; public Hashtable ignoreErrors = null ; public String description = null ; private int iterations ; private int attempts ; public void mtTestCase ( ) { } public void setName ( String name ) { } public String getName ( ) { } public void setFile ( String name ) { } public void setInputDir ( String dir ) { } public String getFile ( ) { } public void setPropFile ( String name ) { } public String getPropFile ( ) { } public void setWeight ( int weight ) { } public void setIgnoreErrors ( Hashtable t ) { } public void setDescription ( String description ) { } public synchronized BufferedInputStream initialize ( ) throws FileNotFoundException , IOException { } public synchronized BufferedInputStream initialize ( String inputDir ) throws FileNotFoundException , IOException { } public synchronized boolean grab ( ) { } public void runMe ( LocalizedOutput log , LocalizedOutput out , BufferedInputStream infile ) { utilMain utilInstance ; LocalizedInput is ; is = LocalizedResource . getInstance ( ) . getNewInput ( infile ) ; LocalizedInput [ ] in = new LocalizedInput [ ] { is } ; out . println ( ( ( "--------------" + ( file ) ) + "-----------------" ) ) ; utilInstance = new utilMain ( 1 , out , ignoreErrors ) ; utilInstance . initFromEnvironment ( ) ; utilInstance . setMtUse ( true ) ; <START_BUG> utilInstance . go ( in , out , ( ( Properties ) ( null ) ) ) ; <END_BUG> log . flush ( ) ; out . flush ( ) ; } public void updateURLProperties ( Properties p , String newURLPrefix ) { } public String alterURL ( String url , String newURLPrefix ) { } public String toString ( ) { } }
public class GuiPackage { private static transient Logger log = Hierarchy . getDefaultHierarchy ( ) . getLoggerFor ( "jmeter.gui" ) ; private static GuiPackage guiPack ; private boolean dirty = false ; private Map nodesToGui = new HashMap ( ) ; private Map guis = new HashMap ( ) ; private JMeterTreeNode currentNode = null ; private GuiPackage ( ) { } private JMeterTreeModel treeModel ; private MainFrame mainFrame ; private JMeterTreeListener treeListener ; public JMeterGUIComponent getGui ( TestElement node , String guiClass ) { } public void removeNode ( TestElement node ) { } public JMeterGUIComponent getCurrentGui ( ) { } public JMeterTreeNode getNodeOf ( TestElement userObject ) { } public TestElement createTestElement ( String guiClass ) { } public JMeterGUIComponent getGui ( TestElement node ) { } public void updateCurrentGui ( ) { } public void updateCurrentNode ( ) { } public static GuiPackage getInstance ( JMeterTreeListener listener , JMeterTreeModel treeModel ) { } public void setDirty ( boolean d ) { } public boolean isDirty ( ) { } <START_BUG> public boolean addSubTree ( HashTree subTree ) throws IllegalUserActionException { <END_BUG> return treeModel . addSubTree ( subTree , treeListener . getCurrentNode ( ) ) ; } public HashTree getCurrentSubTree ( ) { } public static GuiPackage getInstance ( ) { } public JMeterTreeModel getTreeModel ( ) { } public ValueReplacer getReplacer ( ) { } public void setTreeModel ( JMeterTreeModel newTreeModel ) { } public void setMainFrame ( org . apache . jmeter . gui . MainFrame newMainFrame ) { } public MainFrame getMainFrame ( ) { } public void setTreeListener ( JMeterTreeListener newTreeListener ) { } public JMeterTreeListener getTreeListener ( ) { } public void displayPopUp ( MouseEvent e , JPopupMenu popup ) { } public void displayPopUp ( Component invoker , MouseEvent e , JPopupMenu popup ) { } }
public class SelectionOnSuperReference extends SuperReference { public SelectionOnSuperReference ( int pos , int sourceEnd ) { } public StringBuffer printExpression ( int indent , StringBuffer output ) { } public TypeBinding resolveType ( BlockScope scope ) { TypeBinding binding = super . resolveType ( scope ) ; if ( ( binding == null ) || ( ! ( binding . isValidBinding ( ) ) ) ) throw new SelectionNodeFound ( ) ; else <START_BUG> throw new SelectionNodeFound ( this , binding ) ; <END_BUG> } }
XSSimpleTypeDecl nonNegativeDV = new XSSimpleTypeDecl ( integerDV , NONNEGATIVEINTEGER , SchemaDVFactoryImpl . URI_SCHEMAFORSCHEMA , ( ( short ) ( 0 ) ) , false ) ; nonNegativeDV . applyFacets1 ( facets , FACET_MININCLUSIVE , ( ( short ) ( 0 ) ) ) ; SchemaDVFactoryImpl . fBuiltInTypes . put ( NONNEGATIVEINTEGER , nonNegativeDV ) ; facets . maxInclusive = "18446744073709551615" ; XSSimpleTypeDecl unsignedLongDV = new XSSimpleTypeDecl ( nonNegativeDV , UNSIGNEDLONG , SchemaDVFactoryImpl . URI_SCHEMAFORSCHEMA , ( ( short ) ( 0 ) ) , false ) ; unsignedLongDV . applyFacets1 ( facets , FACET_MAXINCLUSIVE , ( ( short ) ( 0 ) ) ) ; SchemaDVFactoryImpl . fBuiltInTypes . put ( UNSIGNEDLONG , unsignedLongDV ) ; facets . maxInclusive = "4294967295" ; XSSimpleTypeDecl unsignedIntDV = new XSSimpleTypeDecl ( unsignedLongDV , UNSIGNEDINT , SchemaDVFactoryImpl . URI_SCHEMAFORSCHEMA , ( ( short ) ( 0 ) ) , false ) ; unsignedIntDV . applyFacets1 ( facets , FACET_MAXINCLUSIVE , ( ( short ) ( 0 ) ) ) ; SchemaDVFactoryImpl . fBuiltInTypes . put ( UNSIGNEDINT , unsignedIntDV ) ; facets . maxInclusive = "65535" ; XSSimpleTypeDecl unsignedShortDV = new XSSimpleTypeDecl ( unsignedIntDV , UNSIGNEDSHORT , SchemaDVFactoryImpl . URI_SCHEMAFORSCHEMA , ( ( short ) ( 0 ) ) , false ) ; unsignedShortDV . applyFacets1 ( facets , FACET_MAXINCLUSIVE , ( ( short ) ( 0 ) ) ) ; SchemaDVFactoryImpl . fBuiltInTypes . put ( UNSIGNEDSHORT , unsignedShortDV ) ; facets . maxInclusive = "255" ; XSSimpleTypeDecl unsignedByteDV = new XSSimpleTypeDecl ( unsignedShortDV , UNSIGNEDBYTE , SchemaDVFactoryImpl . URI_SCHEMAFORSCHEMA , ( ( short ) ( 0 ) ) , false ) ; unsignedByteDV . applyFacets1 ( facets , FACET_MAXINCLUSIVE , ( ( short ) ( 0 ) ) ) ; SchemaDVFactoryImpl . fBuiltInTypes . put ( UNSIGNEDBYTE , unsignedByteDV ) ; facets . minInclusive = "1" ; XSSimpleTypeDecl positiveIntegerDV = new XSSimpleTypeDecl ( nonNegativeDV , POSITIVEINTEGER , SchemaDVFactoryImpl . URI_SCHEMAFORSCHEMA , ( ( short ) ( 0 ) ) , false ) ; positiveIntegerDV . applyFacets1 ( facets , FACET_MININCLUSIVE , ( ( short ) ( 0 ) ) ) ; SchemaDVFactoryImpl . fBuiltInTypes . put ( POSITIVEINTEGER , positiveIntegerDV ) ; SchemaDVFactoryImpl . fBuiltInTypes . put ( FLOAT , new XSSimpleTypeDecl ( anySimpleType , FLOAT , XSSimpleTypeDecl . DV_FLOAT , XSSimpleType . ORDERED_TOTAL , true , true , true , true ) ) ; SchemaDVFactoryImpl . fBuiltInTypes . put ( DOUBLE , new XSSimpleTypeDecl ( anySimpleType , DOUBLE , XSSimpleTypeDecl . DV_DOUBLE , XSSimpleType . ORDERED_TOTAL , true , true , true , true ) ) ; SchemaDVFactoryImpl . fBuiltInTypes . put ( HEXBINARY , new XSSimpleTypeDecl ( anySimpleType , HEXBINARY , XSSimpleTypeDecl . DV_HEXBINARY , XSSimpleType . ORDERED_FALSE , false , false , false , true ) ) ; SchemaDVFactoryImpl . fBuiltInTypes . put ( NOTATION , new XSSimpleTypeDecl ( anySimpleType , NOTATION , XSSimpleTypeDecl . DV_NOTATION , XSSimpleType . ORDERED_FALSE , false , false , false , true ) ) ; facets . whiteSpace = XSSimpleType . WS_REPLACE ; XSSimpleTypeDecl normalizedDV = new XSSimpleTypeDecl ( stringDV , NORMALIZEDSTRING , SchemaDVFactoryImpl . URI_SCHEMAFORSCHEMA , ( ( short ) ( 0 ) ) , false ) ; normalizedDV . applyFacets1 ( facets , FACET_WHITESPACE , ( ( short ) ( 0 ) ) ) ; SchemaDVFactoryImpl . fBuiltInTypes . put ( NORMALIZEDSTRING , normalizedDV ) ; facets . whiteSpace = XSSimpleType . WS_COLLAPSE ; XSSimpleTypeDecl tokenDV = new XSSimpleTypeDecl ( normalizedDV , TOKEN , SchemaDVFactoryImpl . URI_SCHEMAFORSCHEMA , ( ( short ) ( 0 ) ) , false ) ; tokenDV . applyFacets1 ( facets , FACET_WHITESPACE , ( ( short ) ( 0 ) ) ) ; SchemaDVFactoryImpl . fBuiltInTypes . put ( TOKEN , tokenDV ) ; facets . whiteSpace = XSSimpleType . WS_COLLAPSE ; <START_BUG> facets . pattern = "([a-zA-Z]{2}|[iI]-[a-zA-Z]+|[xX]-[a-zA-Z]+)(-[a-zA-Z]+)*" ; <END_BUG> XSSimpleTypeDecl languageDV = new XSSimpleTypeDecl ( tokenDV , LANGUAGE , SchemaDVFactoryImpl . URI_SCHEMAFORSCHEMA , ( ( short ) ( 0 ) ) , false ) ; languageDV . applyFacets1 ( facets , ( ( short ) ( ( XSSimpleType . FACET_WHITESPACE ) | ( XSSimpleType . FACET_PATTERN ) ) ) , ( ( short ) ( 0 ) ) ) ; SchemaDVFactoryImpl . fBuiltInTypes . put ( LANGUAGE , languageDV ) ; facets . whiteSpace = XSSimpleType . WS_COLLAPSE ; XSSimpleTypeDecl nameDV = new XSSimpleTypeDecl ( tokenDV , NAME , SchemaDVFactoryImpl . URI_SCHEMAFORSCHEMA , ( ( short ) ( 0 ) ) , false ) ; nameDV . applyFacets1 ( facets , FACET_WHITESPACE , ( ( short ) ( 0 ) ) , SPECIAL_PATTERN_NAME ) ; SchemaDVFactoryImpl . fBuiltInTypes . put ( NAME , nameDV ) ; facets . whiteSpace = XSSimpleType . WS_COLLAPSE ; XSSimpleTypeDecl ncnameDV = new XSSimpleTypeDecl ( nameDV , NCNAME , SchemaDVFactoryImpl . URI_SCHEMAFORSCHEMA , ( ( short ) ( 0 ) ) , false ) ; ncnameDV . applyFacets1 ( facets , FACET_WHITESPACE , ( ( short ) ( 0 ) ) , SPECIAL_PATTERN_NCNAME ) ; SchemaDVFactoryImpl . fBuiltInTypes . put ( NCNAME , ncnameDV ) ; SchemaDVFactoryImpl . fBuiltInTypes . put ( QNAME , new XSSimpleTypeDecl ( anySimpleType , QNAME , XSSimpleTypeDecl . DV_QNAME , XSSimpleType . ORDERED_FALSE , false , false , false , true ) ) ; SchemaDVFactoryImpl . fBuiltInTypes . put ( ID , new XSSimpleTypeDecl ( ncnameDV , ID , XSSimpleTypeDecl . DV_ID , XSSimpleType . ORDERED_FALSE , false , false , false , true ) ) ; XSSimpleTypeDecl idrefDV = new XSSimpleTypeDecl ( ncnameDV , IDREF , XSSimpleTypeDecl . DV_IDREF , XSSimpleType . ORDERED_FALSE , false , false , false , true ) ; SchemaDVFactoryImpl . fBuiltInTypes . put ( IDREF , idrefDV ) ; facets . minLength = 1 ; XSSimpleTypeDecl tempDV = new XSSimpleTypeDecl ( null , SchemaDVFactoryImpl . URI_SCHEMAFORSCHEMA , ( ( short ) ( 0 ) ) , idrefDV , true ) ; XSSimpleTypeDecl idrefsDV = new XSSimpleTypeDecl ( tempDV , IDREFS , SchemaDVFactoryImpl . URI_SCHEMAFORSCHEMA , ( ( short ) ( 0 ) ) , false ) ;
public class FolderFactory { private static final Pattern groupPattern = Pattern . compile ( "([^\\s]+)\\s*" ) ; private static FolderFactory instance ; private FolderPluginHandler handler ; private XmlElement folderlistElement ; private String path = config . getConfigDirectory ( ) . getPath ( ) ; protected FolderFactory ( ) { } public static FolderFactory getInstance ( ) { } public List getPossibleChilds ( AbstractFolder parent ) { List list = new LinkedList ( ) ; <START_BUG> FolderItem item = parent . getFolderItem ( ) ; <END_BUG> String parentType = item . get ( "type" ) ; String parentGroup = getGroup ( parentType ) ; Iterator it = folderlistElement . getElements ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { XmlElement next = ( ( XmlElement ) ( it . next ( ) ) ) ; String possibleParents = next . getAttribute ( "possible_parents" ) ; if ( possibleParents != null ) { Matcher matcher = FolderFactory . groupPattern . matcher ( possibleParents ) ; while ( matcher . find ( ) ) { if ( matcher . group ( 1 ) . equals ( parentGroup ) ) { list . add ( next . getAttribute ( "name" ) ) ; } } } } return list ; } public AbstractFolder createDefaultChild ( AbstractFolder parent , String name ) throws Exception { } public AbstractFolder createChild ( AbstractFolder parent , String name , String childType ) throws Exception { } private String getGroup ( String parentType ) { } }
defaultLetter . setName ( letterName ) ; defaultLetter . setDescription ( letterDescription ) ; defaultLetter . setPeriode ( letterFrequence ) ; infoLetterSC . updateInfoLetter ( defaultLetter ) ; destination = setMainContext ( infoLetterSC , request ) ; } else if ( function . startsWith ( "Emails" ) ) { InfoLetter defaultLetter = getCurrentLetter ( infoLetterSC ) ; Set < String > listEmails = infoLetterSC . getEmailsExternalsSuscribers ( defaultLetter . getPK ( ) ) ; request . setAttribute ( "listEmails" , listEmails ) ; destination = "emailsManager.jsp" ; } else if ( function . startsWith ( "SuscribeMe" ) ) { infoLetterSC . suscribeUser ( ) ; destination = setMainContext ( infoLetterSC , request ) ; } else if ( function . startsWith ( "UnsuscribeMe" ) ) { infoLetterSC . unsuscribeUser ( ) ; destination = setMainContext ( infoLetterSC , request ) ; } else if ( function . startsWith ( "DeleteEmails" ) ) { String [ ] emails = request . getParameterValues ( "mails" ) ; InfoLetter defaultLetter = getCurrentLetter ( infoLetterSC ) ; if ( emails != null ) { infoLetterSC . deleteExternalsSuscribers ( defaultLetter . getPK ( ) , emails ) ; } Set < String > listEmails = infoLetterSC . getEmailsExternalsSuscribers ( defaultLetter . getPK ( ) ) ; request . setAttribute ( "listEmails" , listEmails ) ; destination = "emailsManager.jsp" ; } else if ( function . startsWith ( "DeleteAllEmails" ) ) { InfoLetter defaultLetter = getCurrentLetter ( infoLetterSC ) ; infoLetterSC . deleteAllExternalsSuscribers ( defaultLetter . getPK ( ) ) ; Set < String > listEmails = infoLetterSC . getEmailsExternalsSuscribers ( defaultLetter . getPK ( ) ) ; request . setAttribute ( "listEmails" , listEmails ) ; destination = "emailsManager.jsp" ; } else if ( function . startsWith ( "AddMail" ) ) { destination = "addEmail.jsp" ; } else if ( function . startsWith ( "NewMail" ) ) { String newmails = param ( request , "newmails" ) ; InfoLetter defaultLetter = getCurrentLetter ( infoLetterSC ) ; infoLetterSC . addExternalsSuscribers ( defaultLetter . getPK ( ) , newmails ) ; Set < String > listEmails = infoLetterSC . getEmailsExternalsSuscribers ( defaultLetter . getPK ( ) ) ; request . setAttribute ( "listEmails" , listEmails ) ; destination = "emailsManager.jsp" ; } else if ( function . startsWith ( "Suscribers" ) ) { destination = infoLetterSC . initUserPanel ( ) ; } else if ( function . startsWith ( "RetourPanel" ) ) { infoLetterSC . retourUserPanel ( ) ; destination = setMainContext ( infoLetterSC , request ) ; } else if ( function . equals ( "ViewTemplate" ) ) { request . setAttribute ( "InfoLetter" , getCurrentLetter ( infoLetterSC ) ) ; destination = "template.jsp" ; } else if ( function . startsWith ( "searchResult" ) ) { String id = request . getParameter ( "Id" ) ; String type = request . getParameter ( "Type" ) ; if ( type . equals ( "Lettre" ) ) { destination = setMainContext ( infoLetterSC , request ) ; } else { if ( id == null ) { id = "" ; } if ( ! ( id . isEmpty ( ) ) ) { IdPK publiPK = new IdPK ( ) ; publiPK . setId ( id ) ; InfoLetterPublicationPdC ilp = infoLetterSC . getInfoLetterPublication ( publiPK ) ; request . setAttribute ( "parution" , id ) ; request . setAttribute ( "parutionTitle" , ilp . getTitle ( ) ) ; destination = "viewLetter.jsp" ; } else { destination = setMainContext ( infoLetterSC , request ) ; } } } else if ( function . startsWith ( "ImportEmailsCsv" ) ) { FileItem fileItem = request . getSingleFile ( ) ; infoLetterSC . importCsvEmails ( fileItem ) ; destination = "importEmailsCsv.jsp?Result=OK" ; } else if ( function . equals ( "ExportEmailsCsv" ) ) { boolean exportOk = infoLetterSC . exportCsvEmails ( ) ; request . setAttribute ( "ExportOk" , Boolean . toString ( exportOk ) ) ; if ( exportOk ) { <START_BUG> request . setAttribute ( "EmailCsvName" , ( ( getCurrentLetter ( infoLetterSC ) . getName ( ) ) + ( InfoLetterSessionController . EXPORT_CSV_NAME ) ) ) ; <END_BUG> } destination = "exportEmailsCsv.jsp" ; } else if ( function . startsWith ( "SendLetterToManager" ) ) { String parution = param ( request , "parution" ) ; String [ ] emailErrors = new String [ 0 ] ; if ( StringUtil . isDefined ( parution ) ) { IdPK publiPK = new IdPK ( ) ; publiPK . setId ( parution ) ; InfoLetterPublicationPdC ilp = infoLetterSC . getInfoLetterPublication ( publiPK ) ; String server = request . getRequestURL ( ) . substring ( 0 , request . getRequestURL ( ) . toString ( ) . indexOf ( URLManager . getApplicationURL ( ) ) ) ; emailErrors = infoLetterSC . notifyManagers ( ilp , server ) ; } request . setAttribute ( "SpaceId" , infoLetterSC . getSpaceId ( ) ) ; request . setAttribute ( "SpaceName" , infoLetterSC . getSpaceLabel ( ) ) ; request . setAttribute ( "ComponentId" , infoLetterSC . getComponentId ( ) ) ; request . setAttribute ( "ComponentName" , infoLetterSC . getComponentLabel ( ) ) ; request . setAttribute ( "EmailErrors" , emailErrors ) ; request . setAttribute ( "ReturnUrl" , ( ( ( request . getParameter ( "ReturnUrl" ) ) + "?parution=" ) + parution ) ) ; destination = "infoLetterSended.jsp" ; } else { destination = function ; } if ( ! ( function . startsWith ( "Suscribers" ) ) ) { destination = "/infoLetter/jsp/" + destination ; } } catch ( Exception e ) { request . setAttribute ( "javax.servlet.jsp.jspException" , e ) ; destination = "/admin/jsp/errorpageMain.jsp" ; } SilverTrace . info ( "infoLetter" , "infoLetterRequestRouter.getDestination()" , "root.MSG_GEN_PARAM_VALUE" , ( "Destination=" + destination ) ) ; return destination ; } private String getFlag ( String [ ] profiles ) { } private String param ( HttpServletRequest request , String name ) { } }
public class WebMethodCheckForWebServiceRule extends AbstractAnnotationProcessor { private static final String WEB_METHOD = "javax.jws.WebMethod" ; private static final String WEB_SERVICE = "javax.jws.WebService" ; public WebMethodCheckForWebServiceRule ( ) { } @ Override public void process ( ) { Messager messager = environment . getMessager ( ) ; AnnotationTypeDeclaration annotationDeclaration = ( ( AnnotationTypeDeclaration ) ( environment . getTypeDeclaration ( WebMethodCheckForWebServiceRule . WEB_METHOD ) ) ) ; Collection < Declaration > annotatedTypes = environment . getDeclarationsAnnotatedWith ( annotationDeclaration ) ; for ( Declaration declaration : annotatedTypes ) { Collection < AnnotationMirror > annotationMirrors = declaration . getAnnotationMirrors ( ) ; for ( AnnotationMirror mirror : annotationMirrors ) { if ( ( mirror . getAnnotationType ( ) . getDeclaration ( ) . getQualifiedName ( ) . equals ( WebMethodCheckForWebServiceRule . WEB_METHOD ) ) && ( ! ( checkForWebServiceAnnotation ( ( ( com . sun . mirror . declaration . MethodDeclaration ) ( declaration ) ) . getDeclaringType ( ) ) ) ) ) { <START_BUG> messager . printError ( mirror . getPosition ( ) , WEBMETHOD_ANNOTATION_PROCESSOR_ONLY_SUPPORTED_ON_CLASSES_WITH_WEBSERVICE_MESSAGE ) ; <END_BUG> } } } } private boolean checkForWebServiceAnnotation ( TypeDeclaration typeDeclaration ) { } }
public class PaletteStorageHelper { private SQLiteDatabase database ; private DBManager dBManager ; private String [ ] allColumns = new String [ ] { DBManager . COLUMN_ID , DBManager . COLUMN_NAME , DBManager . COLUMN_COLORS } ; public static final int SUCCESS = 0 ; public static final int DUPLICATE = 1 ; public static final int FAILURE = 2 ; public PaletteStorageHelper ( Context context ) { } public void open ( ) throws SQLException { } public void close ( ) { } public int save ( Palette p ) { } public boolean remove ( Palette p ) { } public boolean isSaved ( Palette p ) { String temp = colorsToString ( p ) ; open ( ) ; <START_BUG> Cursor cursor = database . rawQuery ( ( ( ( ( ( ( ( ( "SELECT<seq2seq4repair_space>" + ( DBManager . COLUMN_COLORS ) ) + "<seq2seq4repair_space>FROM<seq2seq4repair_space>" ) + ( DBManager . TABLE_PALETTES ) ) + "<seq2seq4repair_space>WHERE<seq2seq4repair_space>" ) + ( DBManager . COLUMN_COLORS ) ) + "<seq2seq4repair_space>=<seq2seq4repair_space>\'" ) + temp ) + "'" ) , null ) ; <END_BUG> close ( ) ; if ( ( cursor . getCount ( ) ) > 0 ) return true ; return false ; } public Palette [ ] getAllPalettes ( ) { } private String colorsToString ( Palette p ) { } private Palette cursorToPalette ( Cursor cursor ) { } }
public class EJBSecurityManagerDefaultImpl implements EJBSecurityManager { public boolean isValid ( Principal principal , Object credential ) { <START_BUG> return principal . getName ( ) . equals ( credential . toString ( ) ) ; <END_BUG> } }
public abstract class IndexFactory { private static final Logger LOGGER = LoggerFactory . getLogger ( IndexFactory . class ) ; private static IndexFactory . IIndexFactory indexFactory ; private static void initFactory ( ) { Class cl ; try { cl = IndexFactory . class . getClassLoader ( ) . loadClass ( "org.lex.perf.impl.IndexFactoryImpl" ) ; IndexFactory . indexFactory = ( ( IndexFactory . IIndexFactory ) ( cl . newInstance ( ) ) ) ; <START_BUG> } catch ( Throwable e ) { <END_BUG> IndexFactory . LOGGER . error ( "Can't<seq2seq4repair_space>instantiate<seq2seq4repair_space>IndexFactory" , e ) ; IndexFactory . indexFactory = new NopIndexFactory ( ) ; } } public static IndexFactory . IIndexFactory getFactory ( ) { } public interface IIndexFactory { public void registerGauge ( IndexSeriesImpl impl , GaugeIndex gaugeIndex ) { } IndexSeriesImpl createIndexSeriesImpl ( String indexSeriesName ) { } } private static final Map < String , IndexSeries > INDEX_SERIES = new ConcurrentHashMap < String , IndexSeries > ( ) ; public static synchronized IndexSeries registerIndexSeries ( String indexSeriesName ) { } public static void registerGauge ( IndexSeries indexSeries , GaugeIndex gaugeIndex ) { } }
public class AddFastExpenseActivity extends Activity { private static String groupUuid ; private double cost ; private String description ; private String expenseDate ; private boolean back = false ; @ Override protected void onCreate ( Bundle savedInstanceState ) { } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } private void addExpenseToAnExistingGroup ( ) { } private void addExpenseToNewGroup ( ) { } public static class PlaceholderFragment extends Fragment { private EditText dateEditText ; private EditText costEditText ; private EditText descEditText ; private Calendar myCalendar ; private OnDateSetListener date ; public PlaceholderFragment ( ) { } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { final View rootView = inflater . inflate ( fragment_add_fast_expense , container , false ) ; AddFastExpenseActivity . groupUuid = null ; myCalendar = Calendar . getInstance ( ) ; dateEditText = ( ( EditText ) ( rootView . findViewById ( expense_date ) ) ) ; SimpleDateFormat format = new SimpleDateFormat ( "dd/MM/yyyy" ) ; AddFastExpenseActivity activity = ( ( AddFastExpenseActivity ) ( getActivity ( ) ) ) ; if ( activity . back ) { costEditText = ( ( EditText ) ( rootView . findViewById ( expense_cost ) ) ) ; descEditText = ( ( EditText ) ( rootView . findViewById ( expense_description ) ) ) ; double cost = activity . cost ; String description = activity . description ; String date = activity . expenseDate ; descEditText . setText ( description ) ; costEditText . setText ( String . valueOf ( cost ) ) ; dateEditText . setText ( date ) ; } else { dateEditText . setText ( format . format ( myCalendar . getTime ( ) ) ) ; } date = new DatePickerDialog . OnDateSetListener ( ) { @ Override public void onDateSet ( DatePicker view , int year , int monthOfYear , int dayOfMonth ) { myCalendar . set ( Calendar . YEAR , year ) ; myCalendar . set ( Calendar . MONTH , monthOfYear ) ; myCalendar . set ( Calendar . DAY_OF_MONTH , dayOfMonth ) ; updateLabel ( ) ; } private void updateLabel ( ) { <START_BUG> String myFormat = "dd/mm/yy" ; <END_BUG> SimpleDateFormat sdf = new SimpleDateFormat ( myFormat , Locale . US ) ; dateEditText . setText ( sdf . format ( myCalendar . getTime ( ) ) ) ; } } ; dateEditText . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { new DatePickerDialog ( getActivity ( ) , date , myCalendar . get ( Calendar . YEAR ) , myCalendar . get ( Calendar . MONTH ) , myCalendar . get ( Calendar . DAY_OF_MONTH ) ) . show ( ) ; } } ) ; List < GroupDTO > groupDTOs = UserLocalDB . getGroupsDTOs ( ) ; List < String > groupsNames = new ArrayList < > ( ) ; for ( GroupDTO groupDTO : groupDTOs ) { groupsNames . add ( groupDTO . getGroupName ( ) ) ; } if ( groupDTOs . isEmpty ( ) ) { View chooseGroupCard = rootView . findViewById ( choose_group_card ) ; chooseGroupCard . setVisibility ( GONE ) ; } else { Spinner spinner = ( ( Spinner ) ( rootView . findViewById ( groups_spinner ) ) ) ; ArrayAdapter < String > spinnerArrayAdapter = new ArrayAdapter ( getActivity ( ) , layout . simple_spinner_item , groupsNames ) ; spinnerArrayAdapter . setDropDownViewResource ( simple_spinner_dropdown_item ) ; spinner . setAdapter ( spinnerArrayAdapter ) ; spinner . setOnItemSelectedListener ( new AdapterView . OnItemSelectedListener ( ) { public void onItemSelected ( AdapterView < ? > parent , View view , int position , long id ) { groupChosen ( UserLocalDB . getGroupsDTOs ( ) . get ( position ) . getGroupUuid ( ) ) ; } @ Override public void onNothingSelected ( AdapterView < ? > parent ) { } } ) ; } Spinner spinner = ( ( Spinner ) ( rootView . findViewById ( groups_spinner ) ) ) ; ArrayAdapter < String > spinnerArrayAdapter = new ArrayAdapter ( getActivity ( ) , R . layout . spinner_item , groupsNames ) ; spinnerArrayAdapter . setDropDownViewResource ( spinner_dropdown_item ) ; spinner . setAdapter ( spinnerArrayAdapter ) ; spinner . setOnItemSelectedListener ( new AdapterView . OnItemSelectedListener ( ) { public void onItemSelected ( AdapterView < ? > parent , View view , int position , long id ) { groupChosen ( UserLocalDB . getGroupsDTOs ( ) . get ( position ) . getGroupUuid ( ) ) ; } @ Override public void onNothingSelected ( AdapterView < ? > parent ) { } } ) ; Button addToNewGroupButton = ( ( Button ) ( rootView . findViewById ( create_new_group_button ) ) ) ; Typeface font = Typeface . create ( "sans-serif-condensed" , NORMAL ) ; addToNewGroupButton . setTypeface ( font ) ; addToNewGroupButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { createNewGroup ( ) ; } } ) ; return rootView ; } private void createNewGroup ( ) { } private void groupChosen ( String groupUuid ) { } } }
public class CameraPreview extends ViewGroup { public interface StateListener { void previewSized ( ) { } void previewStarted ( ) { } void previewStopped ( ) { } void cameraError ( Exception error ) { } } private static final String TAG = CameraPreview . class . getSimpleName ( ) ; private CameraInstance cameraInstance ; private WindowManager windowManager ; private Handler stateHandler ; private boolean useTextureView = false ; private SurfaceView surfaceView ; private TextureView textureView ; private boolean previewActive = false ; private RotationListener rotationListener ; private List < CameraPreview . StateListener > stateListeners = new ArrayList < > ( ) ; private DisplayConfiguration displayConfiguration ; private CameraSettings cameraSettings = new CameraSettings ( ) ; private Size containerSize ; private Size previewSize ; private Rect surfaceRect ; private Size currentSurfaceSize ; private Rect framingRect = null ; private Rect previewFramingRect = null ; private Size framingRectSize = null ; private double marginFraction = 0.1 ; @ TargetApi ( 14 ) private SurfaceTextureListener surfaceTextureListener ( ) { } private final Callback surfaceCallback = new SurfaceHolder . Callback ( ) { @ Override public void surfaceCreated ( SurfaceHolder holder ) { } @ Override public void surfaceDestroyed ( SurfaceHolder holder ) { } @ Override public void surfaceChanged ( SurfaceHolder holder , int format , int width , int height ) { } } ; private final Handler . Callback stateCallback = new Handler . Callback ( ) { @ Override public boolean handleMessage ( Message message ) { } } ; private RotationCallback rotationCallback = new RotationCallback ( ) { @ Override public void onRotationChanged ( int rotation ) { } } ; public CameraPreview ( Context context ) { } public CameraPreview ( Context context , AttributeSet attrs ) { } public CameraPreview ( Context context , AttributeSet attrs , int defStyleAttr ) { } private void initialize ( Context context , AttributeSet attrs , int defStyleAttr , int defStyleRes ) { } @ Override protected void onAttachedToWindow ( ) { } protected void initializeAttributes ( AttributeSet attrs ) { } private void rotationChanged ( ) { } private void setupSurfaceView ( ) { } public void addStateListener ( CameraPreview . StateListener listener ) { } private final CameraPreview . StateListener fireState = new CameraPreview . StateListener ( ) { @ Override public void previewSized ( ) { } @ Override public void previewStarted ( ) { } @ Override public void previewStopped ( ) { } @ Override public void cameraError ( Exception error ) { } } ; private void calculateFrames ( ) { } public void setTorch ( boolean on ) { } private void containerSized ( Size containerSize ) { } private void previewSized ( Size size ) { } protected Matrix calculateTextureTransform ( Size textureSize , Size previewSize ) { } private void startPreviewIfReady ( ) { } @ SuppressLint ( "DrawAllocation" ) @ Override protected void onLayout ( boolean changed , int l , int t , int r , int b ) { containerSized ( new Size ( ( r - l ) , ( b - t ) ) ) ; if ( ( surfaceView ) != null ) { if ( ( surfaceRect ) == null ) { surfaceView . layout ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; } else { surfaceView . layout ( surfaceRect . left , surfaceRect . top , surfaceRect . right , surfaceRect . bottom ) ; } } else <START_BUG> if ( ( textureView ) != null ) { <END_BUG> textureView . layout ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; } } public Rect getFramingRect ( ) { } public Rect getPreviewFramingRect ( ) { } public CameraSettings getCameraSettings ( ) { } public void setCameraSettings ( CameraSettings cameraSettings ) { } public void resume ( ) { } public void pause ( ) { } public Size getFramingRectSize ( ) { } public void setFramingRectSize ( Size framingRectSize ) { } public double getMarginFraction ( ) { } public void setMarginFraction ( double marginFraction ) { } public boolean isUseTextureView ( ) { } public void setUseTextureView ( boolean useTextureView ) { } protected boolean isActive ( ) { } private int getDisplayRotation ( ) { } private void initCamera ( ) { } private void startCameraPreview ( CameraSurface surface ) { } protected void previewStarted ( ) { } public CameraInstance getCameraInstance ( ) { } public boolean isPreviewActive ( ) { } protected Rect calculateFramingRect ( Rect container , Rect surface ) { } }
if ( ( ( ( entry . getKey ( ) . contains ( "path" ) ) || ( entry . getKey ( ) . contains ( "resource" ) ) ) || ( entry . getKey ( ) . contains ( "packagename" ) ) ) || ( entry . getKey ( ) . contains ( "appname" ) ) ) { comparisonString = ( ( ( "{\"" + ( entry . getKey ( ) ) ) + "\":\"" ) + ( entry . getValue ( ) ) ) + "\"}" ; } else { comparisonString = ( ( ( "{\"" + ( entry . getKey ( ) ) ) + "\":" ) + ( entry . getValue ( ) ) ) + "}" ; } Log . d ( DecisionMaker . TAG , ( "<seq2seq4repair_space>" + comparisonString ) ) ; DebugFileLog . write ( ( "DecisionMaker-<seq2seq4repair_space>" + comparisonString ) ) ; if ( resource . getCondition ( ) . contains ( "\\/" ) ) { resourceCondition = resource . getCondition ( ) . replace ( "\\/" , "/" ) ; } else { resourceCondition = resource . getCondition ( ) ; } if ( resourceCondition != null ) { Log . d ( DecisionMaker . TAG , ( ( ( ( "<seq2seq4repair_space>1:" + ( resourceCondition . toLowerCase ( ) ) ) + "--<seq2seq4repair_space>2:" ) + ( comparisonString . toLowerCase ( ) ) ) + "--" ) ) ; DebugFileLog . write ( ( ( ( ( "DecisionMaker-<seq2seq4repair_space>1:" + ( resourceCondition . toLowerCase ( ) ) ) + "--<seq2seq4repair_space>2:" ) + ( comparisonString . toLowerCase ( ) ) ) + "--" ) ) ; } if ( resourceCondition . toLowerCase ( ) . equals ( comparisonString . toLowerCase ( ) ) ) { Log . d ( DecisionMaker . TAG , "<seq2seq4repair_space>Match!" ) ; DebugFileLog . write ( "DecisionMaker-<seq2seq4repair_space>Match!" ) ; resourceInPolicy = resource ; matchedCondition = resource . getCondition ( ) ; match = true ; break ; } else { Log . d ( DecisionMaker . TAG , ( "<seq2seq4repair_space>No<seq2seq4repair_space>Match!" + comparisonString ) ) ; DebugFileLog . write ( ( "DecisionMaker-<seq2seq4repair_space>No<seq2seq4repair_space>Match!" + comparisonString ) ) ; try { if ( resourceCondition . contains ( ":" ) ) { String property = resourceCondition . substring ( 0 , ( ( resourceCondition . indexOf ( ":" ) ) - 1 ) ) ; Log . d ( DecisionMaker . TAG , ( "property:" + property ) ) ; DebugFileLog . write ( ( "DecisionMaker-property:" + property ) ) ; if ( property . contains ( entry . getKey ( ) ) ) { int intValue = - 1 ; String value = resource . getCondition ( ) . substring ( ( ( resourceCondition . indexOf ( ":" ) ) + 1 ) , ( ( resourceCondition . length ( ) ) - 1 ) ) ; Log . d ( DecisionMaker . TAG , ( "value:" + value ) ) ; DebugFileLog . write ( ( "DecisionMaker-value:" + value ) ) ; try { intValue = Integer . valueOf ( value ) ; } catch ( NumberFormatException e ) { Log . d ( DecisionMaker . TAG , ( ( "value<seq2seq4repair_space>" + value ) + "<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>a<seq2seq4repair_space>number" ) ) ; DebugFileLog . write ( ( ( "DecisionMaker-value<seq2seq4repair_space>" + value ) + "<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>a<seq2seq4repair_space>number" ) ) ; } if ( intValue != ( - 1 ) ) { int currentValue = - 1 ; Log . d ( DecisionMaker . TAG , ( "Current<seq2seq4repair_space>value:" + ( entry . getValue ( ) ) ) ) ; DebugFileLog . write ( ( "DecisionMaker-Current<seq2seq4repair_space>value:" + ( entry . getValue ( ) ) ) ) ; try { currentValue = Integer . valueOf ( entry . getValue ( ) ) ; } catch ( NumberFormatException e ) { Log . d ( DecisionMaker . TAG , ( ( "current<seq2seq4repair_space>value<seq2seq4repair_space>" + ( entry . getValue ( ) ) ) + "<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>a<seq2seq4repair_space>number" ) ) ; DebugFileLog . write ( ( ( "DecisionMaker-current<seq2seq4repair_space>value<seq2seq4repair_space>" + ( entry . getValue ( ) ) ) + "<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>a<seq2seq4repair_space>number" ) ) ; } if ( currentValue != ( - 1 ) ) { if ( currentValue < intValue ) { Log . d ( DecisionMaker . TAG , ( ( ( "Current<seq2seq4repair_space>value<seq2seq4repair_space>" + currentValue ) + "<seq2seq4repair_space>is<seq2seq4repair_space>less<seq2seq4repair_space>than<seq2seq4repair_space>" ) + intValue ) ) ; DebugFileLog . write ( ( ( ( "DecisionMaker-Current<seq2seq4repair_space>value<seq2seq4repair_space>" + currentValue ) + "<seq2seq4repair_space>is<seq2seq4repair_space>less<seq2seq4repair_space>than<seq2seq4repair_space>" ) + intValue ) ) ; Log . d ( DecisionMaker . TAG , "Allow" ) ; DebugFileLog . write ( "DecisionMaker-Allow" ) ; dbManager . closeDB ( ) ; return getConditionNotSatisfiedDecision ( ) ; } else { Log . d ( DecisionMaker . TAG , ( ( ( "Current<seq2seq4repair_space>value<seq2seq4repair_space>" + currentValue ) + "<seq2seq4repair_space>is<seq2seq4repair_space>greater<seq2seq4repair_space>or<seq2seq4repair_space>equal<seq2seq4repair_space>than<seq2seq4repair_space>" ) + intValue ) ) ; DebugFileLog . write ( ( ( ( "DecisionMaker-Current<seq2seq4repair_space>value<seq2seq4repair_space>" + currentValue ) + "<seq2seq4repair_space>is<seq2seq4repair_space>greater<seq2seq4repair_space>or<seq2seq4repair_space>equal<seq2seq4repair_space>than<seq2seq4repair_space>" ) + intValue ) ) ; } } } } } } catch ( Exception e ) { Log . d ( DecisionMaker . TAG , e . getMessage ( ) ) ; } } <START_BUG> if ( resourceCondition . contains ( "wifi" ) ) { <END_BUG>
public class RestartHandler extends AbstractHandler { public Object execute ( ExecutionEvent event ) throws ExecutionException { if ( ( HandlerUtil . getActivePart ( event ) ) instanceof WotsView ) { WotsView view = ( ( WotsView ) ( HandlerUtil . getActivePart ( event ) ) ) ; <START_BUG> view . reset ( ) ; <END_BUG> } return null ; } }
public class ShipTest { @ Test public void testFire ( ) throws Exception { ShipType shipType1 = new ShipType ( "meet" , 1 , 1 , 1 ) ; ShipType shipType2 = new ShipType ( "shield4" , 1 , 1 , 4 ) ; Race race1 = new Race ( 1 , "Race1" ) ; Race race2 = new Race ( 2 , "Race2" ) ; Ship ship = new Ship ( race1 , shipType1 ) ; Ship shipEnemy = new Ship ( race2 , shipType2 ) ; <START_BUG> Shot shot = ship . fire ( shipEnemy , 1 ) ; <END_BUG> System . out . println ( shot . toString ( ) ) ; } No newline ; at end ; of file ; }
final TypeMirror erasedType = SerializerCreator . getErasedType ( innerType , processingEnvironment ) ; resultClassname = erasedType . toString ( ) ; } cast = typeMirror . toString ( ) ; } else { resultClassname = resultType . toString ( ) ; cast = resultClassname ; } } final boolean hasReturn = ! ( "void" . equals ( resultClassname ) ) ; w . println ( "try{" ) ; w . indent ( ) ; final String s = "return" ; w . println ( ( ( ( ( ( ( "if<seq2seq4repair_space>(<seq2seq4repair_space>isMock()<seq2seq4repair_space>)<seq2seq4repair_space>{" + ( hasReturn ? "return" : "" ) ) + "<seq2seq4repair_space>createMock()." ) + methodName ) + "(" ) + ( argsBuilder . toString ( ) ) ) + ");<seq2seq4repair_space>}" ) ) ; w . println ( ( ( "java.lang.String<seq2seq4repair_space>subPath<seq2seq4repair_space>=<seq2seq4repair_space>\"" + ( ( method . getAnnotation ( Path . class ) ) != null ? method . getAnnotation ( Path . class ) . value ( ) : "" ) ) + "\";" ) ) ; w . println ( "final<seq2seq4repair_space>Map<java.lang.String,<seq2seq4repair_space>java.lang.String>additionalHeaders<seq2seq4repair_space>=<seq2seq4repair_space>new<seq2seq4repair_space>HashMap<>();" ) ; final String className = svcInf . getQualifiedName ( ) . toString ( ) ; boolean firstQueryParam = true ; final Types typeUtils = processingEnvironment . getTypeUtils ( ) ; final DeclaredType CollectionType ; { final Elements elementUtils = processingEnvironment . getElementUtils ( ) ; CollectionType = typeUtils . getDeclaredType ( elementUtils . getTypeElement ( Collection . class . getCanonicalName ( ) ) ) ; } String postParamName = null ; w . println ( "StringBuilder<seq2seq4repair_space>postBody<seq2seq4repair_space>=<seq2seq4repair_space>new<seq2seq4repair_space>StringBuilder();" ) ; for ( int i = 0 ; i < ( params . size ( ) ) ; i ++ ) { final VariableElement param = params . get ( i ) ; final TypeMirror paramType = param . asType ( ) ; String pname = "p" + i ; final QueryParam queryAnnotation = param . getAnnotation ( QueryParam . class ) ; final PathParam pathAnnotation = param . getAnnotation ( PathParam . class ) ; final HeaderParam headerAnnotation = param . getAnnotation ( HeaderParam . class ) ; if ( ( ( queryAnnotation != null ) || ( pathAnnotation != null ) ) || ( headerAnnotation != null ) ) { final boolean boxedCharacter = SerializerCreator . isBoxedCharacter ( paramType ) ; final boolean jsonPrimitive = ( SerializerCreator . isJsonPrimitive ( paramType ) ) || ( SerializerCreator . isBoxedPrimitive ( paramType ) ) ; final boolean jsonString = SerializerCreator . isJsonString ( paramType ) ; <START_BUG> if ( jsonPrimitive ) { <END_BUG> w . println ( "{" ) ; } else { w . println ( ( ( "if<seq2seq4repair_space>(" + pname ) + "<seq2seq4repair_space>!=<seq2seq4repair_space>null)<seq2seq4repair_space>{" ) ) ; } w . indent ( ) ; w . println ( "final<seq2seq4repair_space>StringBuilder<seq2seq4repair_space>param=<seq2seq4repair_space>new<seq2seq4repair_space>StringBuilder();" ) ; if ( boxedCharacter ) { w . println ( ( ( "param.append(" + pname ) + ".toString());" ) ) ; } else { if ( jsonPrimitive ) { if ( jsonString ) { w . println ( ( ( "param.append(" + pname ) + ");" ) ) ; } else { w . println ( ( ( "param.append(" + pname ) + "<seq2seq4repair_space>+<seq2seq4repair_space>\"\");" ) ) ; } } else { writeEncoded ( w , paramType , pname , serializerFields [ i ] ) ; } } w . println ( "<seq2seq4repair_space>" ) ; if ( queryAnnotation != null ) { if ( firstQueryParam ) { w . print ( "subPath<seq2seq4repair_space>+=<seq2seq4repair_space>\"?" ) ; firstQueryParam = false ; } else { w . print ( "subPath<seq2seq4repair_space>+=<seq2seq4repair_space>\"&" ) ; } w . println ( ( ( ( queryAnnotation . value ( ) ) + "=\"+param" ) + ".toString();" ) ) ; } if ( headerAnnotation != null ) { w . println ( ( ( "additionalHeaders.put(\"" + ( headerAnnotation . value ( ) ) ) + "\",<seq2seq4repair_space>param.toString());" ) ) ; } if ( pathAnnotation != null ) { final String pathVariable = ( "\\\\{" + ( pathAnnotation . value ( ) ) ) + "\\\\}" ; w . println ( ( ( "subPath<seq2seq4repair_space>=<seq2seq4repair_space>subPath.replaceFirst(\"" + pathVariable ) + "\",<seq2seq4repair_space>param.toString());" ) ) ; } w . outdent ( ) ; w . println ( "}" ) ; } else { if ( ( method . getAnnotation ( GET . class ) ) != null ) { throw new UnableToCompleteException ( ( ( ( ( ( ( "param<seq2seq4repair_space>type<seq2seq4repair_space>" + pname ) + "<seq2seq4repair_space>doesnt<seq2seq4repair_space>have<seq2seq4repair_space>a<seq2seq4repair_space>param<seq2seq4repair_space>annotation<seq2seq4repair_space>in<seq2seq4repair_space>" ) + className ) + "." ) + methodName ) + "<seq2seq4repair_space>Please<seq2seq4repair_space>use<seq2seq4repair_space>QueryParam,<seq2seq4repair_space>PathParam<seq2seq4repair_space>or<seq2seq4repair_space>HeaderParam" ) ) ; } if ( postParamName != null ) { throw new UnableToCompleteException ( ( ( ( ( ( ( ( ( "<seq2seq4repair_space>post<seq2seq4repair_space>param<seq2seq4repair_space>already<seq2seq4repair_space>set<seq2seq4repair_space>in<seq2seq4repair_space>" + className ) + "." ) + methodName ) + "<seq2seq4repair_space>" ) + postParamName ) + "," ) + pname ) + "<seq2seq4repair_space>only<seq2seq4repair_space>one<seq2seq4repair_space>post<seq2seq4repair_space>param<seq2seq4repair_space>is<seq2seq4repair_space>allowed." ) ) ; } writeBody ( w , paramType , pname , serializerFields [ i ] ) ; postParamName = pname ; } } final String methodType ; if ( ( method . getAnnotation ( POST . class ) ) != null ) { methodType = "POST" ; } else if ( ( method . getAnnotation ( PUT . class ) ) != null ) { methodType = "PUT" ; } else if ( ( method . getAnnotation ( DELETE . class ) ) != null ) { methodType = "DELETE" ; } else if ( ( method . getAnnotation ( GET . class ) ) != null ) { methodType = "GET" ; } else { throw new UnableToCompleteException ( ( ( ( "No<seq2seq4repair_space>accessor<seq2seq4repair_space>annotation<seq2seq4repair_space>on<seq2seq4repair_space>pubic<seq2seq4repair_space>method<seq2seq4repair_space>" + className ) + "." ) + methodName ) ) ; } writeCall ( w , resultType , resultField , containerClass , resultClassname , className , methodType ) ; if ( hasReturn ) { w . println ( ( ( "return<seq2seq4repair_space>(" + cast ) + ")<seq2seq4repair_space>result;" ) ) ; } w . outdent ( ) ; w . println ( "}<seq2seq4repair_space>catch<seq2seq4repair_space>(Exception<seq2seq4repair_space>ex)<seq2seq4repair_space>{" ) ; w . indent ( ) ; for ( TypeMirror exception : thrownTypes ) { String exName = exception . toString ( ) ; w . println ( ( ( ( ( "if<seq2seq4repair_space>(<seq2seq4repair_space>ex<seq2seq4repair_space>instanceof<seq2seq4repair_space>" + exName ) + "<seq2seq4repair_space>)<seq2seq4repair_space>throw<seq2seq4repair_space>(" ) + exName ) + ")<seq2seq4repair_space>ex;" ) ) ; } w . println ( "throw<seq2seq4repair_space>new<seq2seq4repair_space>RuntimeException(ex);" ) ; w . outdent ( ) ; w . println ( "}" ) ; w . outdent ( ) ; w . println ( "}"
public final class Target extends Terminus implements Encodable { public static final long DESCRIPTOR_LONG = 41L ; public static final String DESCRIPTOR_STRING = "amqp:target:list" ; public static final Target . Factory FACTORY = new Target . Factory ( ) ; @ Override public void encode ( Encoder encoder ) { } public static final class Factory implements DescribedTypeFactory { @ SuppressWarnings ( "unchecked" ) public Object create ( Object in ) throws DecodeException { List < Object > l = ( ( List < Object > ) ( in ) ) ; Target target = new Target ( ) ; switch ( 7 - ( l . size ( ) ) ) { case 0 : Object val0 = l . get ( 6 ) ; if ( ( val0 == null ) || ( val0 . getClass ( ) . isArray ( ) ) ) { target . setCapabilities ( ( ( String [ ] ) ( val0 ) ) ) ; } else { target . setCapabilities ( ( ( String ) ( val0 ) ) ) ; } case 1 : target . setDynamicNodeProperties ( ( ( Map < Object , Object > ) ( l . get ( 5 ) ) ) ) ; case 2 : target . setDynamic ( ( ( l . get ( 4 ) ) == null ? false : ( ( Boolean ) ( l . get ( 4 ) ) ) ) ) ; case 3 : target . setTimeout ( ( ( l . get ( 3 ) ) == null ? 0 : ( ( Integer ) ( l . get ( 3 ) ) ) ) ) ; case 4 : target . setExpiryPolicy ( ( ( l . get ( 2 ) ) == null ? TerminusExpiryPolicy . SESSION_END : TerminusExpiryPolicy . getEnum ( ( ( String ) ( l . get ( 2 ) ) ) ) ) ) ; case 5 : <START_BUG> target . setDurable ( ( ( l . get ( 1 ) ) == null ? TerminusDurability . NONE : TerminusDurability . get ( ( ( Byte ) ( l . get ( 1 ) ) ) ) ) ) ; <END_BUG> case 6 : target . setAddress ( ( ( String ) ( l . get ( 0 ) ) ) ) ; } return target ; } } @ Override public String toString ( ) { } No newline ; at end ; of file ; }
public class VerticalPartioningTripleStoreRWSmartLock implements TripleStore { private static Logger logger = Logger . getLogger ( VerticalPartioningTripleStoreRWSmartLock . class ) ; private final Map < Long , Multimap < Long , Long > > internalstore ; private final Map < Long , ReentrantReadWriteLock > predicatesLocks ; private final ReentrantReadWriteLock globalLock ; private final AtomicInteger triples ; public VerticalPartioningTripleStoreRWSmartLock ( ) { } private ReentrantReadWriteLock getLock ( final long p ) { } @ Override public boolean add ( final Triple t ) { } @ Override public Collection < Triple > addAll ( final Collection < Triple > triples ) { } @ Override public void remove ( final Triple t ) { } @ Override public Collection < Triple > getAll ( ) { } @ Override public Collection < Triple > getbySubject ( final long s ) { } @ Override public Collection < Triple > getbyPredicate ( final long p ) { Collection < Triple > result = null ; this . globalLock . readLock ( ) . lock ( ) ; Multimap < Long , Long > map = null ; try { map = this . internalstore . get ( p ) ; } catch ( final Exception e ) { VerticalPartioningTripleStoreRWSmartLock . logger . error ( "" , e ) ; } finally { this . globalLock . readLock ( ) . unlock ( ) ; if ( map == null ) { return new ArrayList < Triple > ( ) ; } } final ReentrantReadWriteLock lock = this . getLock ( p ) ; lock . writeLock ( ) . lock ( ) ; try { result = new ArrayList < Triple > ( ) ; for ( final Map . Entry < Long , Long > entry : map . entries ( ) ) { result . add ( new ImmutableTriple ( entry . getKey ( ) , p , entry . getValue ( ) ) ) ; } } catch ( final Exception e ) { VerticalPartioningTripleStoreRWSmartLock . logger . error ( "" , e ) ; } finally { <START_BUG> lock . readLock ( ) . unlock ( ) ; <END_BUG> } return result ; } @ Override public Collection < Triple > getbyObject ( final long o ) { } @ Override public long size ( ) { } @ Override public boolean isEmpty ( ) { } @ Override public void writeToFile ( final String file , final Dictionary dictionary ) { } @ Override public boolean contains ( final Triple triple ) { } @ Override public boolean contains ( final long s , final long p , final long o ) { } private boolean containsNoLock ( final long s , final long p , final long o ) { } @ Override public Multimap < Long , Long > getMultiMapForPredicate ( final long p ) { } @ Override public Collection < Long > getPredicates ( ) { } @ Override public void clear ( ) { } @ Override public void add ( final long s , final long p , final long o ) { } @ Override public int hashCode ( ) { } @ Override public boolean equals ( final Object obj ) { } }
public class PlayerTest { @ Test public void testConstructor ( ) { } @ Test public void testSetName ( ) { } @ Test public void testDealDamage ( ) { } @ Test public void testRunAttempt ( ) { Player p = new Player ( ) ; <START_BUG> Boolean bool = p . runAttempt ( ) ; <END_BUG> if ( bool ) { assertTrue ( true ) ; } else { assertTrue ( false ) ; } } @ Test public void testGetScore ( ) { } @ Test public void testGetRooms ( ) { } @ Test public void testGetMonstersDefeated ( ) { } @ Test public void testIncreaseScore ( ) { } @ Test public void testDefeatedMonster ( ) { } @ Test public void testClearedRoom ( ) { } }
public class StatefulComponentDescription extends SessionBeanComponentDescription { private static final Logger logger = Logger . getLogger ( StatefulComponentDescription . class ) ; private Method afterBegin ; private Method afterCompletion ; private Method beforeCompletion ; private final Set < StatefulComponentDescription . StatefulRemoveMethod > removeMethods = new HashSet < StatefulComponentDescription . StatefulRemoveMethod > ( ) ; private StatefulTimeoutInfo statefulTimeout ; private DefaultAccessTimeoutService defaultAccessTimeoutProvider ; private Map < Method , String > initMethods = new HashMap < Method , String > ( 0 ) ; public class StatefulRemoveMethod { private final MethodIdentifier methodIdentifier ; private final boolean retainIfException ; StatefulRemoveMethod ( final MethodIdentifier method , final boolean retainIfException ) { } public MethodIdentifier getMethodIdentifier ( ) { } public boolean isRetainIfException ( ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } } public StatefulComponentDescription ( final String componentName , final String componentClassName , final EjbJarDescription ejbJarDescription , final ServiceName deploymentUnitServiceName ) { } private void addInitMethodInvokingInterceptor ( ) { } private void addStatefulSessionSynchronizationInterceptor ( ) { } @ Override public ComponentConfiguration createConfiguration ( final ClassIndex classIndex ) { } @ Override public boolean allowsConcurrentAccess ( ) { } public Method getAfterBegin ( ) { } public Method getAfterCompletion ( ) { } public Method getBeforeCompletion ( ) { } @ Override public SessionBeanType getSessionBeanType ( ) { } public void setAfterBegin ( final Method afterBegin ) { } public void setAfterCompletion ( final Method afterCompletion ) { } public void setBeforeCompletion ( final Method afterCompletion ) { } @ Override protected void setupViewInterceptors ( EJBViewDescription view ) { super . setupViewInterceptors ( view ) ; this . addRemoveMethodInterceptor ( view ) ; this . addStatefulInstanceAssociatingInterceptor ( view ) ; this . addViewSerializationInterceptor ( view ) ; if ( view instanceof EJBViewDescription ) { EJBViewDescription ejbViewDescription = ( ( EJBViewDescription ) ( view ) ) ; <START_BUG> if ( ( ( ejbViewDescription . getMethodIntf ( ) ) == ( MethodIntf . REMOTE ) ) || ( ( ejbViewDescription . getMethodIntf ( ) ) == ( MethodIntf . REMOTE ) ) ) { <END_BUG> view . getConfigurators ( ) . add ( new ViewConfigurator ( ) { @ Override public void configure ( final DeploymentPhaseContext context , final ComponentConfiguration componentConfiguration , final ViewDescription description , final ViewConfiguration configuration ) throws DeploymentUnitProcessingException { configuration . setViewInstanceFactory ( new StatefulRemoteViewInstanceFactory ( componentConfiguration . getApplicationName ( ) , componentConfiguration . getModuleName ( ) , componentConfiguration . getComponentDescription ( ) . getModuleDescription ( ) . getDistinctName ( ) , componentConfiguration . getComponentName ( ) ) ) ; } } ) ; } } } @ Override protected ViewConfigurator getSessionBeanObjectViewConfigurator ( ) { } private void addViewSerializationInterceptor ( final ViewDescription view ) { } public void addRemoveMethod ( final MethodIdentifier removeMethod , final boolean retainIfException ) { } public Set < StatefulComponentDescription . StatefulRemoveMethod > getRemoveMethods ( ) { } public StatefulTimeoutInfo getStatefulTimeout ( ) { } public void setStatefulTimeout ( final StatefulTimeoutInfo statefulTimeout ) { } private void addStatefulInstanceAssociatingInterceptor ( final ViewDescription view ) { } private void addRemoveMethodInterceptor ( final ViewDescription view ) { } public void addInitMethod ( final Method method , final String createMethod ) { } public Map < Method , String > getInitMethods ( ) { } }
public class WsdlToDotnet extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File destFile = null ; private String language = "CS" ; private boolean server = false ; private String namespace = null ; private boolean failOnError = true ; protected String extraOptions = null ; private String protocol = null ; private boolean ideErrors = false ; private Vector schemas = new Vector ( ) ; private WsdlToDotnet . Schema wsdl = new WsdlToDotnet . Schema ( ) ; private WsdlToDotnet . Compiler compiler = null ; public static final String ERROR_DEST_FILE_IS_DIR = "destination<seq2seq4repair_space>file<seq2seq4repair_space>is<seq2seq4repair_space>a<seq2seq4repair_space>directory" ; public static final String ERROR_NO_DEST_FILE = "destination<seq2seq4repair_space>file<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>specified" ; public void setDestFile ( File destFile ) { } public void setUrl ( String url ) { } public void setSrcFile ( File srcFile ) { } public void setLanguage ( String language ) { } public void setServer ( boolean server ) { } public void setNamespace ( String namespace ) { } public void setFailOnError ( boolean failOnError ) { } public void setExtraOptions ( String extraOptions ) { } public void setIdeErrors ( boolean ideErrors ) { } public void setProtocol ( String protocol ) { } public void addSchema ( WsdlToDotnet . Schema source ) { } public void setMakeURL ( boolean b ) { } public void setCompiler ( WsdlToDotnet . Compiler compiler ) { } protected void validate ( ) throws BuildException { } public void execute ( ) throws BuildException { } private boolean isRebuildNeeded ( WsdlToDotnet . Schema schema , long destLastModified ) { } public static class Schema { private File file ; private String url ; private boolean makeURL = false ; public static final String ERROR_NONE_DECLARED = "One<seq2seq4repair_space>of<seq2seq4repair_space>file<seq2seq4repair_space>and<seq2seq4repair_space>url<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>set" ; public static final String ERROR_BOTH_DECLARED = "Only<seq2seq4repair_space>one<seq2seq4repair_space>of<seq2seq4repair_space>file<seq2seq4repair_space>or<seq2seq4repair_space>url<seq2seq4repair_space>can<seq2seq4repair_space>be<seq2seq4repair_space>set" ; public static final String ERROR_FILE_NOT_FOUND = "Not<seq2seq4repair_space>found:<seq2seq4repair_space>" ; public static final String ERROR_FILE_IS_DIR = "File<seq2seq4repair_space>is<seq2seq4repair_space>a<seq2seq4repair_space>directory:<seq2seq4repair_space>" ; public static final String ERROR_NO_URL_CONVERT = "Could<seq2seq4repair_space>not<seq2seq4repair_space>URL<seq2seq4repair_space>convert<seq2seq4repair_space>" ; public void validate ( ) { } public String evaluate ( ) { validate ( ) ; if ( ( url ) != null ) { return getUrl ( ) ; } if ( makeURL ) { try { <START_BUG> return file . toURL ( ) . toExternalForm ( ) ; <END_BUG> } catch ( MalformedURLException e ) { throw new BuildException ( ( ( WsdlToDotnet . Schema . ERROR_NO_URL_CONVERT ) + ( file ) ) ) ; } } return file . toString ( ) ; } public File getFile ( ) { } public void setFile ( File file ) { } public String getUrl ( ) { } public void setUrl ( String url ) { } public boolean isMakeURL ( ) { } public void setMakeURL ( boolean makeURL ) { } public long getTimestamp ( ) { } } public static class Compiler extends EnumeratedAttribute { public static final String COMPILER_MS = "microsoft" ; public static final String COMPILER_MONO = "mono" ; public static final String COMPILER_MS_ON_MONO = "microsoft-on-mono" ; String [ ] compilers = new String [ ] { WsdlToDotnet . Compiler . COMPILER_MS , WsdlToDotnet . Compiler . COMPILER_MONO , WsdlToDotnet . Compiler . COMPILER_MS_ON_MONO } ; public static final String EXE_WSDL = "wsdl" ; public static final String EXE_MONO = "mono" ; String [ ] compilerExecutables = new String [ ] { WsdlToDotnet . Compiler . EXE_WSDL , WsdlToDotnet . Compiler . EXE_WSDL , WsdlToDotnet . Compiler . EXE_MONO } ; String [ ] [ ] extraCompilerArgs = new String [ ] [ ] { new String [ ] { } , new String [ ] { } , new String [ ] { ( WsdlToDotnet . Compiler . EXE_WSDL ) + ".exe" } } ; boolean [ ] absoluteFiles = new boolean [ ] { true , false , true } ; public String [ ] getValues ( ) { } public static WsdlToDotnet . Compiler createDefaultCompiler ( ) { } public String getCommand ( ) { } public String [ ] getExtraArgs ( ) { } public boolean supportsAbsoluteFiles ( ) { } public void applyExtraArgs ( NetCommand command ) { } } }
public class DanceBotMediaPlayer implements MediaPlayer . OnCompletionListener , SeekBar . OnSeekBarChangeListener , MediaPlayerListener . OnMediaPlayerChangeListener { private static final String LOG_TAG = DanceBotMediaPlayer . class . getSimpleName ( ) ; private final Activity mActivity ; private TextView mSeekBarTotalTimeView ; private TextView mSeekBarCurrentTimeView ; private SeekBar mSeekBar ; private MediaPlayer mMediaPlayer ; private boolean mIsReady = false ; private boolean mIsPlaying = false ; private int mTotalTime ; private DanceBotMusicFile mMusicFile ; private Button mPlayPauseButton ; private MediaPlayerListener mEventListener ; public DanceBotMediaPlayer ( Activity activity , DanceBotMusicFile musicFile ) { } public void setEventListener ( MediaPlayerListener eventListener ) { } public void setMediaPlayerSeekBar ( SeekBar seekBar , TextView currentTime , TextView totalTime ) { } public void setPlayButton ( Button playButton ) { } private void setDataSource ( DanceBotMusicFile musicFile ) { } @ Override public void play ( ) { } @ Override public void pause ( ) { } @ Override public boolean isPlaying ( ) { } @ Override public Button getPlayButton ( ) { } @ Override public int getCurrentPosition ( ) { } @ Override public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) { <START_BUG> if ( ( mMediaPlayer ) != null ) { <END_BUG> if ( fromUser ) { mMediaPlayer . seekTo ( progress ) ; } } } @ Override public void onStartTrackingTouch ( SeekBar seekBar ) { } @ Override public void onStopTrackingTouch ( SeekBar seekBar ) { } @ Override public void onCompletion ( MediaPlayer mp ) { } public void cleanUp ( ) { } public void onStop ( ) { } }
public class TermsQueryBuilder implements QueryBuilder { private final Analyzer analyzer ; public TermsQueryBuilder ( Analyzer analyzer ) { } public Query getQuery ( Element e ) throws ParserException { String fieldName = DOMUtils . getAttributeWithInheritanceOrFail ( e , "fieldName" ) ; String text = DOMUtils . getNonBlankTextOrFail ( e ) ; BooleanQuery bq = new BooleanQuery ( DOMUtils . getAttribute ( e , "disableCoord" , false ) ) ; bq . setMinimumNumberShouldMatch ( DOMUtils . getAttribute ( e , "minimumNumberShouldMatch" , 0 ) ) ; try { TokenStream ts = analyzer . tokenStream ( fieldName , new StringReader ( text ) ) ; TermToBytesRefAttribute termAtt = ts . addAttribute ( TermToBytesRefAttribute . class ) ; Term term = null ; BytesRef bytes = termAtt . getBytesRef ( ) ; ts . reset ( ) ; while ( ts . incrementToken ( ) ) { termAtt . fillBytesRef ( ) ; <START_BUG> term = new Term ( fieldName , new BytesRef ( bytes ) ) ; <END_BUG> bq . add ( new org . apache . lucene . search . BooleanClause ( new org . apache . lucene . search . TermQuery ( term ) , Occur . SHOULD ) ) ; } ts . end ( ) ; ts . close ( ) ; } catch ( IOException ioe ) { throw new RuntimeException ( ( "Error<seq2seq4repair_space>constructing<seq2seq4repair_space>terms<seq2seq4repair_space>from<seq2seq4repair_space>index:" + ioe ) ) ; } bq . setBoost ( DOMUtils . getAttribute ( e , "boost" , 1.0F ) ) ; return bq ; } }
public class DefaultItemReuseStrategy implements IItemReuseStrategy { private static final long serialVersionUID = 1L ; private static final IItemReuseStrategy instance = new DefaultItemReuseStrategy ( ) ; public static IItemReuseStrategy getInstance ( ) { } public Iterator getItems ( final IItemFactory factory , final Iterator newModels , final Iterator existingItems ) { return new Iterator ( ) { private int index = 0 ; public void remove ( ) { throw new UnsupportedOperationException ( ) ; } public boolean hasNext ( ) { return newModels . hasNext ( ) ; } public Object next ( ) { Object next = newModels . next ( ) ; <START_BUG> if ( ! ( next instanceof IModel ) ) <END_BUG> throw new WicketRuntimeException ( ( ( ( "Expecting<seq2seq4repair_space>an<seq2seq4repair_space>instance<seq2seq4repair_space>of<seq2seq4repair_space>" + ( IModel . class . getName ( ) ) ) + ",<seq2seq4repair_space>got<seq2seq4repair_space>" ) + ( next . getClass ( ) . getName ( ) ) ) ) ; final IModel model = ( ( IModel ) ( next ) ) ; Item item = factory . newItem ( index , model ) ; ( index ) ++ ; return item ; } } ; } }
public class SelectionOnSingleNameReference extends SingleNameReference { public SelectionOnSingleNameReference ( char [ ] source , long pos ) { } public TypeBinding resolveType ( BlockScope scope ) { <START_BUG> binding = scope . getBinding ( token , ( ( ( VARIABLE ) | ( TypeConstants . TYPE ) ) | ( PACKAGE ) ) , this ) ; <END_BUG> if ( ! ( binding . isValidBinding ( ) ) ) { if ( ( binding ) instanceof ProblemFieldBinding ) { if ( ( ( ( ( binding . problemId ( ) ) == ( ProblemReasons . NotVisible ) ) || ( ( binding . problemId ( ) ) == ( ProblemReasons . InheritedNameHidesEnclosingName ) ) ) || ( ( binding . problemId ( ) ) == ( ProblemReasons . NonStaticReferenceInConstructorInvocation ) ) ) || ( ( binding . problemId ( ) ) == ( ProblemReasons . NonStaticReferenceInStaticContext ) ) ) { throw new SelectionNodeFound ( binding ) ; } scope . problemReporter ( ) . invalidField ( this , ( ( FieldBinding ) ( binding ) ) ) ; } else if ( ( binding ) instanceof ProblemReferenceBinding ) { if ( ( binding . problemId ( ) ) == ( ProblemReasons . NotVisible ) ) { throw new SelectionNodeFound ( binding ) ; } scope . problemReporter ( ) . invalidType ( this , ( ( TypeBinding ) ( binding ) ) ) ; } else { scope . problemReporter ( ) . unresolvableReference ( this , binding ) ; } throw new SelectionNodeFound ( ) ; } throw new SelectionNodeFound ( binding ) ; } public StringBuffer printExpression ( int indent , StringBuffer output ) { } }
public class Combo extends Composite { boolean noSelection ; boolean ignoreDefaultSelection ; boolean ignoreCharacter ; boolean ignoreModify ; boolean ignoreResize ; int scrollWidth ; int visibleCount = 5 ; int cbtHook ; public static final int LIMIT ; static final int CBID_LIST = 1000 ; static final int CBID_EDIT = 1001 ; static int EditProc ; static int ListProc ; static final int ComboProc ; static final TCHAR ComboClass = new TCHAR ( 0 , "COMBOBOX" , true ) ; public Combo ( Composite parent , int style ) { } public void add ( String string ) { } public void add ( String string , int index ) { } public void addModifyListener ( ModifyListener listener ) { } public void addSelectionListener ( SelectionListener listener ) { } public void addVerifyListener ( VerifyListener listener ) { } int callWindowProc ( int hwnd , int msg , int wParam , int lParam ) { if ( ( handle ) == 0 ) return 0 ; if ( hwnd == ( handle ) ) { switch ( msg ) { case OS . WM_SIZE : { ignoreResize = true ; int result = OS . CallWindowProc ( Combo . ComboProc , hwnd , msg , wParam , lParam ) ; ignoreResize = false ; <START_BUG> break ; <END_BUG> } } return OS . CallWindowProc ( Combo . ComboProc , hwnd , msg , wParam , lParam ) ; } int hwndText = OS . GetDlgItem ( handle , Combo . CBID_EDIT ) ; if ( hwnd == hwndText ) { return OS . CallWindowProc ( Combo . EditProc , hwnd , msg , wParam , lParam ) ; } int hwndList = OS . GetDlgItem ( handle , Combo . CBID_LIST ) ; if ( hwnd == hwndList ) { return OS . CallWindowProc ( Combo . ListProc , hwnd , msg , wParam , lParam ) ; } return OS . DefWindowProc ( hwnd , msg , wParam , lParam ) ; } int CBTProc ( int nCode , int wParam , int lParam ) { } boolean checkHandle ( int hwnd ) { } protected void checkSubclass ( ) { } static int checkStyle ( int style ) { } public void clearSelection ( ) { } public Point computeSize ( int wHint , int hHint , boolean changed ) { } public void copy ( ) { } void createHandle ( ) { } public void cut ( ) { } int defaultBackground ( ) { } void deregister ( ) { } public void deselect ( int index ) { } public void deselectAll ( ) { } boolean dragDetect ( int hwnd , int x , int y , boolean filter , boolean [ ] detect , boolean [ ] consume ) { } public String getItem ( int index ) { } public int getItemCount ( ) { } public int getItemHeight ( ) { } public String [ ] getItems ( ) { } boolean getListVisible ( ) { } String getNameText ( ) { } public int getOrientation ( ) { } public Point getSelection ( ) { } public int getSelectionIndex ( ) { } public String getText ( ) { } public int getTextHeight ( ) { } public int getTextLimit ( ) { } public int getVisibleItemCount ( ) { } boolean hasFocus ( ) { } public int indexOf ( String string ) { } public int indexOf ( String string , int start ) { } int mbcsToWcsPos ( int mbcsPos ) { } public void paste ( ) { } void register ( ) { } public void remove ( int index ) { } void remove ( int index , boolean notify ) { } public void remove ( int start , int end ) { } public void remove ( String string ) { } public void removeAll ( ) { } public void removeModifyListener ( ModifyListener listener ) { } public void removeSelectionListener ( SelectionListener listener ) { } public void removeVerifyListener ( VerifyListener listener ) { } boolean sendKeyEvent ( int type , int msg , int wParam , int lParam , Event event ) { } public void select ( int index ) { } void setBackgroundImage ( int hBitmap ) { } void setBackgroundPixel ( int pixel ) { } void setBounds ( int x , int y , int width , int height , int flags ) { } public void setFont ( Font font ) { } void setForegroundPixel ( int pixel ) { } public void setItem ( int index , String string ) { } public void setItems ( String [ ] items ) { } void setListVisible ( boolean visible ) { } public void setOrientation ( int orientation ) { } void setScrollWidth ( ) { } void setScrollWidth ( int scrollWidth ) { } void setScrollWidth ( TCHAR buffer , boolean grow ) { } void setScrollWidth ( int newWidth , boolean grow ) { } public void setSelection ( Point selection ) { } public void setText ( String string ) { } public void setTextLimit ( int limit ) { } void setToolTipText ( Shell shell , String string ) { } public void setVisibleItemCount ( int count ) { } void subclass ( ) { } boolean translateTraversal ( MSG msg ) { } boolean traverseEscape ( ) { } boolean traverseReturn ( ) { } void unsubclass ( ) { } String verifyText ( String string , int start , int end , Event keyEvent ) { } int wcsToMbcsPos ( int wcsPos ) { } int widgetExtStyle ( ) { } int widgetStyle ( ) { } TCHAR windowClass ( ) { } int windowProc ( ) { } int windowProc ( int hwnd , int msg , int wParam , int lParam ) { } LRESULT WM_CTLCOLOR ( int wParam , int lParam ) { }
public class GuidedDTDRLPersistence { public static GuidedDTDRLPersistence getInstance ( ) { } public String marshal ( GuidedDecisionTable52 dt ) { } void doActions ( List < BaseColumn > allColumns , List < ActionCol52 > actionCols , TemplateDataProvider rowDataProvider , List < DTCellValue52 > row , RuleModel rm ) { } private void doAction ( List < BaseColumn > allColumns , LimitedEntryBRLActionColumn column , List < GuidedDTDRLPersistence . LabelledAction > actions , TemplateDataProvider rowDataProvider , List < DTCellValue52 > row , RuleModel rm ) { } private void doAction ( List < BaseColumn > allColumns , BRLActionColumn column , List < GuidedDTDRLPersistence . LabelledAction > actions , TemplateDataProvider rowDataProvider , List < DTCellValue52 > row , RuleModel rm ) { } private boolean hasVariables ( BRLActionColumn column ) { } private void addAction ( IAction action , List < GuidedDTDRLPersistence . LabelledAction > actions ) { } private void doAction ( List < GuidedDTDRLPersistence . LabelledAction > actions , ActionWorkItemInsertFactCol52 ac , String cell ) { } private void doAction ( List < GuidedDTDRLPersistence . LabelledAction > actions , ActionInsertFactCol52 ac , String cell ) { } private void doAction ( List < GuidedDTDRLPersistence . LabelledAction > actions , ActionWorkItemSetFieldCol52 sf , String cell ) { } private void doAction ( List < GuidedDTDRLPersistence . LabelledAction > actions , ActionSetFieldCol52 sf , String cell ) { } private void doAction ( List < GuidedDTDRLPersistence . LabelledAction > actions , ActionRetractFactCol52 rf , String cell ) { } private void doAction ( List < GuidedDTDRLPersistence . LabelledAction > actions , ActionWorkItemCol52 wi , String cell ) { } private GuidedDTDRLPersistence . LabelledAction findByLabelledAction ( List < GuidedDTDRLPersistence . LabelledAction > actions , String boundName ) { } void doConditions ( List < BaseColumn > allColumns , List < CompositeColumn < ? > > conditionPatterns , TemplateDataProvider rowDataProvider , List < DTCellValue52 > row , List < List < DTCellValue52 > > data , RuleModel rm ) { } private void doCondition ( List < BaseColumn > allColumns , LimitedEntryBRLConditionColumn column , List < IPattern > patterns , TemplateDataProvider rowDataProvider , List < DTCellValue52 > row , RuleModel rm ) { } private void doCondition ( List < BaseColumn > allColumns , BRLConditionColumn column , List < IPattern > patterns , TemplateDataProvider rowDataProvider , List < DTCellValue52 > row , RuleModel rm ) { if ( ! ( hasVariables ( column ) ) ) { final BRLConditionVariableColumn variableColumn = column . getChildColumns ( ) . get ( 0 ) ; final int index = allColumns . indexOf ( variableColumn ) ; final DTCellValue52 dcv = row . get ( index ) ; <START_BUG> if ( dcv . getBooleanValue ( ) ) { <END_BUG> for ( IPattern pattern : column . getDefinition ( ) ) { patterns . add ( pattern ) ; } } } else { for ( IPattern pattern : column . getDefinition ( ) ) { boolean addPattern = true ; Map < InterpolationVariable , Integer > ivs = new HashMap < InterpolationVariable , Integer > ( ) ; RuleModelVisitor rmv = new RuleModelVisitor ( pattern , ivs ) ; rmv . visit ( pattern ) ; if ( ( ivs . size ( ) ) > 0 ) { for ( InterpolationVariable variable : ivs . keySet ( ) ) { String value = rowDataProvider . getTemplateKeyValue ( variable . getVarName ( ) ) ; if ( "" . equals ( value ) ) { addPattern = false ; break ; } } } if ( addPattern ) { patterns . add ( pattern ) ; } } } } private boolean hasVariables ( BRLConditionColumn column ) { } private void doCondition ( List < BaseColumn > allColumns , Pattern52 pattern , List < IPattern > patterns , List < DTCellValue52 > row , List < List < DTCellValue52 > > data , RuleModel rm ) { } String makeInList ( String cell ) { } private boolean no ( String operator ) { } private IPattern findByFactPattern ( List < IPattern > patterns , String boundName ) { } void doAttribs ( List < BaseColumn > allColumns , List < AttributeCol52 > attributeCols , List < DTCellValue52 > row , RuleModel rm ) { } void doMetadata ( List < BaseColumn > allColumns , List < MetadataCol52 > metadataCols , List < DTCellValue52 > row , RuleModel rm ) { } String getName ( String tableName , Number num ) { } boolean validCell ( String c ) { } private class LabelledAction { String boundName ; IAction action ; } private FieldConstraint makeSingleFieldConstraint ( ConditionCol52 c , String cell ) { } private FieldConstraint makeSingleFieldConstraint ( ConditionCol52 c , List < BaseColumn > allColumns , List < List < DTCellValue52 > > data ) { } }
@ Repository public class DbeExpendControlDaoImpl extends GenericDaoImpl < DbeExpendControl , DbeExpendLimitPK > implements DbeExpendControlDao { private static Logger logger = LoggerFactory . getLogger ( DbeExpendControlDaoImpl . class ) ; @ Override protected Class < DbeExpendControl > getDomainClass ( ) { } @ Override public List < DbeExpendControl > getExpendDataForUserAppProvCurrencyObCountry ( String urlEndUserId , BmService bmService , String appProviderId , BmCurrency bmCurrency , BmObCountry bmObCountry ) { } @ Override public void saveDbeExpendControl ( DbeExpendControl expendData ) { DbeExpendControlDaoImpl . logger . debug ( "Entering<seq2seq4repair_space>saveDbeExpendControl..." ) ; if ( ( ( ( ( ( ( ( expendData != null ) && ( ( expendData . getId ( ) ) != null ) ) && ( ( expendData . getId ( ) . getTxEndUserId ( ) ) != null ) ) && ( ( expendData . getId ( ) . getTxEndUserId ( ) . length ( ) ) > 0 ) ) && ( ( expendData . getId ( ) . getTxAppProviderId ( ) ) != null ) ) && ( ( expendData . getId ( ) . getTxAppProviderId ( ) . length ( ) ) > 0 ) ) && ( ( expendData . getId ( ) . getTxElType ( ) ) != null ) ) && ( ( expendData . getId ( ) . getTxElType ( ) . length ( ) ) > 0 ) ) { <START_BUG> this . getSession ( ) . saveOrUpdate ( expendData ) ; <END_BUG> } } }
public class RecoveryTest extends CompilerTest { @ Test public void testRcvBrokenClass ( ) { } @ Test public void testRcvBrokenMethod ( ) { } @ Test public void testRcvBrokenAttribute ( ) { } @ Test public void testRcvClassWithBrokenMembers ( ) { <START_BUG> compile ( "ClassWithBrokenMembers.ceylon" , 33 ) ; <END_BUG> } private void compile ( String ceylon , int expectedErrors ) { } private int getErrorCount ( DiagnosticCollector < JavaFileObject > errorCollector ) { } No newline ; at end ; of file ; }
public class ToggleSwitches extends Subsystem { private boolean indexerHasGoneUpSinceLastBottomPress ; private long lastIndexerBottomOn ; private Set < String > warnedFor = new HashSet < > ( ) ; private AnalogInput indexerBottom = new AnalogInput ( AnalogIoPorts . BOTTOM_INDEXER_SWITCH ) ; @ Override protected void initDefaultCommand ( ) { } private boolean proccessAnalogInput ( String name , AnalogInput input ) { } public boolean getIndexerTop ( ) { } public void indexerHasGoneUp ( ) { } public boolean getIndexerBottom ( ) { <START_BUG> boolean current = ! ( proccessAnalogInput ( "indexer-bottom" , indexerBottom ) ) ; <END_BUG> long now = System . currentTimeMillis ( ) ; if ( current ) { lastIndexerBottomOn = now ; indexerHasGoneUpSinceLastBottomPress = false ; } if ( ( ( lastIndexerBottomOn ) + 200 ) >= now ) { return true ; } else { return ! ( indexerHasGoneUpSinceLastBottomPress ) ; } } public boolean getVerticalClawTop ( ) { } }
public Object removeAttribute ( String name ) { } public Object getAttribute ( String name , boolean recurse ) { } public boolean hasAttribute ( String name , boolean recurse ) { } public Object setAttribute ( String name , Object value , boolean recurse ) { } public Object removeAttribute ( String name , boolean recurse ) { } public Object getAttributeOrFellow ( String name , boolean recurse ) { } public boolean hasAttributeOrFellow ( String name , boolean recurse ) { } public boolean addScopeListener ( ScopeListener listener ) { } public boolean removeScopeListener ( ScopeListener listener ) { } public void invalidate ( ) { } public boolean addClassResolver ( ClassResolver resolver ) { } public Class < ? > resolveClass ( String clsnm ) throws ClassNotFoundException { } public Class < ? > getZScriptClass ( String clsnm ) { } public Function getZScriptFunction ( String name , Class [ ] argTypes ) { } public Function getZScriptFunction ( Component comp , String name , Class [ ] argTypes ) { } public Object getZScriptVariable ( String name ) { } public Object getZScriptVariable ( Component comp , String name ) { } public Object getXelVariable ( String name ) { } public Object getXelVariable ( XelContext ctx , Object base , Object name , boolean ignoreExec ) { } public boolean addVariableResolver ( VariableResolver resolver ) { } public boolean removeVariableResolver ( VariableResolver resolver ) { } public boolean hasVariableResolver ( VariableResolver resolver ) { } public boolean addEventListener ( String evtnm , EventListener < ? extends Event > listener ) { } public boolean removeEventListener ( String evtnm , EventListener < ? extends Event > listener ) { } private static boolean duplicateListenerIgnored ( ) { } private static Boolean dupListenerIgnored ; public boolean isComplete ( ) { } public void setComplete ( boolean complete ) { } public void preInit ( ) { } public void init ( PageConfig config ) { } public void destroy ( ) { } public boolean isAlive ( ) { } public String getBeforeHeadTags ( ) { } public String getAfterHeadTags ( ) { } public void addBeforeHeadTags ( String tags ) { } public void addAfterHeadTags ( String tags ) { } public Collection < Object [ ] > getResponseHeaders ( ) { } public String getRootAttributes ( ) { } public void setRootAttributes ( String rootAttrs ) { } public String getContentType ( ) { } public void setContentType ( String contentType ) { } public String getWidgetClass ( ) { } public void setWidgetClass ( String wgtcls ) { } public String getDocType ( ) { } public void setDocType ( String docType ) { } public String getFirstLine ( ) { } public void setFirstLine ( String firstLine ) { } public Boolean getCacheable ( ) { } public void setCacheable ( Boolean cacheable ) { } public Boolean getAutomaticTimeout ( ) { } public void setAutomaticTimeout ( Boolean autoTimeout ) { } public final Desktop getDesktop ( ) { } public void redraw ( Writer out ) throws IOException { } private static Boolean _ie7compat ; private static Boolean _ieAutoCompat ; private static boolean shallIE7Compatible ( ) { } private static boolean shallDisableAutoCompatible ( ) { } public void interpret ( String zslang , String script , Scope scope ) { } public Interpreter getInterpreter ( String zslang ) { } public Collection < Interpreter > getLoadedInterpreters ( ) { } public String getZScriptLanguage ( ) { } public void setZScriptLanguage ( String zslang ) throws InterpreterNotFoundException { } public void addDeferredZScript ( Component parent , ZScript zscript ) { } private void evalDeferredZScripts ( Interpreter ip , String zslang ) { } private boolean isEffective ( Condition cond , Component comp ) { } public boolean isListenerAvailable ( String evtnm ) { } public Iterator < EventListener < ? extends Event > > getListenerIterator ( String evtnm ) { } public Iterable < EventListener < ? extends Event > > getEventListeners ( String evtnm ) { } public final Component getOwner ( ) { } public final void setOwner ( Component comp ) { } public void sessionWillPassivate ( Desktop desktop ) { } public void sessionDidActivate ( Desktop desktop ) { } private void willPassivate ( Collection c ) { } private void willPassivate ( Object o ) { } private void didActivate ( Collection c ) { } private void didActivate ( Object o ) { } public LanguageDefinition getLanguageDefinition ( ) { } public ComponentDefinitionMap getComponentDefinitionMap ( ) { } public ComponentDefinition getComponentDefinition ( String name , boolean recurse ) { } public ComponentDefinition getComponentDefinition ( Class < ? extends Component > cls , boolean recurse ) { } public Class < ? extends ExpressionFactory > getExpressionFactoryClass ( ) { } public void setExpressionFactoryClass ( Class < ? extends ExpressionFactory > expfcls ) { } public void addTemplate ( String name , Template template ) { } public void removeTemplate ( String name ) { } public Template getTemplate ( String name ) { <START_BUG> return _templates . get ( name ) ; <END_BUG> } private synchronized void writeObject ( ObjectOutputStream s ) throws IOException { } private void willSerialize ( Collection c ) { } private void willSerialize ( Object o ) { } private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { } private void didDeserialize ( Collection c ) { } private void didDeserialize ( Object o ) { } public String toString ( ) { } private class PageFuncMapper implements Serializable , FunctionMapper , FunctionMapperExt { public Function resolveFunction ( String prefix , String name ) throws XelException { } public Collection < String > getClassNames ( ) { } public Class resolveClass ( String name ) throws XelException { } } private static < E > Collection < E > combine ( Collection < E > first , Collection < E > second ) { } }
public class SubTypeSearchJob extends PatternSearchJob { SimpleSet indexes = new SimpleSet ( 5 ) ; public SubTypeSearchJob ( SearchPattern pattern , SearchParticipant participant , IJavaSearchScope scope , IndexQueryRequestor requestor ) { } public void finished ( ) { } public Index [ ] getIndexes ( IProgressMonitor progressMonitor ) { } public boolean search ( Index index , IProgressMonitor progressMonitor ) { if ( index == null ) return IJob . COMPLETE ; <START_BUG> if ( ( indexes . addIfNotIncluded ( index ) ) == index ) <END_BUG> index . startQuery ( ) ; return super . search ( index , progressMonitor ) ; } }
public class CodeSnippetQualifiedNameReference extends QualifiedNameReference implements InvocationSite , ProblemReasons , EvaluationConstants { EvaluationContext evaluationContext ; FieldBinding delegateThis ; public CodeSnippetQualifiedNameReference ( char [ ] [ ] sources , long [ ] positions , int sourceStart , int sourceEnd , EvaluationContext evaluationContext ) { } public TypeBinding checkFieldAccess ( BlockScope scope ) { } public void generateAssignment ( BlockScope currentScope , CodeStream codeStream , Assignment assignment , boolean valueRequired ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } public void generateCompoundAssignment ( BlockScope currentScope , CodeStream codeStream , Expression expression , int operator , int assignmentImplicitConversion , boolean valueRequired ) { } public void generatePostIncrement ( BlockScope currentScope , CodeStream codeStream , CompoundAssignment postIncrement , boolean valueRequired ) { } public FieldBinding generateReadSequence ( BlockScope currentScope , CodeStream codeStream ) { } public void generateReceiver ( CodeStream codeStream ) { } public TypeBinding getOtherFieldBindings ( BlockScope scope ) { } public TypeBinding getReceiverType ( BlockScope currentScope ) { } public void manageSyntheticAccessIfNecessary ( BlockScope currentScope , FieldBinding fieldBinding , TypeBinding lastReceiverType , int index , FlowInfo flowInfo ) { <START_BUG> if ( ! ( flowInfo . isReachable ( ) ) ) <END_BUG> return ; boolean useDelegate ; if ( index < 0 ) { useDelegate = ( fieldBinding == ( this . binding ) ) && ( ( this . delegateThis ) != null ) ; } else { useDelegate = ( index == 0 ) && ( ( this . delegateThis ) != null ) ; } if ( useDelegate ) { lastReceiverType = this . delegateThis . type ; } if ( ( ( ( ( fieldBinding . declaringClass ) != lastReceiverType ) && ( ! ( lastReceiverType . isArrayType ( ) ) ) ) && ( ( fieldBinding . declaringClass ) != null ) ) && ( ( fieldBinding . constant ( ) ) == ( Constant . NotAConstant ) ) ) { CompilerOptions options = currentScope . compilerOptions ( ) ; if ( ( ( ( ( options . targetJDK ) >= ( ClassFileConstants . JDK1_2 ) ) && ( ( ( ( ( options . complianceLevel ) >= ( ClassFileConstants . JDK1_4 ) ) || ( index < 0 ? fieldBinding != ( binding ) : index > 0 ) ) || ( ( this . indexOfFirstFieldBinding ) > 1 ) ) || ( ! ( fieldBinding . isStatic ( ) ) ) ) ) && ( ( fieldBinding . declaringClass . id ) != ( TypeIds . T_JavaLangObject ) ) ) || ( ! ( useDelegate ? new CodeSnippetScope ( currentScope ) . canBeSeenByForCodeSnippet ( fieldBinding . declaringClass , ( ( ReferenceBinding ) ( this . delegateThis . type ) ) ) : fieldBinding . declaringClass . canBeSeenBy ( currentScope ) ) ) ) { if ( index < 0 ) { if ( fieldBinding == ( this . binding ) ) { this . codegenBinding = currentScope . enclosingSourceType ( ) . getUpdatedFieldBinding ( fieldBinding , ( ( ReferenceBinding ) ( lastReceiverType . erasure ( ) ) ) ) ; } else { if ( ( this . otherCodegenBindings ) == ( this . otherBindings ) ) { int l = this . otherBindings . length ; System . arraycopy ( this . otherBindings , 0 , ( this . otherCodegenBindings = new FieldBinding [ l ] ) , 0 , l ) ; } this . otherCodegenBindings [ ( ( this . otherCodegenBindings . length ) - 1 ) ] = currentScope . enclosingSourceType ( ) . getUpdatedFieldBinding ( fieldBinding , ( ( ReferenceBinding ) ( lastReceiverType . erasure ( ) ) ) ) ; } } if ( index == 0 ) { this . codegenBinding = currentScope . enclosingSourceType ( ) . getUpdatedFieldBinding ( fieldBinding , ( ( ReferenceBinding ) ( lastReceiverType . erasure ( ) ) ) ) ; } else { if ( ( this . otherCodegenBindings ) == ( this . otherBindings ) ) { int l = this . otherBindings . length ; System . arraycopy ( this . otherBindings , 0 , ( this . otherCodegenBindings = new FieldBinding [ l ] ) , 0 , l ) ; } this . otherCodegenBindings [ ( index - 1 ) ] = currentScope . enclosingSourceType ( ) . getUpdatedFieldBinding ( fieldBinding , ( ( ReferenceBinding ) ( lastReceiverType . erasure ( ) ) ) ) ; } } } } public TypeBinding reportError ( BlockScope scope ) { } public TypeBinding resolveTypeVisibility ( BlockScope scope ) { } }
