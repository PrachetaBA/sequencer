class CompilationUnitResolver extends Compiler { static class IntArrayList { public int [ ] list = new int [ 5 ] ; public int length = 0 ; public void add ( int i ) { } } HashtableOfObject requestedSources ; HashtableOfObject requestedKeys ; DefaultBindingResolver . BindingTables bindingTables ; boolean hasCompilationAborted ; public CompilationUnitResolver ( INameEnvironment environment , IErrorHandlingPolicy policy , Map settings , ICompilerRequestor requestor , IProblemFactory problemFactory ) { } public void accept ( ISourceType [ ] sourceTypes , PackageBinding packageBinding , AccessRestriction accessRestriction ) { } protected void beginToCompile ( ICompilationUnit [ ] sourceUnits , String [ ] bindingKeys ) { int sourceLength = sourceUnits . length ; int keyLength = bindingKeys . length ; int maxUnits = sourceLength + keyLength ; this . totalUnits = 0 ; this . unitsToProcess = new CompilationUnitDeclaration [ maxUnits ] ; int index = 0 ; this . requestedSources = new HashtableOfObject ( ) ; for ( int i = 0 ; i < sourceLength ; i ++ ) { ICompilationUnit sourceUnit = sourceUnits [ i ] ; CompilationUnitDeclaration parsedUnit ; CompilationResult unitResult = new CompilationResult ( sourceUnit , ( index ++ ) , maxUnits , this . options . maxProblemsPerUnit ) ; try { if ( options . verbose ) { System . out . println ( Messages . bind ( Messages . compilation_request , new String [ ] { String . valueOf ( ( ( index ++ ) + 1 ) ) , String . valueOf ( maxUnits ) , new String ( sourceUnit . getFileName ( ) ) } ) ) ; } if ( ( this . totalUnits ) < ( this . parseThreshold ) ) { parsedUnit = this . parser . parse ( sourceUnit , unitResult ) ; } else { parsedUnit = this . parser . dietParse ( sourceUnit , unitResult ) ; } this . lookupEnvironment . buildTypeBindings ( parsedUnit , null ) ; addCompilationUnit ( sourceUnit , parsedUnit ) ; this . requestedSources . put ( unitResult . getFileName ( ) , sourceUnit ) ; } finally { sourceUnits [ i ] = null ; } } this . requestedKeys = new HashtableOfObject ( ) ; for ( int i = 0 ; i < keyLength ; i ++ ) { BindingKeyResolver resolver = new BindingKeyResolver ( bindingKeys [ i ] , this , this . lookupEnvironment ) ; resolver . parse ( true ) ; CompilationUnitDeclaration parsedUnit = resolver . getCompilationUnitDeclaration ( ) ; if ( parsedUnit != null ) { char [ ] fileName = parsedUnit . compilationResult . getFileName ( ) ; Object existing = this . requestedKeys . get ( fileName ) ; if ( existing == null ) this . requestedKeys . put ( fileName , resolver ) ; else if ( existing instanceof ArrayList ) ( ( ArrayList ) ( existing ) ) . add ( resolver ) ; else { ArrayList list = new ArrayList ( ) ; list . add ( existing ) ; list . add ( resolver ) ; this . requestedKeys . put ( fileName , list ) ; } } else { <START_BUG> if ( resolver . isPackage ( ) ) { <END_BUG> char [ ] pkgName = CharOperation . concatWith ( resolver . compoundName ( ) , '.' ) ; this . requestedKeys . put ( pkgName , resolver ) ; } else { char [ ] key = resolver . getKey ( ) . toCharArray ( ) ; this . requestedKeys . put ( key , resolver ) ; } } } lookupEnvironment . completeTypeBindings ( ) ; } IBinding createBinding ( String key ) { } public static CompilationUnit convert ( CompilationUnitDeclaration compilationUnitDeclaration , char [ ] source , int apiLevel , Map options , boolean needToResolveBindings , WorkingCopyOwner owner , DefaultBindingResolver . BindingTables bindingTables , IProgressMonitor monitor ) { } protected static IErrorHandlingPolicy getHandlingPolicy ( ) { } protected static ICompilerRequestor getRequestor ( ) { } public void initializeParser ( ) { } public void process ( CompilationUnitDeclaration unit , int i ) { } protected void handleInternalException ( Throwable internalException , CompilationUnitDeclaration unit , CompilationResult result ) { } protected void handleInternalException ( org . eclipse . jdt . internal . compiler . problem . AbortCompilation abortException , CompilationUnitDeclaration unit ) { } public static void parse ( org . eclipse . jdt . core . ICompilationUnit [ ] compilationUnits , ASTRequestor astRequestor , int apiLevel , Map options , IProgressMonitor monitor ) { } public static CompilationUnitDeclaration parse ( ICompilationUnit sourceUnit , NodeSearcher nodeSearcher , Map settings ) { } public static void resolve ( org . eclipse . jdt . core . ICompilationUnit [ ] compilationUnits , String [ ] bindingKeys , ASTRequestor requestor , int apiLevel , Map options , IJavaProject javaProject , WorkingCopyOwner owner , IProgressMonitor monitor ) { } public static CompilationUnitDeclaration resolve ( ICompilationUnit sourceUnit , IJavaProject javaProject , NodeSearcher nodeSearcher , Map options , WorkingCopyOwner owner , IProgressMonitor monitor ) throws JavaModelException { } public static IBinding [ ] resolve ( final IJavaElement [ ] elements , int apiLevel , Map compilerOptions , IJavaProject javaProject , WorkingCopyOwner owner , IProgressMonitor monitor ) { } public void removeUnresolvedBindings ( CompilationUnitDeclaration compilationUnitDeclaration ) { } private void removeUnresolvedBindings ( TypeDeclaration type ) { } private void resolve ( org . eclipse . jdt . core . ICompilationUnit [ ] compilationUnits , String [ ] bindingKeys , ASTRequestor astRequestor , int apiLevel , Map compilerOptions , WorkingCopyOwner owner , IProgressMonitor monitor ) { } private void reportBinding ( Object key , ASTRequestor astRequestor , WorkingCopyOwner owner , CompilationUnitDeclaration unit ) { } private CompilationUnitDeclaration resolve ( CompilationUnitDeclaration unit , ICompilationUnit sourceUnit , NodeSearcher nodeSearcher , boolean verifyMethods , boolean analyzeCode , boolean generateCode ) { } public CompilationUnitDeclaration resolve ( ICompilationUnit sourceUnit , boolean verifyMethods , boolean analyzeCode , boolean generateCode ) { }
private static final String KEYWORD_ADD = "ADD" ; private static final String KEYWORD_PUT = "PUT" ; private static final String KEYWORD_REMOVE = "REMOVE" ; private static final String KEYWORD_INCREMENT = "INCREMENT" ; private static final String KEYWORD_MERGE = "MERGE" ; private static final String KEYWORD_UPSERT = "UPSERT" ; private static final Object EMPTY_VALUE = new Object ( ) ; private Map < String , Object > setEntries = new LinkedHashMap < String , Object > ( ) ; private List < OPair < String , Object > > addEntries = new ArrayList < OPair < String , Object > > ( ) ; private Map < String , OPair < String , Object > > putEntries = new LinkedHashMap < String , OPair < String , Object > > ( ) ; private List < OPair < String , Object > > removeEntries = new ArrayList < OPair < String , Object > > ( ) ; private Map < String , Number > incrementEntries = new LinkedHashMap < String , Number > ( ) ; private ODocument merge = null ; private String lockStrategy = "NONE" ; private OReturnHandler returnHandler = new ORecordCountHandler ( ) ; private OQuery < ? > query ; private OSQLFilter compiledFilter ; private String subjectName ; private OCommandParameters parameters ; private boolean upsertMode = false ; private boolean isUpsertAllowed = false ; private boolean updated = false ; @ SuppressWarnings ( "unchecked" ) public OCommandExecutorSQLUpdate parse ( final OCommandRequest iRequest ) { } public Object execute ( final Map < Object , Object > iArgs ) { } @ SuppressWarnings ( "unchecked" ) public boolean result ( final Object iRecord ) { } @ Override public String getSyntax ( ) { } @ Override public void end ( ) { } @ Override public int getSecurityOperationType ( ) { } protected void parseMerge ( ) { } protected String getBlock ( String fieldValue ) { } protected void parseReturn ( ) throws OCommandSQLParsingException { } private boolean handleContent ( ODocument record ) { } private boolean handleMerge ( ODocument record ) { } private boolean handleSetEntries ( ODocument record ) { } private boolean handleIncrementEnries ( ODocument record ) { } private boolean handleAddEntries ( ODocument record ) { } @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private boolean handlePutEntries ( ODocument record ) { boolean updated = false ; if ( ! ( putEntries . isEmpty ( ) ) ) { for ( Map . Entry < String , OPair < String , Object > > entry : putEntries . entrySet ( ) ) { Object fieldValue = record . field ( entry . getKey ( ) ) ; if ( fieldValue == null ) { if ( ( record . getSchemaClass ( ) ) != null ) { final OProperty property = record . getSchemaClass ( ) . getProperty ( entry . getKey ( ) ) ; if ( ( property != null ) && ( ( ( property . getType ( ) ) != null ) && ( ( ! ( property . getType ( ) . equals ( EMBEDDEDMAP ) ) ) && ( ! ( property . getType ( ) . equals ( LINKMAP ) ) ) ) ) ) { throw new com . orientechnologies . orient . core . exception . OCommandExecutionException ( ( ( "field<seq2seq4repair_space>" + ( entry . getKey ( ) ) ) + "<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>defined<seq2seq4repair_space>as<seq2seq4repair_space>a<seq2seq4repair_space>map" ) ) ; } } fieldValue = new HashMap < String , Object > ( ) ; record . field ( entry . getKey ( ) , fieldValue ) ; } if ( fieldValue instanceof Map < ? , ? > ) { Map < String , Object > map = ( ( Map < String , Object > ) ( fieldValue ) ) ; OPair < String , Object > pair = entry . getValue ( ) ; Object value = extractValue ( record , pair ) ; if ( ( record . getSchemaClass ( ) ) != null ) { final OProperty property = record . getSchemaClass ( ) . getProperty ( entry . getKey ( ) ) ; if ( ( ( property != null ) && ( property . getType ( ) . equals ( LINKMAP ) ) ) && ( ! ( value instanceof OIdentifiable ) ) ) { throw new com . orientechnologies . orient . core . exception . OCommandExecutionException ( ( ( "field<seq2seq4repair_space>" + ( entry . getKey ( ) ) ) + "<seq2seq4repair_space>defined<seq2seq4repair_space>of<seq2seq4repair_space>type<seq2seq4repair_space>LINKMAP<seq2seq4repair_space>accept<seq2seq4repair_space>only<seq2seq4repair_space>link<seq2seq4repair_space>values" ) ) ; } } <START_BUG> if ( ( LINKMAP . equals ( record . fieldType ( entry . getKey ( ) ) ) ) && ( ! ( value instanceof OIdentifiable ) ) ) { <END_BUG> map = new com . orientechnologies . orient . core . db . record . OTrackedMap ( record , map , Object . class ) ; record . field ( entry . getKey ( ) , map , EMBEDDEDMAP ) ; } map . put ( pair . getKey ( ) , value ) ; updated = true ; } } } return updated ; } private boolean handleRemoveEntries ( ODocument record ) { } private boolean removeFromCollection ( boolean updated , Object value , Collection < ? > collection ) { } private boolean removeFromMap ( boolean updated , Object value , Map < ? , ? > map ) { } private boolean removeFromBag ( ODocument record , boolean updated , Object value , ORidBag bag ) { } private boolean removeSingleValueFromBag ( ORidBag bag , Object value , ODocument record ) { } private Object extractValue ( ODocument record , OPair < String , Object > entry ) { } private void parseAddFields ( ) { } private void parsePutFields ( ) { } private void parseRemoveFields ( ) { } private void parseIncrementFields ( ) { } }
public class GenericController extends AbstractTestElement implements Serializable , Controller , PerThreadClonable { protected List subControllersAndSamplers = new ArrayList ( ) ; protected int current ; protected Iterator controlIt ; private List configs = new LinkedList ( ) ; private boolean returnedNull = false ; private boolean done = false ; private boolean timeForNext = false ; private List assertions = new LinkedList ( ) ; public GenericController ( ) { } public boolean isNextFirst ( ) { } protected List getConfigElements ( ) { } private void addConfigElement ( TestElement el ) { } public void initialize ( ) { } public void reInitialize ( ) { } protected void removeCurrentController ( ) { } protected void resetCurrent ( ) { } protected void incrementCurrent ( ) { } protected boolean hasNextAtEnd ( ) { } protected void nextAtEnd ( ) { } public boolean hasNext ( ) { } protected void currentHasNextIsFalse ( ) { } protected boolean shortCircuitIsDone ( ) { } protected void setShortCircuit ( boolean done ) { } public boolean isDone ( ) { } protected TestElement getCurrentController ( ) { } protected List getSubControllers ( ) { } public void addTestElement ( TestElement child ) { } private void addController ( TestElement child ) { } public Sampler next ( ) { } public static class Test extends TestCase { public Test ( String name ) { } public void testProcessing ( ) throws Exception { GenericController controller = new GenericController ( ) ; GenericController sub_1 = new GenericController ( ) ; sub_1 . addTestElement ( makeSampler ( "one" ) ) ; sub_1 . addTestElement ( makeSampler ( "two" ) ) ; controller . addTestElement ( sub_1 ) ; controller . addTestElement ( makeSampler ( "three" ) ) ; GenericController sub_2 = new GenericController ( ) ; GenericController sub_3 = new GenericController ( ) ; sub_2 . addTestElement ( makeSampler ( "four" ) ) ; sub_3 . addTestElement ( makeSampler ( "five" ) ) ; sub_3 . addTestElement ( makeSampler ( "six" ) ) ; sub_2 . addTestElement ( sub_3 ) ; sub_2 . addTestElement ( makeSampler ( "seven" ) ) ; controller . addTestElement ( sub_2 ) ; String [ ] order = new String [ ] { "one" , "two" , "three" , "four" , "five" , "six" , "seven" } ; int counter = 7 ; for ( int i = 0 ; i < 2 ; i ++ ) { assertEquals ( 7 , counter ) ; counter = 0 ; while ( controller . hasNext ( ) ) { TestElement sampler = controller . next ( ) ; <START_BUG> assertEquals ( order [ ( counter ++ ) ] , sampler . getProperty ( NAME ) ) ; <END_BUG> } } } private TestElement makeSampler ( String name ) { } class TestSampler extends AbstractSampler implements PerSampleClonable { public void addCustomTestElement ( TestElement t ) { } public SampleResult sample ( Entry e ) { } } } }
class ASTConverter { private AST ast ; private char [ ] compilationUnitSource ; private Scanner scanner ; private boolean resolveBindings ; private Set pendingThisExpressionScopeResolution ; private Set pendingNameScopeResolution ; public ASTConverter ( Map options , boolean resolveBindings ) { } public void setAST ( AST ast ) { } public CompilationUnit convert ( CompilationUnitDeclaration unit , char [ ] source ) { } public PackageDeclaration convertPackage ( CompilationUnitDeclaration compilationUnitDeclaration ) { } public ImportDeclaration convertImport ( ImportReference importReference ) { } public TypeDeclaration convert ( org . eclipse . jdt . internal . compiler . ast . TypeDeclaration typeDeclaration ) { } private void buildBodyDeclarations ( org . eclipse . jdt . internal . compiler . ast . TypeDeclaration typeDeclaration , TypeDeclaration typeDecl ) { } private void checkAndAddMultipleFieldDeclaration ( FieldDeclaration [ ] fields , int index , List bodyDeclarations ) { } private void checkAndAddMultipleLocalDeclaration ( Statement [ ] stmts , int index , List blockStatements ) { } public Name convert ( TypeReference typeReference ) { } public SimpleName convert ( SingleNameReference nameReference ) { } public Name convert ( QualifiedNameReference nameReference ) { } private QualifiedName setQualifiedNameNameAndSourceRanges ( char [ ] [ ] typeName , long [ ] positions , AstNode node ) { } public Expression convert ( ThisReference reference ) { <START_BUG> if ( reference == ( ThisImplicit ) ) { <END_BUG> return null ; } else if ( reference instanceof QualifiedSuperReference ) { return convert ( ( ( QualifiedSuperReference ) ( reference ) ) ) ; } else if ( reference instanceof QualifiedThisReference ) { return convert ( ( ( QualifiedThisReference ) ( reference ) ) ) ; } else { ThisExpression thisExpression = this . ast . newThisExpression ( ) ; thisExpression . setSourceRange ( reference . sourceStart , ( ( ( reference . sourceEnd ) - ( reference . sourceStart ) ) + 1 ) ) ; if ( this . resolveBindings ) { recordNodes ( thisExpression , reference ) ; recordPendingThisExpressionScopeResolution ( thisExpression ) ; } return thisExpression ; } } public ThisExpression convert ( QualifiedThisReference reference ) { } public Name convert ( QualifiedSuperReference reference ) { } public ArrayAccess convert ( ArrayReference reference ) { } public Expression convert ( FieldReference reference ) { } public Expression convert ( Reference reference ) { } public Name convert ( NameReference reference ) { } public TypeDeclaration convert ( MemberTypeDeclaration typeDeclaration ) { } private void completeRecord ( ArrayType arrayType , AstNode astNode ) { } public Type convertType ( TypeReference typeReference ) { } public MethodDeclaration convert ( AbstractMethodDeclaration methodDeclaration ) { } public Expression convert ( org . eclipse . jdt . internal . compiler . ast . Expression expression ) { } public ParenthesizedExpression convertToParenthesizedExpression ( org . eclipse . jdt . internal . compiler . ast . Expression expression ) { } public ClassInstanceCreation convert ( AllocationExpression expression ) { } public ClassInstanceCreation convert ( AnonymousLocalTypeDeclaration expression ) { } private void buildBodyDeclarations ( AnonymousLocalTypeDeclaration expression , AnonymousClassDeclaration anonymousClassDeclaration ) { } public ArrayCreation convert ( ArrayAllocationExpression expression ) { } public SingleVariableDeclaration convert ( Argument argument ) { } public ArrayInitializer convert ( org . eclipse . jdt . internal . compiler . ast . ArrayInitializer expression ) { } public Expression convert ( QualifiedAllocationExpression expression ) { } public Assignment convert ( org . eclipse . jdt . internal . compiler . ast . Assignment expression ) { } public Assignment convert ( CompoundAssignment expression ) { } public PrefixExpression convert ( org . eclipse . jdt . internal . compiler . ast . PrefixExpression expression ) { } public PostfixExpression convert ( org . eclipse . jdt . internal . compiler . ast . PostfixExpression expression ) { } public CastExpression convert ( org . eclipse . jdt . internal . compiler . ast . CastExpression expression ) { } public Type convertToType ( NameReference reference ) { } public Expression convert ( ClassLiteralAccess expression ) { } public BooleanLiteral convert ( FalseLiteral expression ) { } public BooleanLiteral convert ( TrueLiteral expression ) { } public NullLiteral convert ( org . eclipse . jdt . internal . compiler . ast . NullLiteral expression ) { } public CharacterLiteral convert ( CharLiteral expression ) { } public NumberLiteral convert ( DoubleLiteral expression ) { } public NumberLiteral convert ( FloatLiteral expression ) { } public NumberLiteral convert ( IntLiteral expression ) { } public NumberLiteral convert ( IntLiteralMinValue expression ) { } public NumberLiteral convert ( LongLiteral expression ) { } public NumberLiteral convert ( LongLiteralMinValue expression ) { } public StringLiteral convert ( org . eclipse . jdt . internal . compiler . ast . StringLiteral expression ) { } public StringLiteral convert ( ExtendedStringLiteral expression ) { } public Expression convert ( BinaryExpression expression ) { } public PrefixExpression convert ( UnaryExpression expression ) { } public InstanceofExpression convert ( InstanceOfExpression expression ) { } public ConditionalExpression convert ( org . eclipse . jdt . internal . compiler . ast . ConditionalExpression expression ) { } public Expression convert ( MessageSend expression ) { } public Expression convert ( AND_AND_Expression expression ) { } public Expression convert ( EqualExpression expression ) { } public Expression convert ( OR_OR_Expression expression ) { } public Statement convert ( Statement statement ) { } public AssertStatement convert ( org . eclipse . jdt . internal . compiler . ast . AssertStatement statement ) { } public Block convert ( org . eclipse . jdt . internal . compiler . ast . Block statement ) { } public BreakStatement convert ( Break statement ) { } public ContinueStatement convert ( Continue statement ) { } public SwitchCase convert ( Case statement ) { } public SwitchCase convert ( DefaultCase statement ) { } public DoStatement convert ( org . eclipse . jdt . internal . compiler . ast . DoStatement statement ) { }
public ParameterMetaData getParameterMetaData ( ) throws SqlException { } private ParameterMetaData getParameterMetaDataX ( ) throws SqlException { } public void writeExecute ( Section section , ColumnMetaData parameterMetaData , Object [ ] inputs , int numInputColumns , boolean outputExpected , boolean chainedWritesFollowingSetLob ) throws SqlException { } public void readExecute ( ) throws SqlException { } public void writeOpenQuery ( Section section , int fetchSize , int resultSetType , int numInputColumns , ColumnMetaData parameterMetaData , Object [ ] inputs ) throws SqlException { } public void writeDescribeInput ( Section section ) throws SqlException { } public void readDescribeInput ( ) throws SqlException { } public void completeDescribeInput ( ColumnMetaData parameterMetaData , Sqlca sqlca ) { } public void writeDescribeOutput ( Section section ) throws SqlException { } public void readDescribeOutput ( ) throws SqlException { } public void completeDescribeOutput ( ColumnMetaData resultSetMetaData , Sqlca sqlca ) { } void writePrepareDescribeInputOutput ( ) throws SqlException { } void readPrepareDescribeInputOutput ( ) throws SqlException { } void writePrepareDescribeInput ( ) throws SqlException { } void readPrepareDescribeInput ( ) throws SqlException { } void completePrepareDescribe ( ) { } private Object [ ] expandObjectArray ( Object [ ] array , int newLength ) { } private boolean [ ] expandBooleanArray ( boolean [ ] array , int newLength ) { } void flowPrepareForSelectFromInsert ( ) throws SqlException { } void writePrepareDescribeInputOutput ( String sql , Section section ) throws SqlException { } void flowPrepareDescribeInputOutput ( ) throws SqlException { } void flowExecute ( int executeType ) throws SqlException { super . checkForClosedStatement ( ) ; super . clearWarningsX ( ) ; super . checkForAppropriateSqlMode ( executeType , sqlMode_ ) ; checkThatAllParametersAreSet ( ) ; if ( ( sqlMode_ ) == ( isUpdate__ ) ) { updateCount_ = 0 ; } else { updateCount_ = - 1 ; } Timer queryTimer = null ; QueryTimerTask queryTimerTask = null ; if ( ( timeout_ ) != 0 ) { queryTimer = new Timer ( ) ; queryTimerTask = new QueryTimerTask ( this , queryTimer ) ; queryTimer . schedule ( queryTimerTask , ( 1000 * ( timeout_ ) ) ) ; } try { agent_ . beginWriteChain ( this ) ; boolean piggybackedAutocommit = super . writeCloseResultSets ( true ) ; int numInputColumns = ( ( parameterMetaData_ ) != null ) ? parameterMetaData_ . getColumnCount ( ) : 0 ; boolean outputExpected = ( ( resultSetMetaData_ ) != null ) && ( ( resultSetMetaData_ . getColumnCount ( ) ) > 0 ) ; boolean chainAutoCommit = false ; boolean commitSubstituted = false ; boolean repositionedCursor = false ; ResultSet scrollableRS = null ; switch ( sqlMode_ ) { case isUpdate__ : if ( ( positionedUpdateCursorName_ ) != null ) { scrollableRS = sectionManager_ . getPositionedUpdateResultSet ( positionedUpdateCursorName_ ) ; } if ( ( scrollableRS != null ) && ( ! ( scrollableRS . isRowsetCursor_ ) ) ) { repositionedCursor = scrollableRS . repositionScrollableResultSetBeforeJDBC1PositionedUpdateDelete ( ) ; if ( ! repositionedCursor ) { scrollableRS = null ; } } chainAutoCommit = ( connection_ . willAutoCommitGenerateFlow ( ) ) && ( isAutoCommittableStatement_ ) ; if ( ( ( sqlUpdateMode_ ) == ( isInsertSql__ ) ) && ( ( generatedKeysColumnNames_ ) != null ) ) { writeOpenQuery ( section_ , fetchSize_ , resultSetType_ , numInputColumns , parameterMetaData_ , parameters_ ) ; } else { boolean chainOpenQueryForAutoGeneratedKeys = ( ( sqlUpdateMode_ ) == ( isInsertSql__ ) ) && ( ( autoGeneratedKeys_ ) == ( java . sql . Statement . RETURN_GENERATED_KEYS ) ) ; writeExecute ( section_ , parameterMetaData_ , parameters_ , numInputColumns , outputExpected , ( chainAutoCommit || chainOpenQueryForAutoGeneratedKeys ) ) ; if ( chainOpenQueryForAutoGeneratedKeys ) { prepareAutoGeneratedKeysStatement ( ) ; writeOpenQuery ( section_ , fetchSize_ , resultSetType_ ) ; } } if ( chainAutoCommit ) { if ( ( agent_ . accumulatedReadExceptions_ ) != null ) { connection_ . writeCommitSubstitute_ ( ) ; commitSubstituted = true ; } else { connection_ . writeCommit ( ) ; } } break ; case isQuery__ : writeOpenQuery ( section_ , fetchSize_ , resultSetType_ , numInputColumns , parameterMetaData_ , parameters_ ) ; break ; case isCall__ : writeExecuteCall ( outputRegistered_ , null , section_ , fetchSize_ , false , resultSetType_ , parameterMetaData_ , parameters_ ) ; break ; } agent_ . flow ( this ) ; super . readCloseResultSets ( true ) ; if ( piggybackedAutocommit ) { connection_ . completeTransactionStart ( ) ; } <START_BUG> super . markResultSetsClosed ( ) ; <END_BUG> switch ( sqlMode_ ) { case isUpdate__ : if ( ( scrollableRS != null ) && ( ! ( scrollableRS . isRowsetCursor_ ) ) ) { scrollableRS . readPositioningFetch_ ( ) ; } if ( ( ( sqlUpdateMode_ ) == ( isInsertSql__ ) ) && ( ( generatedKeysColumnNames_ ) != null ) ) { readOpenQuery ( ) ; if ( ( resultSet_ ) != null ) { generatedKeysResultSet_ = resultSet_ ; resultSet_ = null ; updateCount_ = 1 ; } } else { readExecute ( ) ; if ( ( ( sqlUpdateMode_ ) == ( isInsertSql__ ) ) && ( ( autoGeneratedKeys_ ) == ( java . sql . Statement . RETURN_GENERATED_KEYS ) ) ) { readPrepareAutoGeneratedKeysStatement ( ) ; preparedStatementForAutoGeneratedKeys_ . readOpenQuery ( ) ; generatedKeysResultSet_ = preparedStatementForAutoGeneratedKeys_ . resultSet_ ; preparedStatementForAutoGeneratedKeys_ . resultSet_ = null ; } } if ( chainAutoCommit ) { if ( commitSubstituted ) { connection_ . readCommitSubstitute_ ( ) ; } else { connection_ . readCommit ( ) ; } } break ; case isQuery__ : try { readOpenQuery ( ) ; } catch ( DisconnectException dise ) { throw dise ; } catch ( SqlException e ) { throw e ; } if ( ( resultSet_ ) != null ) { resultSet_ . parseScrollableRowset ( ) ; mapCursorNameToResultSet ( ) ; } break ; case isCall__ : readExecuteCall ( ) ; break ; } try { agent_ . endReadChain ( ) ; } catch ( SqlException e ) { throw e ;
public class ScentedFilter extends VisualizationComponent implements ISpinnerListener { @ FXML protected AnchorPane root_anchorPane ; @ FXML protected Label param_label ; protected NumericSpinner min_spinner ; protected NumericSpinner max_spinner ; @ FXML protected VBox container_vbox ; @ FXML protected StackedBarChart < String , Number > barchart ; protected RangeSlider rangeSlider ; protected Slider slider ; protected XYChart . Series < String , Number > discardedDataSeries ; protected XYChart . Series < String , Number > inactiveDataSeries ; protected XYChart . Series < String , Number > activeDataSeries ; protected ScentedFilterOptionset options ; protected ScentedFilterDataset data ; protected boolean isAdjustedToExtrema ; protected Set < String > selectedBars ; @ Override public void initialize ( URL location , ResourceBundle resources ) { } protected void initSpinners ( ) { min_spinner = new NumericSpinner ( new BigDecimal ( 0 ) , new BigDecimal ( 1 ) ) ; max_spinner = new NumericSpinner ( new BigDecimal ( 0 ) , new BigDecimal ( 1 ) ) ; min_spinner . setId ( "min_spinner" ) ; max_spinner . setId ( "max_spinner" ) ; root_anchorPane . getChildren ( ) . add ( min_spinner ) ; root_anchorPane . getChildren ( ) . add ( max_spinner ) ; min_spinner . setPrefWidth ( 55 ) ; min_spinner . setLayoutX ( 25 ) ; min_spinner . setLayoutY ( 30 ) ; max_spinner . setPrefWidth ( 55 ) ; <START_BUG> max_spinner . setLayoutX ( 100 ) ; <END_BUG> max_spinner . setLayoutY ( 30 ) ; min_spinner . registerListener ( this ) ; max_spinner . registerListener ( this ) ; } protected void initSelection ( ) { } public void applyOptions ( ScentedFilterOptionset options ) { } protected void addEventHandlerToRangeSlider ( RangeSlider rs ) { } protected void addEventHandlerToSlider ( Slider s ) { } protected void updateControlValues ( RangeSlider rs ) { } protected void updateControlValues ( Slider s ) { } public void processSpinnerValue ( BigDecimal value , String id ) { } @ Override public void processSelectionManipulationRequest ( double minX , double minY , double maxX , double maxY ) { } @ Override public void processEndOfSelectionManipulation ( ) { } @ Override public Pair < Integer , Integer > provideOffsets ( ) { } @ Override public void processKeyPressedEvent ( KeyEvent ke ) { } @ Override public void processKeyReleasedEvent ( KeyEvent ke ) { } @ Override public void refresh ( ) { } @ Override protected Map < String , Integer > prepareOptionSet ( ) { } protected void setBarHighlighting ( Node node , boolean on , Color color ) { } @ Override public void resizeContent ( double width , double height ) { } public void refresh ( ScentedFilterDataset data ) { } public void adjustControlExtrema ( ArrayList < LDAConfiguration > ldaConfigurations ) { } public void adjustDerivedControlExtrema ( double [ ] derivedData ) { } protected XYChart . Series < String , Number > addParameterHistogramDataSeries ( double [ ] parameterBinList , final int numberOfBins , final int seriesIndex ) { } protected XYChart . Series < String , Number > generateParameterHistogramDataSeries ( double [ ] parameterBinList , final int numberOfBins ) { } protected void colorParameterHistogramBarchart ( StackedBarChart < String , Number > barchart , int seriesIndex ) { } public void addThresholdsToMap ( Map < String , Pair < Double , Double > > thresholdMap ) { } @ Override public void initHoverEventListeners ( ) { } @ Override public void highlightHoveredOverDataPoints ( Set < Integer > dataPointIDs , DatapointIDMode idMode ) { } protected boolean isBarToHighlight ( int barIndex , String seriesPraefix , Set < Integer > dataPointIDs ) { } @ Override public void removeHoverHighlighting ( ) { } protected void addHoverEventListenersToNode ( XYChart . Data < String , Number > bar ) { } @ Override public String getComponentIdentification ( ) { } }
public class Application { public long calcTimeExecution ( long start , long end ) { long totalTime = end - start ; NumberFormat formatter = new DecimalFormat ( "#0.00" ) ; <START_BUG> System . out . print ( ( ( "\n********<seq2seq4repair_space>Tempo<seq2seq4repair_space>de<seq2seq4repair_space>execução:<seq2seq4repair_space>" + ( formatter . format ( ( totalTime / 1000.0 ) ) ) ) + "<seq2seq4repair_space>segundos<seq2seq4repair_space>\n" ) ) ; <END_BUG> return totalTime ; } public static void main ( String [ ] args ) throws IOException , SQLException { } }
public class RenameFolderAction extends AbstractColumbaAction implements ISelectionListener { public RenameFolderAction ( FrameMediator frameMediator ) { } public void actionPerformed ( ActionEvent evt ) { } public void selectionChanged ( SelectionChangedEvent evt ) { <START_BUG> if ( ( ( ( org . columba . mail . gui . tree . selection . TreeSelectionChangedEvent ) ( evt ) ) . getSelected ( ) . length ) > 0 ) { <END_BUG> AbstractFolder folder = ( ( org . columba . mail . gui . tree . selection . TreeSelectionChangedEvent ) ( evt ) ) . getSelected ( ) [ 0 ] ; if ( ( folder != null ) && ( folder instanceof AbstractMessageFolder ) ) { IFolderItem item = folder . getConfiguration ( ) ; if ( item . getString ( "property" , "accessrights" ) . equals ( "user" ) ) { setEnabled ( true ) ; } else { setEnabled ( false ) ; } } } else { setEnabled ( false ) ; } } }
public class ResourceUrlEncodingFilter extends OncePerRequestFilter { private static final Log logger = LogFactory . getLog ( ResourceUrlEncodingFilter . class ) ; @ Override protected void doFilterInternal ( HttpServletRequest request , HttpServletResponse response , FilterChain filterChain ) throws IOException , ServletException { } private static class ResourceUrlEncodingResponseWrapper extends HttpServletResponseWrapper { private HttpServletRequest request ; private Integer indexLookupPath ; private ResourceUrlEncodingResponseWrapper ( HttpServletRequest request , HttpServletResponse wrapped ) { } @ Override public String encodeURL ( String url ) { } private ResourceUrlProvider getResourceUrlProvider ( ) { } private void initIndexLookupPath ( ResourceUrlProvider urlProvider ) { if ( ( this . indexLookupPath ) == null ) { String requestUri = urlProvider . getPathHelper ( ) . getRequestUri ( this . request ) ; String lookupPath = urlProvider . getPathHelper ( ) . getLookupPathForRequest ( this . request ) ; <START_BUG> this . indexLookupPath = requestUri . indexOf ( lookupPath ) ; <END_BUG> } } } }
public class TextFile extends File { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private String encoding = null ; public TextFile ( File filename , String encoding ) { } public TextFile ( File filename ) { } public TextFile ( String filename ) { } public TextFile ( String filename , String encoding ) { } public void setText ( String body ) { } public String getText ( ) { String lineEnd = System . getProperty ( "line.separator" ) ; <START_BUG> StringBuffer sb = new StringBuffer ( ) ; <END_BUG> Reader reader = null ; BufferedReader br = null ; try { if ( ( encoding ) == null ) { reader = new FileReader ( this ) ; } else { reader = new InputStreamReader ( new FileInputStream ( this ) , encoding ) ; } br = new BufferedReader ( reader ) ; String line = "NOTNULL" ; while ( line != null ) { line = br . readLine ( ) ; if ( line != null ) { sb . append ( ( line + lineEnd ) ) ; } } } catch ( IOException ioe ) { TextFile . log . error ( "" , ioe ) ; } finally { JOrphanUtils . closeQuietly ( br ) ; } return sb . toString ( ) ; } public String getEncoding ( ) { } public void setEncoding ( String string ) { } }
class CraftAsyncDebugger { private CraftAsyncDebugger next = null ; private final int expiry ; private final Plugin plugin ; private final Class < ? extends Runnable > clazz ; CraftAsyncDebugger ( final int expiry , final Plugin plugin , final Class < ? extends Runnable > clazz ) { } final CraftAsyncDebugger getNextHead ( final int time ) { } final CraftAsyncDebugger setNext ( final CraftAsyncDebugger next ) { } StringBuilder debugTo ( final StringBuilder string ) { for ( CraftAsyncDebugger next = this ; next != null ; next = next . next ) { <START_BUG> string . append ( plugin . getDescription ( ) . getName ( ) ) . append ( ':' ) . append ( clazz . getName ( ) ) . append ( '@' ) . append ( expiry ) . append ( ',' ) ; <END_BUG> } return string ; } }
public class DigestAlgorithm implements Algorithm { private static final int BYTE_MASK = 255 ; private static final int BUFFER_SIZE = 8192 ; private String algorithm = "MD5" ; private String provider = null ; private MessageDigest messageDigest = null ; private int readBufferSize = DigestAlgorithm . BUFFER_SIZE ; public void setAlgorithm ( String algorithm ) { } public void setProvider ( String provider ) { } public void initMessageDigest ( ) { } public boolean isValid ( ) { } public String getValue ( File file ) { } public String toString ( ) { <START_BUG> StringBuffer buf = new StringBuffer ( ) ; <END_BUG> buf . append ( "<DigestAlgorithm:" ) ; buf . append ( "algorithm=" ) . append ( algorithm ) ; buf . append ( ";provider=" ) . append ( provider ) ; buf . append ( ">" ) ; return buf . toString ( ) ; } }
public class GuildRoleUpdateHandler extends PacketHandler { public GuildRoleUpdateHandler ( ImplDiscordAPI api ) { } @ Override public void handle ( JSONObject packet ) { String guildId = packet . getString ( "guild_id" ) ; JSONObject roleJson = packet . getJSONObject ( "role" ) ; Server server = api . getServerById ( guildId ) ; final ImplRole role = ( ( ImplRole ) ( server . getRoleById ( roleJson . getString ( "id" ) ) ) ) ; String name = roleJson . getString ( "name" ) ; if ( ! ( role . getName ( ) . equals ( name ) ) ) { final String oldName = role . getName ( ) ; role . setName ( name ) ; listenerExecutorService . submit ( new Runnable ( ) { @ Override public void run ( ) { List < Listener > listeners = api . getListeners ( RoleChangeNameListener . class ) ; synchronized ( listeners ) { for ( Listener listener : listeners ) { ( ( RoleChangeNameListener ) ( listener ) ) . onRoleChangeName ( api , role , oldName ) ; } } } } ) ; } Permissions permissions = new ImplPermissions ( roleJson . getInt ( "permissions" ) ) ; if ( ! ( role . getPermissions ( ) . equals ( permissions ) ) ) { final Permissions oldPermissions = role . getPermissions ( ) ; role . setPermissions ( ( ( ImplPermissions ) ( permissions ) ) ) ; listenerExecutorService . submit ( new Runnable ( ) { @ Override public void run ( ) { List < Listener > listeners = api . getListeners ( RoleChangePermissionsListener . class ) ; synchronized ( listeners ) { for ( Listener listener : listeners ) { ( ( RoleChangePermissionsListener ) ( listener ) ) . onRoleChangePermissions ( api , role , oldPermissions ) ; } } } } ) ; } Color color = new Color ( roleJson . getInt ( "color" ) ) ; if ( ( role . getColor ( ) . getRGB ( ) ) != ( color . getRGB ( ) ) ) { final Color oldColor = role . getColor ( ) ; role . setColor ( color ) ; listenerExecutorService . submit ( new Runnable ( ) { @ Override public void run ( ) { List < Listener > listeners = api . getListeners ( RoleChangeColorListener . class ) ; synchronized ( listeners ) { for ( Listener listener : listeners ) { ( ( RoleChangeColorListener ) ( listener ) ) . onRoleChangeColor ( api , role , oldColor ) ; } } } } ) ; } <START_BUG> if ( ( role . getHoist ( ) ) != ( packet . getBoolean ( "hoist" ) ) ) { <END_BUG> role . setHoist ( ( ! ( role . getHoist ( ) ) ) ) ; listenerExecutorService . submit ( new Runnable ( ) { @ Override public void run ( ) { List < Listener > listeners = api . getListeners ( RoleChangeHoistListener . class ) ; synchronized ( listeners ) { for ( Listener listener : listeners ) { ( ( RoleChangeHoistListener ) ( listener ) ) . onRoleChangeHoist ( api , role , ( ! ( role . getHoist ( ) ) ) ) ; } } } } ) ; } synchronized ( Role . class ) { int position = roleJson . getInt ( "position" ) ; if ( ( role . getPosition ( ) ) != position ) { final int oldPosition = role . getPosition ( ) ; role . setPosition ( position ) ; listenerExecutorService . submit ( new Runnable ( ) { @ Override public void run ( ) { List < Listener > listeners = api . getListeners ( RoleChangePositionListener . class ) ; synchronized ( listeners ) { for ( Listener listener : listeners ) { ( ( RoleChangePositionListener ) ( listener ) ) . onRoleChangePosition ( api , role , oldPosition ) ; } } } } ) ; } } } }
public class Results extends ActionBarActivity { private ArrayList < Card > cards = new ArrayList < > ( ) ; public CardListView cardView ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( activity_results ) ; Toolbar toolbar = ( ( Toolbar ) ( findViewById ( toolbar ) ) ) ; <START_BUG> toolbar . setTitle ( second ) ; <END_BUG> presentIndicativeActive ( ) ; presentIndicativePassive ( ) ; imperfectIndicativeActive ( ) ; imperfectSubjunctiveActive ( ) ; imperfectIndicativePassive ( ) ; perfectIndicativeActive ( ) ; perfectIndicativePassive ( ) ; pluperfectIndicativeActive ( ) ; pluperfectSubjunctiveActive ( ) ; pluperfectIndicativePassive ( ) ; CardArrayAdapter mCardArrayAdapter = new CardArrayAdapter ( this , cards ) ; CardListView listView = ( ( CardListView ) ( findViewById ( list_view ) ) ) ; if ( listView != null ) { listView . setAdapter ( mCardArrayAdapter ) ; } } public void presentIndicativeActive ( ) { } public void presentIndicativePassive ( ) { } public void imperfectIndicativeActive ( ) { } public void imperfectIndicativePassive ( ) { } public void imperfectSubjunctiveActive ( ) { } public void perfectIndicativeActive ( ) { } public void perfectIndicativePassive ( ) { } public void pluperfectIndicativeActive ( ) { } public void pluperfectSubjunctiveActive ( ) { } public void pluperfectIndicativePassive ( ) { } No newline ; at end ; of file ; }
public class ChangePassword extends ScarabTemplateAction { public void doChangepassword ( RunData data , TemplateContext context ) throws Exception { String template = getCurrentTemplate ( data , null ) ; String nextTemplate = getNextTemplate ( data , template ) ; IntakeTool intake = getIntakeTool ( context ) ; if ( intake . isAllValid ( ) ) { Object user = data . getUser ( ) . getTemp ( SESSION_REGISTER ) ; Group register = null ; if ( ( user != null ) && ( user instanceof ScarabUser ) ) { register = intake . get ( "Register" , ( ( ScarabUser ) ( user ) ) . getQueryKey ( ) , false ) ; } else { register = intake . get ( "Register" , DEFAULT_KEY , false ) ; } <START_BUG> String username = register . get ( "Email" ) . toString ( ) ; <END_BUG> String oldPassword = register . get ( "OldPassword" ) . toString ( ) ; String password = register . get ( "Password" ) . toString ( ) ; String passwordConfirm = register . get ( "PasswordConfirm" ) . toString ( ) ; if ( oldPassword . equals ( password ) ) { getScarabRequestTool ( context ) . setInfoMessage ( ( "Your<seq2seq4repair_space>new<seq2seq4repair_space>password<seq2seq4repair_space>was<seq2seq4repair_space>the<seq2seq4repair_space>same<seq2seq4repair_space>as<seq2seq4repair_space>your<seq2seq4repair_space>old<seq2seq4repair_space>one.<seq2seq4repair_space>" + "Your<seq2seq4repair_space>password<seq2seq4repair_space>has<seq2seq4repair_space>not<seq2seq4repair_space>been<seq2seq4repair_space>changed!" ) ) ; setTarget ( data , template ) ; } else if ( password . equals ( passwordConfirm ) ) { try { ScarabUser confirmedUser = ( ( ScarabUser ) ( TurbineSecurity . getUser ( username ) ) ) ; confirmedUser . setPasswordExpire ( ) ; confirmedUser . setHasLoggedIn ( Boolean . FALSE ) ; data . setUser ( confirmedUser ) ; data . save ( ) ; TurbineSecurity . changePassword ( confirmedUser , oldPassword , password ) ; getScarabRequestTool ( context ) . setConfirmMessage ( ( "Your<seq2seq4repair_space>password<seq2seq4repair_space>has<seq2seq4repair_space>been<seq2seq4repair_space>changed." + "<seq2seq4repair_space>Please<seq2seq4repair_space>login<seq2seq4repair_space>with<seq2seq4repair_space>your<seq2seq4repair_space>new<seq2seq4repair_space>password." ) ) ; setTarget ( data , "Login.vm" ) ; } catch ( PasswordMismatchException pme ) { getScarabRequestTool ( context ) . setAlertMessage ( pme . getMessage ( ) ) ; setTarget ( data , template ) ; } } else { getScarabRequestTool ( context ) . setAlertMessage ( "The<seq2seq4repair_space>passwords<seq2seq4repair_space>you<seq2seq4repair_space>entered<seq2seq4repair_space>do<seq2seq4repair_space>not<seq2seq4repair_space>match!" ) ; setTarget ( data , template ) ; } } } }
@ RunWith ( SpringJUnit4ClassRunner . class ) @ ContextConfiguration ( classes = ApplicationConfig . class ) @ ActiveProfiles ( "dev" ) @ Transactional @ WebAppConfiguration public class MessageRepositoryTest { @ Autowired private MessageRepository messageRepository ; @ Test public void testFindByMessageAuthor ( ) { Message message = new Message ( "test_user" , "hello<seq2seq4repair_space>world" ) ; messageRepository . save ( message ) ; List < Message > messages = messageRepository . findByMessageAuthor ( "test_user" ) ; assertNotNull ( messages ) ; assertFalse ( messages . isEmpty ( ) ) ; <START_BUG> assertEquals ( 2 , messages . size ( ) ) ; <END_BUG> } @ Test public void testFindByAll ( ) { } }
void setBackgroundPixel ( int pixel ) { } void setCheckboxImageListColor ( ) { } void setCheckboxImageList ( int width , int height ) { } void setFocusIndex ( int index ) { } public void setFont ( Font font ) { } void setForegroundPixel ( int pixel ) { } public void setHeaderVisible ( boolean show ) { } public void setItemCount ( int count ) { } void setItemHeight ( ) { } public void setLinesVisible ( boolean show ) { } public void setRedraw ( boolean redraw ) { } boolean setScrollWidth ( TableItem item , boolean force ) { } public void setSelection ( int [ ] indices ) { } public void setSelection ( TableItem [ ] items ) { } public void setSelection ( int index ) { } public void setSelection ( int start , int end ) { } void setTableEmpty ( ) { } public void setTopIndex ( int index ) { } public void showColumn ( TableColumn column ) { } void showItem ( int index ) { } public void showItem ( TableItem item ) { } public void showSelection ( ) { } String toolTipText ( NMTTDISPINFO hdr ) { } int widgetStyle ( ) { } TCHAR windowClass ( ) { } int windowProc ( ) { } LRESULT WM_CHAR ( int wParam , int lParam ) { } LRESULT WM_ERASEBKGND ( int wParam , int lParam ) { } LRESULT WM_GETOBJECT ( int wParam , int lParam ) { } LRESULT WM_KEYDOWN ( int wParam , int lParam ) { } LRESULT WM_LBUTTONDBLCLK ( int wParam , int lParam ) { } LRESULT WM_LBUTTONDOWN ( int wParam , int lParam ) { } LRESULT WM_LBUTTONUP ( int wParam , int lParam ) { } LRESULT WM_MOUSEHOVER ( int wParam , int lParam ) { } LRESULT WM_PAINT ( int wParam , int lParam ) { } LRESULT WM_NOTIFY ( int wParam , int lParam ) { NMHDR hdr = new NMHDR ( ) ; OS . MoveMemory ( hdr , lParam , sizeof ) ; int hwndHeader = OS . SendMessage ( handle , LVM_GETHEADER , 0 , 0 ) ; if ( ( hdr . hwndFrom ) == hwndHeader ) { switch ( hdr . code ) { case OS . HDN_BEGINTRACKW : case OS . HDN_BEGINTRACKA : case OS . HDN_DIVIDERDBLCLICKW : case OS . HDN_DIVIDERDBLCLICKA : { NMHEADER phdn = new NMHEADER ( ) ; OS . MoveMemory ( phdn , lParam , NMHEADER . sizeof ) ; TableColumn column = columns [ phdn . iItem ] ; if ( ( column != null ) && ( ! ( column . getResizable ( ) ) ) ) { return LRESULT . ONE ; } break ; } case OS . HDN_ITEMCHANGEDW : case OS . HDN_ITEMCHANGEDA : { int width = OS . SendMessage ( handle , LVM_GETCOLUMNWIDTH , 0 , 0 ) ; if ( ( ( lastWidth ) == 0 ) && ( width > 0 ) ) { int bits = OS . SendMessage ( handle , LVM_GETEXTENDEDLISTVIEWSTYLE , 0 , 0 ) ; if ( ( bits & ( OS . LVS_EX_GRIDLINES ) ) != 0 ) { RECT rect = new RECT ( ) ; OS . GetClientRect ( handle , rect ) ; rect . right = ( rect . left ) + width ; OS . InvalidateRect ( handle , rect , true ) ; } } lastWidth = width ; if ( ! ( ignoreResize ) ) { NMHEADER phdn = new NMHEADER ( ) ; OS . MoveMemory ( phdn , lParam , NMHEADER . sizeof ) ; if ( ( phdn . pitem ) != 0 ) { HDITEM pitem = new HDITEM ( ) ; OS . MoveMemory ( pitem , phdn . pitem , HDITEM . sizeof ) ; if ( ( ( pitem . mask ) & ( OS . HDI_WIDTH ) ) != 0 ) { TableColumn column = columns [ phdn . iItem ] ; if ( column != null ) { column . sendEvent ( Resize ) ; if ( isDisposed ( ) ) return LRESULT . ZERO ; int count = OS . SendMessage ( hwndHeader , HDM_GETITEMCOUNT , 0 , 0 ) ; if ( ( count == 1 ) && ( ( columns [ 0 ] ) == null ) ) count = 0 ; TableColumn [ ] newColumns = new TableColumn [ count ] ; System . arraycopy ( columns , 0 , newColumns , 0 , count ) ; for ( int i = ( phdn . iItem ) + 1 ; i < count ; i ++ ) { <START_BUG> if ( ( ( newColumns [ i ] ) != null ) && ( ! ( newColumns [ i ] . isDisposed ( ) ) ) ) { <END_BUG> newColumns [ i ] . sendEvent ( Move ) ; } } } } } } break ; } case OS . HDN_ITEMDBLCLICKW : case OS . HDN_ITEMDBLCLICKA : { NMHEADER phdn = new NMHEADER ( ) ; OS . MoveMemory ( phdn , lParam , NMHEADER . sizeof ) ; TableColumn column = columns [ phdn . iItem ] ; if ( column != null ) { column . postEvent ( DefaultSelection ) ; } break ; } } } return super . WM_NOTIFY ( wParam , lParam ) ; } LRESULT WM_RBUTTONDBLCLK ( int wParam , int lParam ) { } LRESULT WM_RBUTTONDOWN ( int wParam , int lParam ) { } LRESULT WM_SETFOCUS ( int wParam , int lParam ) { } LRESULT WM_SIZE ( int wParam , int lParam ) { } LRESULT WM_SYSCOLORCHANGE ( int wParam , int lParam ) { } LRESULT WM_VSCROLL ( int wParam , int lParam ) { } LRESULT WM_WINDOWPOSCHANGED ( int wParam , int lParam ) { } LRESULT wmNotifyChild ( int wParam , int lParam ) { } }
public class IrcBot { public static final IrcBot instance = new IrcBot ( ) ; public static CLogger LOGGER ; private final MemBuffer buffer = new MemBuffer ( ) ; private boolean isRunning = false ; private boolean canRun = true ; private String shutdownReason = null ; private IrcListener handler ; private IrcConnection connection ; private NickServ nickServ ; private Admins admins ; private Auth auth ; private StringCheck stringCheck ; private BlackList blacklist ; private AutoJoinList autoJoinList ; private IrcBot ( ) { } private void start ( ) { } private void init ( ) { } private void onTick ( ) { } private void end ( int code ) { } public void stop ( ) { } public void stop ( String reason ) { } public IrcListener getHandler ( ) { } public IrcConnection getConnection ( ) { } public String getVersionString ( ) { <START_BUG> return "AcomputerBot<seq2seq4repair_space>v0.13" ; <END_BUG> } public boolean canRun ( ) { } public NickServ getNickServ ( ) { } public Admins getAdmins ( ) { } public Auth getAuth ( ) { } public StringCheck getStringCheck ( ) { } public BlackList getBlacklist ( ) { } public static void main ( String [ ] args ) { } }
public class SharedObjectFactory implements ISharedObjectFactory { private static Trace debug = Trace . create ( "containerfactory" ) ; private static Hashtable sharedobjectdescriptions = new Hashtable ( ) ; protected static ISharedObjectFactory instance = null ; protected SharedObjectFactory ( ) { } public static ISharedObjectFactory getDefault ( ) { } private static void trace ( String msg ) { } private static void dumpStack ( String msg , Throwable e ) { } public SharedObjectDescription addDescription ( SharedObjectDescription description ) { } public List getDescriptions ( ) { } protected List getDescriptions0 ( ) { } protected SharedObjectDescription addDescription0 ( SharedObjectDescription n ) { } public boolean containsDescription ( SharedObjectDescription scd ) { } protected boolean containsDescription0 ( SharedObjectDescription scd ) { } protected SharedObjectDescription getDescription0 ( SharedObjectDescription scd ) { } protected SharedObjectDescription getDescription0 ( String name ) { } public SharedObjectDescription getDescriptionByName ( String name ) throws SharedObjectInstantiationException { } public ISharedObject createSharedObject ( SharedObjectDescription desc , String [ ] argTypes , Object [ ] args ) throws SharedObjectInstantiationException { SharedObjectFactory . trace ( ( ( ( ( ( ( "createSharedObject(" + desc ) + "," ) + ( Trace . convertStringAToString ( argTypes ) ) ) + "," ) + ( Trace . convertObjectAToString ( args ) ) ) + ")" ) ) ; if ( desc == null ) throw new SharedObjectInstantiationException ( "SharedObjectDescription<seq2seq4repair_space>cannot<seq2seq4repair_space>be<seq2seq4repair_space>null" ) ; SharedObjectDescription cd = getDescription0 ( desc ) ; if ( cd == null ) throw new SharedObjectInstantiationException ( ( ( "SharedObjectDescription<seq2seq4repair_space>named<seq2seq4repair_space>'" + ( desc . getName ( ) ) ) + "'<seq2seq4repair_space>not<seq2seq4repair_space>found" ) ) ; Class [ ] clazzes = null ; ISharedObjectInstantiator instantiator = null ; try { instantiator = ( ( ISharedObjectInstantiator ) ( cd . getInstantiator ( ) ) ) ; <START_BUG> clazzes = AbstractFactory . getClassesForTypes ( argTypes , args , cd . getClassLoader ( ) ) ; <END_BUG> } catch ( Exception e ) { SharedObjectInstantiationException newexcept = new SharedObjectInstantiationException ( ( ( ( ( ( "createSharedObject<seq2seq4repair_space>exception<seq2seq4repair_space>with<seq2seq4repair_space>description:<seq2seq4repair_space>" + desc ) + ":<seq2seq4repair_space>" ) + ( e . getClass ( ) . getName ( ) ) ) + ":<seq2seq4repair_space>" ) + ( e . getMessage ( ) ) ) ) ; newexcept . setStackTrace ( e . getStackTrace ( ) ) ; SharedObjectFactory . dumpStack ( "Exception<seq2seq4repair_space>in<seq2seq4repair_space>createSharedObject" , newexcept ) ; throw newexcept ; } if ( instantiator == null ) throw new SharedObjectInstantiationException ( ( ( "Instantiator<seq2seq4repair_space>for<seq2seq4repair_space>SharedObjectDescription<seq2seq4repair_space>" + ( cd . getName ( ) ) ) + "<seq2seq4repair_space>is<seq2seq4repair_space>null" ) ) ; return ( ( ISharedObject ) ( instantiator . createInstance ( desc , clazzes , args ) ) ) ; } public ISharedObject createSharedObject ( String descriptionName ) throws SharedObjectInstantiationException { } public ISharedObject createSharedObject ( String descriptionName , Object [ ] args ) throws SharedObjectInstantiationException { } public ISharedObject createSharedObject ( String descriptionName , String [ ] argsTypes , Object [ ] args ) throws SharedObjectInstantiationException { } public SharedObjectDescription removeDescription ( SharedObjectDescription scd ) { } protected SharedObjectDescription removeDescription0 ( SharedObjectDescription n ) { } }
public class TransactionAction { private RealShop2Plugin plugin ; public TransactionAction ( RealShop2Plugin plugin ) { } public int buy ( Player player , Shop shop , ItemStack itemStack ) { } public Price calculatePrice ( Shop shop , ItemStack itemStack ) { } public Price calculatePrice ( Shop shop , RealItemStack itemStack ) { RealItemType itemType = itemStack . getItemType ( ) ; <START_BUG> ItemPriceList prices = new ItemPriceList ( plugin , shop . getPlayerName ( ) ) ; <END_BUG> Price price = prices . getPrice ( itemType , itemStack . getDamage ( ) , plugin . getMarketPrices ( ) ) ; return price ; } public boolean canPay ( Player player , Shop shop , ItemStack buyStack , ItemStack sellStack ) { } public int sell ( Player player , Shop shop , ItemStack itemStack ) { } private void sendMessage ( Player player , Shop shop , ItemStack itemStack , double price , double amount , String side , String shopSide ) { } }
